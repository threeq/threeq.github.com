[{"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/11-view-index/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第十一天：索引和视图", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/11-view-index/", "content": "已经介绍了 SQL 的查询、定义、插入、修改、删除等操作，接下来将介绍数据库另一个重要的知识点：索引，特别是在查询优化的时候，索引 将是优化的最重要手段之一。查询本身会随着我们的应用功能的增强，不断的增加复杂度，这时就需要管理复杂查询的手段：视图 。\n知识要点\n 索引 MySQL 索引操作语句 BTREE 和 HASH 视图  这里的内容可能有点难，有一定使用经验可能会更容易理解。不过没有关系只要知道索引的基本概念和操作语句就行，大家真的在使用到时再来看或查询相关资料就可以了。\n\n现代数据库无一不包含 索引。首先我们需要理解为什么？就像之前说的，数据库是用来做大量数据管理和查询的系统。在现在这个以数据为中心的时代，任意一个业务系统数据量也是动辄百万了，大部分业务系统都在千万到亿这个级别，现在大家平时接触到的系统在亿这个级别的很多。这么大的数据量存储在磁盘中，怎么能快速的获取我们所需要的数据？总不能每次都取出全部数据吧！（当然这里数据的高效存储也非常重要，不过这个已经超出了这里范围了不做介绍）\n索引 数据库中的所有数据都会持久化的磁盘中，磁盘读取速度是很慢的，并且数据库里的数据都会比较大，如果我们每次查询都从磁盘里面读入所有数据进行比较过滤，那将会是非常慢的。所以数据库为了更快的检索需要的数据，就需要使用一种高效的数据结构来组织编目原始数据，这就是这里介绍的： 索引。\n大家不要以为索引数据会很小，其实索引也是很大的。如果索引长度是 16字节，表数据量是 1亿，那表的这个索引存储需要的空间至少是15G（因为在存储的时候还需要存储索引结构的其他信息）。计算机的内存资源是很昂贵的，且索引数据也需要永久存储，所以索引结构数据也是存储在磁盘里面。数据库在读取数据时是按照每页读取的，数据库会以页为单位缓存已经读取的索引数据。关于如何估算页数量不在本文内容中，但是这个对于理解如何优化 SQL 会很重要，感兴趣的可以查询相关资料。\nMySQL 索引语法 MySQL 里面索引管理使用 alter 语句，对于创建索引还可以使用 create index 语句。\nCreate Index create index 语句只是 alter table 语句的另一种语法， 可以完全映射到 alter table 创建索引语句中。并且 create index 不能用于 主键 的创建，主键 的创建需要使用 alter 语句或在 create table 表结构创建语句中。\nCREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [index_type] ON tbl_name (index_col_name,...) [index_option] [algorithm_option | lock_option] ... index_col_name: col_name [(length)] [ASC | DESC] index_option: KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string' index_type: USING {BTREE | HASH} algorithm_option: ALGORITHM [=] {DEFAULT|INPLACE|COPY} lock_option: LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}  Alter 语句 使用ALTER 语句添加索引\nAlter TABLE tbl_name ADD [INDEX|UNIQUE|FULLTEXT|SPATIAL] index_name(index_col_name,...);  使用 ALTER 语句添加主键\nALTER TABLE tbl_name ADD PRIMARY KEY (index_col_name,...);  删除索引\nALTER TABLE tbl_name DROP INDEX index_name;  删除主键\nALTER TABLE tbl_name DROP PRIMARY KEY;  你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \\G 来格式化输出信息。\nSHOW INDEX FROM tbl_name; \\G  这里这里我把主键和外键也看做是索引，他们只是索引的 2 中特殊类型\n  索引分类：普通索引（默认）、唯一索引（unique）、全文索引（fulltext）、空间索引（spatial）、主键、外键 普通索引和唯一索引的数据结构类型可以有：BTree 和 Hash 空间索引使用 R-Tree，也叫 R-Tree 索引 主键一个表只能有一个，可以包含多个列，且列的数据(如果是多列，就是组合数据)必须唯一，且列值不能为 NULL 当遇到比较大的字符串字段，可以仅仅使用字段前面部分数据创建索引   索引类型 这里面 主键、外键、普通索引、唯一索引 比较常见，全文索引 和 空间索引 在一些特定的业务场景里面会使用到。\n针对 普通索引 和 唯一索引 ，底层的存储的数据类型可以有2个选择：一个是 B Tree，一个是 Hash。由于底层的数据结构不同，所以两种类型支持的操作也有所区别。并且不同的存储引擎对索引类型的支持也是不同的。全文索引的数据结构类型的实现依赖于存储引擎，空间索引使用 R-Tree 实现。\n   存储引擎类型 索引类型     InnoDB BTREE   MyISAM BTREE   MEMORY/HEAP HASH, BTREE   NDB HASH, BTREE    不同存储引擎对于索引类型支持的特性也是不同的。\nInnoDB 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No N/A N/A   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   FULLTEXT N/A Yes Yes Table Table   SPATIAL N/A No No N/A N/A    MyISAM 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No N/A N/A   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   FULLTEXT N/A Yes Yes Table Table   SPATIAL N/A No No N/A N/A    MEMORY 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No N/A N/A   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   Primary key HASH No No N/A N/A   Unique HASH Yes Yes Index Index   Key HASH Yes Yes Index Index    NDB 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No Index Index   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   Primary key HASH No No Table (see note 1) Table (see note 1)   Unique HASH Yes Yes Table (see note 1) Table (see note 1)   Key HASH Yes Yes Table (see note 1) Table (see note 1)     注意\n  如果使用 HASH ，则可以防止创建隐式有序索引。   说了这么多 BTREE 和 Hash 对于我们平时使用有什么差异。\n  B-Tree 支持的操作有等于、不等于、小于、小于、Between、前缀 like，in Hash 支持支 等于和不等于 2 种操作。特别注意它是不支持 大于、小于之类的区间型条件的，因为 Hash 类型是无序的，并且对于 order by 排序操作不能使用 Hash 索引加快速度 like 操作如果不是前缀匹配是不能使用使用索引的。如 col_name like 'aa%' 是可以使用索引的，但是 col_name like '%aa' 和 col_name like '%aa%' 都不能使用索引。   索引使用分析 正所谓 过早优化是万恶之源 。我们 不应该在一创建表时就创建索引，应该是在查询真的慢的时候才创建索引 ，因为索引在提高查询速度的时候，也会使 insert、update、delete 语句的操作变慢，并且随着业务功能的迭代，索引也需要跟着优化和修改。这就需要有一定的索引分析手段。\n1、索引分析手段\n ① 针对单个 SQL 可以使用 执行计划 查看索引使用情况\n② 可以使用 show status like 'Handler_read%'; 查看 MySQL 索引使用率\n③ 针对数据库中未使用索引分析，可以收集一段时间内数据库执行的所有 SQL 语句，然后使用三方工具分析数据库中哪些索引已经 失效 。比如 pt-index-usage 等。\n 2、创建索引时需要注意\n ①主键自动建立唯一索引\n②频繁作为查询条件的字段应该创建索引\n③查询中与其他表关联的字段，外键关系建立索引\n④频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引\n⑤WHERE条件里用不到的字段不创建索引\n⑥单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)\n⑦查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度\n⑧查询中统计或者分组字段\n 3、哪些情况不要创建索引\n ①表记录太少\n②经常增删改的表\n　提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。\n　因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。\n　数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。\n③注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。\n 视图 什么是视图？ 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。可以简单的理解成：视图就是存储在数据库中并具有名字的 SQL 语句 ，它是管理复杂 SQL 查询的一种方式。\n视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。\n视图，一种虚拟的表，允许用户执行以下操作：\n 以用户或者某些类型的用户感觉自然或者直观的方式来组织数据； 限制对数据的访问，从而使得用户仅能够看到或者修改（某些情况下）他们需要的数据； 从多个表中汇总数据，以产生报表。  注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。\nSQL 创建视图 CREATE VIEW view_name AS SELECT column_name(s)[,...] FROM table_name WHERE condition  注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。\n可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join 等等，我们可以向用户精确地提交我们希望提交的数据。\n以之前的学生表为例子，创建一个包含学生名字、学生参与班级名称、根据学生生日计算的年龄视图\nCREATE VIEW student_view AS SELECT s.s_name, year(now())-year(s.s_birthday), c.c_name FROM student s,class c, student_join_class sc where s.s_id=sc.s_id and c.c_id=sc.c_id  我们可以查询上面这个视图：\nSELECT * FROM student_view   试试\n [ ] 创建一个包含班级 id、班级名称、班主任、参与人员的视图，视图名称 class_view。（*注意统计函数所使用的字段*）\n  SQL 更新视图 视图可以在特定的情况下更新：\n SELECT 子句不能包含任何汇总函数（summary functions） SELECT 子句不能包含任何集合函数（set functions） SELECT 子句不能包含任何集合运算符（set operators） 查询语句中不能有 GROUP BY 或者 HAVING  如果视图满足以上所有的条件，该视图就可以被更新。当然如果需要通过视图使用 insert 语句，那还需要满足其他条件，不过个人不建议这样使用。\n您可以使用下面的语法来更新视图：\nCREATE OR REPLACE VIEW view_name AS SELECT column_name(s)[,...] FROM table_name WHERE condition  现在，向 student_view 中加入性别、地址信息：\nCREATE OR REPLACE VIEW student_view AS SELECT s.s_name, year(now())-year(s.s_birthday), c.c_name, s.s_sex, s.s_addr FROM student s,class c, student_join_class sc where s.s_id=sc.s_id and c.c_id=sc.c_id;  查询上面这个视图，看修改结果：\nSELECT * FROM student_view  SQL 删除视图 您可以通过 DROP VIEW 命令来删除视图。\nDROP VIEW view_name  :试试\n向 class_view 中加入参与学生的平均年龄。（需要先删除再创建）  总结  索引：索引创建、作用、分析索引使用情况 视图：视图创建、修改、删除、使用 ", "content_s": "已经 介绍 了   SQL   的 查询 、 定义 、 插入 、 修改 、 删除 等 操作 ， 接下 下来 接下来 将 介绍 数据 据库 数据库 另 一个 重要 的 知识 知识点 ： 索引 ， 特别 是 在 查询 优化 的 时候 ， 索引   将 是 优化 的 最 重要 手段 之一 。 查询 本身 会 随着 我们 的 应用 功能 的 增强 ， 不断 的 增加 复杂 复杂度 ， 这时 就 需要 管理 复杂 查询 的 手段 ： 视图   。 \n 知识 要点 \n   索引   MySQL   索引 操作 语句   BTREE   和   HASH   视图     这里 的 内容 可能 有点 难 ， 有 一定 使用 经验 可能 会 更 容易 理解 。 不过 没有 关系 只要 知道 索引 的 基本 概念 基本概念 和 操作 语句 就行 ， 大家 真的 在 使用 到 时 再 来看 或 查询 相关 资料 就 可以 了 。 \n \n 现代 数据 据库 数据库 无一 不 包含   索引 。 首先 我们 需要 理解 什么 为什么 ？ 就 像 之前 说 的 ， 数据 据库 数据库 是 用来 做 大量 数据 管理 数据管理 和 查询 的 系统 。 在 现在 这个 以 数据 为 中心 的 时代 ， 任意 一个 业务 系统 数据 数据量 也 是 动辄 百万 了 ， 大部 部分 大部分 业务 系统 都 在 千万 到 亿 这个 级别 ， 现在 大家 平时 接触 到 的 系统 在 亿 这个 级别 的 很多 。 这么 大 的 数据 数据量 存储 在 磁盘 中 ， 怎么 能 快速 的 获取 我们 所 需要 的 数据 ？ 总 不能 每次 都 取出 全部 数据 吧 ！ （ 当然 这里 数据 的 高效 存储 也 非常 重要 ， 不过 这个 已经 超出 了 这里 范围 了 不 做 介绍 ） \n 索引   数据 据库 数据库 中 的 所有 数据 都 会 持久 化 的 磁盘 中 ， 磁盘 读取 速度 是 很 慢 的 ， 并且 数据 据库 数据库 里 的 数据 都 会 比较 大 ， 如果 我们 每次 查询 都 从 磁盘 里面 读入 所有 数据 进行 比较 过滤 ， 那 将 会 是 非常 慢 的 。 所以 数据 据库 数据库 为了 更快 的 检索 需要 的 数据 ， 就 需要 使用 一种 高效 的 数据 结构 数据结构 来 组织 编目 原始 数据 原始数据 ， 这 就是 这里 介绍 的 ：   索引 。 \n 大家 不要 以为 索引 数据 会 很小 ， 其实 索引 也 是 很大 的 。 如果 索引 长度 是   16 字节 ， 表 数据 数据量 是   1 亿 ， 那表 的 这个 索引 存储 需要 的 空间 至少 是 15G （ 因为 在 存储 的 时候 还 需要 存储 索引 结构 的 其他 信息 ） 。 计算 算机 计算机 的 内存 资源 是 很 昂贵 的 ， 且 索引 数据 也 需要 永久 存储 ， 所以 索引 结构 数据 也 是 存储 在 磁盘 里面 。 数据 据库 数据库 在 读取 数据 读取数据 时 是 按照 每页 读取 的 ， 数据 据库 数据库 会 以页 为 单位 缓存 已经 读取 的 索引 数据 。 关于 如何 估算 页 数量 不 在 本文 内容 中 ， 但是 这个 对于 理解 如何 优化   SQL   会 很 重要 ， 感兴 兴趣 感兴趣 的 可以 查询 相关 资料 。 \n MySQL   索引 语法   MySQL   里面 索引 管理 使用   alter   语句 ， 对于 创建 索引 还 可以 使用   create   index   语句 。 \n Create   Index   create   index   语句 只是   alter   table   语句 的 另 一种 语法 ，   可以 完全 映射 到   alter   table   创建 索引 语句 中 。 并且   create   index   不能 用于   主键   的 创建 ， 主键   的 创建 需要 使用   alter   语句 或 在   create   table   表 结构 创建 语句 中 。 \n CREATE   [ UNIQUE | FULLTEXT | SPATIAL ]   INDEX   index _ name   [ index _ type ]   ON   tbl _ name   ( index _ col _ name , ... )   [ index _ option ]   [ algorithm _ option   |   lock _ option ]   ...   index _ col _ name :   col _ name   [ ( length ) ]   [ ASC   |   DESC ]   index _ option :   KEY _ BLOCK _ SIZE   [ = ]   value   |   index _ type   |   WITH   PARSER   parser _ name   |   COMMENT   ' string '   index _ type :   USING   { BTREE   |   HASH }   algorithm _ option :   ALGORITHM   [ = ]   { DEFAULT | INPLACE | COPY }   lock _ option :   LOCK   [ = ]   { DEFAULT | NONE | SHARED | EXCLUSIVE }     Alter   语句   使用 ALTER   语句 添加 索引 \n Alter   TABLE   tbl _ name   ADD   [ INDEX | UNIQUE | FULLTEXT | SPATIAL ]   index _ name ( index _ col _ name , ... ) ;     使用   ALTER   语句 添加 主键 \n ALTER   TABLE   tbl _ name   ADD   PRIMARY   KEY   ( index _ col _ name , ... ) ;     删除 索引 \n ALTER   TABLE   tbl _ name   DROP   INDEX   index _ name ;     删除 主键 \n ALTER   TABLE   tbl _ name   DROP   PRIMARY   KEY ;     你 可以 使用   SHOW   INDEX   命令 来 列出 表中 的 相关 的 索引 信息 。 可以 通过 添加   \\ G   来 格式 格式化 输出 信息 。 \n SHOW   INDEX   FROM   tbl _ name ;   \\ G     这里 这里 我 把 主键 和 外键 也 看做 是 索引 ， 他们 只是 索引 的   2   中 特殊 类型 \n     索引 分类 ： 普通 索引 （ 默认 ） 、 唯一 索引 （ unique ） 、 全文 索引 全文索引 （ fulltext ） 、 空间 索引 （ spatial ） 、 主键 、 外键   普通 索引 和 唯一 索引 的 数据 结构 数据结构 类型 可以 有 ： BTree   和   Hash   空间 索引 使用   R - Tree ， 也 叫   R - Tree   索引   主键 一个 表 只能 有 一个 ， 可以 包含 多个 列 ， 且列 的 数据 ( 如果 是 多列 ， 就是 组合 数据 ) 必须 唯一 ， 且 列值 不能 为   NULL   当 遇到 比较 大 的 字符 字符串 字 段 ， 可以 仅仅 使用 字 段 前面 部分 数据 创建 索引       索引 类型   这 里面   主键 、 外键 、 普通 索引 、 唯一 索引   比较 常见 ， 全文 索引 全文索引   和   空间 索引   在 一些 特定 的 业务 场景 里面 会 使用 到 。 \n 针对   普通 索引   和   唯一 索引   ， 底层 的 存储 的 数据 类型 数据类型 可以 有 2 个 选择 ： 一个 是   B   Tree ， 一个 是   Hash 。 由于 底层 的 数据 结构 数据结构 不同 ， 所以 两种 类型 支持 的 操作 也 有所 区别 有所区别 。 并且 不同 的 存储 引擎 对 索引 类型 的 支持 也 是 不同 的 。 全文 索引 全文索引 的 数据 结构 数据结构 类型 的 实现 依赖 赖于 依赖于 存储 引擎 ， 空间 索引 使用   R - Tree   实现 。 \n       存储 引擎 类型   索引 类型           InnoDB   BTREE       MyISAM   BTREE       MEMORY / HEAP   HASH ,   BTREE       NDB   HASH ,   BTREE         不同 存储 引擎 对于 索引 类型 支持 的 特性 也 是 不同 的 。 \n InnoDB   存储 引擎 支持 特性 \n       索引 分类   索引 类型   Null   值   多个   NULL 值   IS   NULL   扫描 方式   IS   NOT   NULL   扫描 方式           Primary   key   BTREE   No   No   N / A   N / A       Unique   BTREE   Yes   Yes   Index   Index       Key   BTREE   Yes   Yes   Index   Index       FULLTEXT   N / A   Yes   Yes   Table   Table       SPATIAL   N / A   No   No   N / A   N / A         MyISAM   存储 引擎 支持 特性 \n       索引 分类   索引 类型   Null   值   多个   NULL 值   IS   NULL   扫描 方式   IS   NOT   NULL   扫描 方式           Primary   key   BTREE   No   No   N / A   N / A       Unique   BTREE   Yes   Yes   Index   Index       Key   BTREE   Yes   Yes   Index   Index       FULLTEXT   N / A   Yes   Yes   Table   Table       SPATIAL   N / A   No   No   N / A   N / A         MEMORY   存储 引擎 支持 特性 \n       索引 分类   索引 类型   Null   值   多个   NULL 值   IS   NULL   扫描 方式   IS   NOT   NULL   扫描 方式           Primary   key   BTREE   No   No   N / A   N / A       Unique   BTREE   Yes   Yes   Index   Index       Key   BTREE   Yes   Yes   Index   Index       Primary   key   HASH   No   No   N / A   N / A       Unique   HASH   Yes   Yes   Index   Index       Key   HASH   Yes   Yes   Index   Index         NDB   存储 引擎 支持 特性 \n       索引 分类   索引 类型   Null   值   多个   NULL 值   IS   NULL   扫描 方式   IS   NOT   NULL   扫描 方式           Primary   key   BTREE   No   No   Index   Index       Unique   BTREE   Yes   Yes   Index   Index       Key   BTREE   Yes   Yes   Index   Index       Primary   key   HASH   No   No   Table   ( see   note   1 )   Table   ( see   note   1 )       Unique   HASH   Yes   Yes   Table   ( see   note   1 )   Table   ( see   note   1 )       Key   HASH   Yes   Yes   Table   ( see   note   1 )   Table   ( see   note   1 )           注意 \n     如果 使用   HASH   ， 则 可以 防止 创建 隐式 有序 索引 。       说 了 这么 多   BTREE   和   Hash   对于 我们 平时 使用 有 什么 差异 。 \n     B - Tree   支持 的 操作 有 等于 、 不 等于 、 小于 、 小于 、 Between 、 前缀   like ， in   Hash   支持 支   等于 和 不 等于   2   种 操作 。 特别 注意 它 是 不 支持   大于 、 小于 之类 的 区间 型 条件 的 ， 因为   Hash   类型 是 无序 的 ， 并且 对于   order   by   排序 操作 不能 使用   Hash   索引 加快 快速 速度 加快速度   like   操作 如果 不是 前缀 匹配 是 不能 使用 使用 索引 的 。 如   col _ name   like   ' aa% '   是 可以 使用 索引 的 ， 但是   col _ name   like   ' % aa '   和   col _ name   like   ' % aa% '   都 不能 使用 索引 。       索引 使用 分析   正 所谓   过早 优化 是 万恶 万恶之源   。 我们   不 应该 在 一 创建 表时 就 创建 索引 ， 应该 是 在 查询 真的 慢 的 时候 才 创建 索引   ， 因为 索引 在 提高 查询 速度 的 时候 ， 也 会 使   insert 、 update 、 delete   语句 的 操作 变慢 ， 并且 随着 业务 功能 的 迭代 ， 索引 也 需要 跟着 优化 和 修改 。 这 就 需要 有 一定 的 索引 分析 手段 。 \n 1 、 索引 分析 手段 \n   ①   针对 单个   SQL   可以 使用   执行 计划   查看 索引 使用 情况 \n ②   可以 使用   show   status   like   ' Handler _ read% ' ;   查看   MySQL   索引 使用 用率 使用率 \n ③   针对 数据 据库 数据库 中未 使用 索引 分析 ， 可以 收集 一段 时间 段时间 一段时间 内 数据 据库 数据库 执行 的 所有   SQL   语句 ， 然后 使用 三方 工具 分析 数据 据库 数据库 中 哪些 索引 已经   失效   。 比如   pt - index - usage   等 。 \n   2 、 创建 索引 时 需要 注意 \n   ① 主键 自动 建立 唯一 索引 \n ② 频繁 作为 查询 条件 的 字 段 应该 创建 索引 \n ③ 查询 中 与 其他 表 关联 的 字 段 ， 外键 关系 建立 索引 \n ④ 频繁 更新 的 字 段 不 适合 建立 索引 ， 因为 每次 更新 不单 单单 单单是 不单单是 更新 了 记录 还会 更新 索引 \n ⑤ WHERE 条件 里 用 不到 的 字 段 不 创建 索引 \n ⑥ 单键 / 组合 索引 的 选择 问题 ， who ? ( 在 高 并发 下 倾向 创建 组合 索引 ) \n ⑦ 查询 中 排序 的 字 段 ， 排序 的 字 段 若 通过 索引 去 访问 将 大大 提高 大大提高 排序 速度 \n ⑧ 查询 中 统计 或者 分组 字 段 \n   3 、 哪些 情况 不要 创建 索引 \n   ① 表 记录 太 少 \n ② 经常 增删 改的表 \n 　 提高 了 查询 速度 ， 同时 却会 降低 更新 表 的 速度 ， 如对表 进行 INSERT 、 UPDATE 、 和 DELETE 。 \n 　 因为 更新 表时 ， MySQL 不仅 要 保存 数据 ， 还要 保存 一下 索引 文件 。 \n 　 数据 重复 且 分布 平均 的 表字 段 ， 因此 应该 只为 最 经常 查询 和 最 经常 排序 的 数据 建立 索引 。 \n ③ 注意 ， 如果 某个 数据 列 包含 许多 重复 的 内容 ， 为 它 建立 索引 就 没有 太大 的 实际 效果 实际效果 。 \n   视图   什么 是 视图 ？   在   SQL   中 ， 视图 是 基于   SQL   语句 的 结果 集 的 可视 可视化 的 表 。 可以 简单 的 理解 成 ： 视图 就是 存储 在 数据 据库 数据库 中 并 具有 名字 的   SQL   语句   ， 它 是 管理 复杂   SQL   查询 的 一种 方式 。 \n 视图 包含 行和列 ， 就 像 一个 真实 的 表 。 视图 中 的 字 段 就是 来自 一个 或 多个 数据 据库 数据库 中 的 真实 的 表中 的 字 段 。 我们 可以 向 视图 添加   SQL   函数 、 WHERE   以及   JOIN   语句 ， 我们 也 可以 提交 数据 ， 就 像 这些 来自 于 某个 单一 的 表 。 \n 视图 ， 一种 虚拟 的 表 ， 允许 用户 执行 以下 操作 ： \n   以 用户 或者 某些 类型 的 用户 感觉 自然 或者 直观 的 方式 来 组织 数据 ；   限制 对 数据 的 访问 ， 从而 使得 用户 仅 能够 看到 或者 修改 （ 某些 情况 下 ） 他们 需要 的 数据 ；   从 多个 表中 汇总 数据 ， 以 产生 报表 。     注释 ： 数据 据库 数据库 的 设计 和 结构 不会 受到 视图 中 的 函数 、 where   或   join   语句 的 影响 。 \n SQL   创建 视图   CREATE   VIEW   view _ name   AS   SELECT   column _ name ( s ) [ , ... ]   FROM   table _ name   WHERE   condition     注释 ： 视图 总是 显示 最近 的 数据 。 每当 用户 查询 视图 时 ， 数据 据库 数据库 引擎 通过 使用   SQL   语句 来 重建 数据 。 \n 可以 从 某个 查询 内部 、 某个 存储 过程 内部 ， 或者 从 另 一个 视图 内部 来 使用 视图 。 通过 向 视图 添加 函数 、 join   等等 ， 我们 可以 向 用户 精确 地 提交 我们 希望 提交 的 数据 。 \n 以 之前 的 学生 表为 例子 ， 创建 一个 包含 学生 名字 、 学生 参与 班级 名称 、 根据 学生 生日 计算 的 年龄 视图 \n CREATE   VIEW   student _ view   AS   SELECT   s . s _ name ,   year ( now ( ) ) - year ( s . s _ birthday ) ,   c . c _ name   FROM   student   s , class   c ,   student _ join _ class   sc   where   s . s _ id = sc . s _ id   and   c . c _ id = sc . c _ id     我们 可以 查询 上面 这个 视图 ： \n SELECT   *   FROM   student _ view       试试 \n   [   ]   创建 一个 包含 班级   id 、 班级 名称 、 班主 主任 班主任 、 参与 人员 的 视图 ， 视图 名称   class _ view 。 （ * 注意 统计 函数 所 使用 的 字 段 * ） \n     SQL   更新 视图   视图 可以 在 特定 的 情况 下 更新 ： \n   SELECT   子句 不能 包含 任何 汇总 函数 （ summary   functions ）   SELECT   子句 不能 包含 任何 集合 函数 （ set   functions ）   SELECT   子句 不能 包含 任何 集合 运算 算符 运算符 （ set   operators ）   查询 语句 中 不能 有   GROUP   BY   或者   HAVING     如果 视图 满足 以上 所有 的 条件 ， 该 视图 就 可以 被 更新 。 当然 如果 需要 通过 视图 使用   insert   语句 ， 那 还 需要 满足 其他 条件 ， 不过 个人 不 建议 这样 使用 。 \n 您 可以 使用 下面 的 语法 来 更新 视图 ： \n CREATE   OR   REPLACE   VIEW   view _ name   AS   SELECT   column _ name ( s ) [ , ... ]   FROM   table _ name   WHERE   condition     现在 ， 向   student _ view   中 加入 性别 、 地址 信息 ： \n CREATE   OR   REPLACE   VIEW   student _ view   AS   SELECT   s . s _ name ,   year ( now ( ) ) - year ( s . s _ birthday ) ,   c . c _ name ,   s . s _ sex ,   s . s _ addr   FROM   student   s , class   c ,   student _ join _ class   sc   where   s . s _ id = sc . s _ id   and   c . c _ id = sc . c _ id ;     查询 上面 这个 视图 ， 看 修改 结果 ： \n SELECT   *   FROM   student _ view     SQL   删除 视图   您 可以 通过   DROP   VIEW   命令 来 删除 视图 。 \n DROP   VIEW   view _ name     : 试试 \n 向   class _ view   中 加入 参与 学生 的 平均 年龄 平均年龄 。 （ 需要 先 删除 再 创建 ）     总结     索引 ： 索引 创建 、 作用 、 分析 索引 使用 情况   视图 ： 视图 创建 、 修改 、 删除 、 使用  ", "title_s": "小白学   SQL   第十 十一 一天 第十一 十一天 第十一天 ： 索引 和 视图"}, {"description": "随着微服务兴起前后端分离架构的越来越流行，前端的负责的开发任务越来越重，功能复杂度和代码量也越来越高，在同一个项目投入的前端人力也是越来越多，这个时候需要我们使用更加高效的方式来组织我们的代码结构。目前前端有很多框架帮我们做了很多这方面的工作，比如目前比较流行的的三大框架：angular、vue、react。但是我们在实际使用的时候往往发现，使用他们的命令行工具生成了一个工程，可以进行开发了，但是真正应用到真实项目中的时候，往往有力不从心的感觉，特别是企业及的项目中，这是由于它们做的只是从技术层面上解决了代码组织方式，并没有给出结合业务时项目里的组织结构和组织方法。本文介绍分层架构在前端开发中的实践。", "objectID": "https://blog.threeq.me/post/web/web-frontend-arch-practice/", "tags": ["架构", "前端"], "title": "前端分层架构实战（一）", "uri": "https://blog.threeq.me/post/web/web-frontend-arch-practice/", "content": "整个《前端分层架构实战》分成两部分：\n 前端分层架构实战（一）：分层架构问题分析和结构设计 前端分层架构实战（二）：分层架构项目规划和工程实施  本文是其中的第一篇。\n随着微服务兴起前后端分离架构的越来越流行，前端的负责的开发任务越来越重，功能复杂度和代码量也越来越高，在同一个项目投入的前端人力也是越来越多，这个时候需要我们使用更加高效的方式来组织我们的代码结构。目前前端有很多框架帮我们做了很多这方面的工作，比如目前比较流行的的三大框架：angular、vue、react。但是我们在实际使用的时候往往发现，使用他们的命令行工具生成了一个工程，可以进行开发了，但是真正应用到真实项目中的时候，往往有力不从心的感觉，特别是企业及的项目中，这是由于它们做的只是从技术层面上解决了代码组织方式，并没有给出结合业务时项目里的组织结构和组织方法。而这些正是软件架构所解决的问题，软件架构正在后端开发中大放异彩，那我们能不能也在前端开发中引入软件架构方法，来解决前端日益复杂的开发需求呢？答案是肯定的，下面简单说一下我自己在这里面的实践总结，由于个人能力有限，有不正确的地方欢迎大家指正。\n\n先从我们实际看到的页面效果出发，对我们页面的内容进行分析、设计。以下 2 中页面是我们最常见页面结构，一个是 PC 端常见的页面版式，一个是移动端常见的页面版式，列举这 2 个的目的就是说明在分析层模式的时候，对于 PC 端和移动端都是适用的，也说明我们移动端的页面也在往不断复杂的方向上发展。\n  pc 端    移动端    这个是页面展示是呈现的具体效果，那我们如何对其进行分层设计呢？试想如果我们看到的浏览器页面是有厚度的，上面的图是我们正对浏览器看到的页面效果，如果我们从斜上方去看我们的这个页面会是什么样子？。以下是一种简单的划分设计方式，这个层的划分是按照 HTML 的逻辑功能划分的，属于 HTML 逻辑层结构。\n以上层的拆分是我们在浏览器里面看到内容分层。其实大家所熟悉的 CSS 逻辑层结构划分也是这样的，也即是说 HTML 和 CSS 共享逻辑层结构。这是是正确的，因为界面的呈现使用 HTML 和 CSS 共同完成的，所以它们应该共享相同的逻辑层划分。其实这个层逻辑结构就是通过 CSS 的 z-index 来实现的。其实在我们实际规划 CSS 和 HTML 逻辑层的时候，往往比上面会多一些，一般是4~5层，比如下面是项目中可能存在的一种划分方式\n在开发的项目工程中物理文件组织是没有按照这个逻辑层去组织的，如果按照逻辑层去组织的代码，当项目代码逐渐增多时代码管理起来将会非常麻烦，并且这个逻辑层结构并不适合 JS 代码结构划分，也并没有包含底层框架、项目管理和代码重用等方面的相关内容。这就要需要我们在项目文件物理存储这个层面上需要有新的层划分方式，这个时候我们将以 JS 角度出发，重点关心项目结构和文件组织方式，方面团队协作和长期维护等需求。以下层架构框图展示了项目中的一种可能划分，也是我们目前的项目结构\n整个代码功能上划分成 5 层，6个不同的功能块。当然这几个功能块并不是完全相互独立的，会由于基础框架的选型影响所有其他功能块的实现方式。\n 框架层：这个是最底层，包含最基础的依赖组件。我们常说的 angular、vue、react 包含在这个层级里，这里面基础框架的选择会对其他每个层造成重大影响，并且上面所有层的实现都会基于此做设计。 工具层：是基于框架层选型开发的一些通用公共组件（比如：对话框、警告提示、加载、上传等）。这里的组件可以是自己开发，也可以是使用三方封装，可能还会包含一些和具体业务相关的公共组件。 容器层：负责处理一些公共逻辑和存放公共数据（比如：页面启动流程、用户数据、页面状态数据等），一个系统往往只有一个容器，当然也可以有多个。现在大多数页面启动流程都会比较负责，如登录流程、权限处理等都会和页面启动流程相关，且用户的登录数据、页面的状态信息都需要全局、多模块共享。 视图层：是在容器层上将页面上的可视区域划分成不同的作用的显示区域。在每个显示区域都可以放入不同的内容，并且可以根据用户操作进行切换。针对不同终端的响应式规范，也是在这层进行定义。一个系统或网站往往会有多个不同的视图 内容层：是实现具体业务的层面，我们实现的每个模块都属于内容层的一个内容块。每个内容块都可以放入任意一个视图中，当然在实现内容布局显示的时候，要符合相应视图定义的规范。具体某个内容放入哪个视图中，可以做成动态配置（比如：使用 angular 时，可以选择通过路由配置），这样做到模块级重用。 管理工具：是对工程进行管理的工具，包括打包、依赖管理、单元测试、CI/CD等。这里的选择也会很多，且和我们具体的业务结构相对独立，流行的有 gulp、webpack、grunt 等。  这里除了框架层和容器层需要同步加载，其他所有层的内容都可以做成按需延迟加载。每个层和层里面内容所涉及到的所有资源（JS、CSS、HTML、Image） 都放在相同的目录中，减少开发过程中开发人员的心智负担。\n", "content_s": "整个 《 前端 分层 架构 实战 》 分成 两 部分 ： \n   前端 分层 架构 实战 （ 一 ） ： 分层 架构 问题 分析 和 结构 构设 设计 结构设计   前端 分层 架构 实战 （ 二 ） ： 分层 架构 项目 规划 和 工程 实施     本文 是 其中 的 第一 一篇 第一篇 。 \n 随着 微 服务 兴起 前后 端 分离 架构 的 越来 越来越 流行 ， 前端 的 负责 的 开发 任务 越来 越来越 越来越重 ， 功能 复杂 复杂度 和 代码 量 也 越来 越来越 高 ， 在 同一 一个 同一个 项目 投入 的 前端 人力 也 是 越来 越来越 多 ， 这个 时候 需要 我们 使用 更加 高效 的 方式 来 组织 我们 的 代码 结构 。 目前 前端 有 很多 框架 帮 我们 做 了 很多 这方 方面 这方面 的 工作 ， 比如 目前 比较 流行 的 的 三大 框架 ： angular 、 vue 、 react 。 但是 我们 在 实际 使用 的 时候 往往 发现 ， 使用 他们 的 命令 命令行 工具 生成 了 一个 工程 ， 可以 进行 开发 了 ， 但是 真正 应用 到 真实 项目 中 的 时候 ， 往往 有 力不从心 的 感觉 ， 特别 是 企业 及 的 项目 中 ， 这是 由于 它们 做 的 只是 从 技术 层面 上 解决 了 代码 组织 方式 ， 并 没有 给出 结合 业务 时 项目 里 的 组织 结构 和 组织 方法 。 而 这些 正是 软件 架构 软件架构 所 解决 的 问题 ， 软件 架构 软件架构 正在 后 端 开发 中 大放 异彩 大放异彩 ， 那 我们 能 不能 也 在 前端 开发 前端开发 中 引入 软件 架构 软件架构 方法 ， 来 解决 前端 日益 复杂 的 开发 需求 呢 ？ 答案 是 肯定 的 ， 下面 简单 说 一下 我 自己 在 这 里面 的 实践 总结 ， 由于 个人 能力 有限 ， 有 不 正确 的 地方 欢迎 大家 指正 。 \n \n 先 从 我们 实际 看到 的 页面 效果 出发 ， 对 我们 页面 的 内容 进行 分析 、 设计 。 以下   2   中 页面 是 我们 最 常见 页面 结构 ， 一个 是   PC   端 常见 的 页面 版式 ， 一个 是 移动 端 常见 的 页面 版式 ， 列举 这   2   个 的 目的 就是 说明 在 分析 层 模式 的 时候 ， 对于   PC   端 和 移动 端 都 是 适用 的 ， 也 说明 我们 移动 端的 页面 也 在 往 不断 复杂 的 方向 上 发展 。 \n     pc   端         移动 端         这个 是 页面 展示 是 呈现 的 具体 效果 ， 那 我们 如何 对 其 进行 分层 设计 呢 ？ 试想 如果 我们 看到 的 浏览 浏览器 页面 是 有 厚度 的 ， 上面 的 图 是 我们 正对 浏览 浏览器 看到 的 页面 效果 ， 如果 我们 从 斜 上方 去 看 我们 的 这个 页面 会 是 什么 样子 ？ 。 以下 是 一种 简单 的 划分 设计 方式 ， 这个 层 的 划分 是 按照   HTML   的 逻辑 功能 划分 的 ， 属于   HTML   逻辑 层 结构 。 \n 以上 层 的 拆分 是 我们 在 浏览 浏览器 里面 看到 内容 分层 。 其实 大家 所 熟悉 的   CSS   逻辑 层 结构 划分 也 是 这样 的 ， 也 即 是 说   HTML   和   CSS   共享 逻辑 层 结构 。 这 是 是 正确 的 ， 因为 界面 的 呈现 使用   HTML   和   CSS   共同 完成 共同完成 的 ， 所以 它们 应该 共享 相同 的 逻辑 层 划分 。 其实 这个 层 逻辑 结构 就是 通过   CSS   的   z - index   来 实现 的 。 其实 在 我们 实际 规划   CSS   和   HTML   逻辑 层 的 时候 ， 往往 比 上面 会 一些 多一些 ， 一般 是 4 ~ 5 层 ， 比如 下面 是 项目 中 可能 存在 的 一种 划分 方式 \n 在 开发 的 项目 工程 中 物理 文件 组织 文件组织 是 没有 按照 这个 逻辑 层去 组织 的 ， 如果 按照 逻辑 层去 组织 的 代码 ， 当 项目 代码 逐渐 增多 时 代码 管理 起来 将会 非常 麻烦 ， 并且 这个 逻辑 层 结构 并 不 适合   JS   代码 结构 划分 ， 也 并 没有 包含 底层 框架 、 项目 管理 项目管理 和 代码 重用 等 方面 的 相关 内容 。 这 就要 需要 我们 在 项目 文件 物理 存储 这个 层面 上 需要 有 新 的 层 划分 方式 ， 这个 时候 我们 将 以   JS   角度 出发 ， 重点 关心 项目 结构 和 文件 组织 文件组织 方式 ， 方面 团队 协作 和 长期 维护 等 需求 。 以 下层 架构 框图 展示 了 项目 中 的 一种 可能 划分 ， 也 是 我们 目前 的 项目 结构 \n 整个 代码 功能 上 划分 成   5   层 ， 6 个 不同 的 功能 功能块 。 当然 这 几个 功能 功能块 并 不是 完全 相互 独立 的 ， 会 由于 基础 框架 的 选型 影响 所有 其他 功能 功能块 的 实现 方式 。 \n   框架 层 ： 这个 是 底层 最底层 ， 包含 最 基础 的 依赖 组件 。 我们 常说 的   angular 、 vue 、 react   包含 在 这个 层级 里 ， 这 里面 基础 框架 的 选择 会 对 其他 每个 层 造成 重大 影响 ， 并且 上面 所有 层 的 实现 都 会 基于 此 做 设计 。   工具 层 ： 是 基于 框架 层 选型 开发 的 一些 通用 公共 组件 （ 比如 ： 对话 对话框 、 警告 提示 、 加载 、 上传 等 ） 。 这里 的 组件 可以 是 自己 开发 ， 也 可以 是 使用 三方 封装 ， 可能 还会 包含 一些 和 具体 业务 相关 的 公共 组件 。   容器 层 ： 负责 处理 一些 公共 逻辑 和 存放 公共 数据 公共数据 （ 比如 ： 页面 启动 流程 、 用户 数据 、 页面 状态 数据 等 ） ， 一个 系统 往往 只有 一个 容器 ， 当然 也 可以 有 多个 。 现在 大多 多数 大多数 页面 启动 流程 都 会 比较 负责 ， 如 登录 流程 、 权限 处理 等 都 会 和 页面 启动 流程 相关 ， 且 用户 的 登录 数据 、 页面 的 状态 信息 都 需要 全局 、 多 模块 共享 。   视图 层 ： 是 在 容器 层 上将 页面 上 的 可视 区域 划分 成 不同 的 作用 的 显示 区域 。 在 每个 显示 区域 都 可以 放入 不同 的 内容 ， 并且 可以 根据 用户 操作 进行 切换 。 针对 不同 终端 的 响应 式 规范 ， 也 是 在 这层 进行 定义 。 一个 系统 或 网站 往往 会 有 多个 不同 的 视图   内容 层 ： 是 实现 具体 业务 的 层面 ， 我们 实现 的 每个 模块 都 属于 内容 层 的 一个 内容 块 。 每个 内容 块 都 可以 放入 任意 一个 视图 中 ， 当然 在 实现 内容 布局 显示 的 时候 ， 要 符合 相应 视图 定义 的 规范 。 具体 某个 内容 放入 哪个 视图 中 ， 可以 做成 动态 配置 （ 比如 ： 使用   angular   时 ， 可以 选择 通过 路由 配置 ） ， 这样 做到 模块 级 重用 。   管理 理工 工具 管理工具 ： 是 对 工程 进行 管理 的 工具 ， 包括 打包 、 依赖 管理 、 单元 测试 单元测试 、 CI / CD 等 。 这里 的 选择 也 会 很多 ， 且 和 我们 具体 的 业务 结构 相对 独立 ， 流行 的 有   gulp 、 webpack 、 grunt   等 。     这里 除了 框架 层 和 容器 层 需要 同步 加载 ， 其他 所有 层 的 内容 都 可以 做成 按 需 延迟 加载 。 每个 层和层 里面 内容 所 涉及 到 的 所有 资源 （ JS 、 CSS 、 HTML 、 Image ）   都 放在 相同 的 目录 中 ， 减少 开发 过程 中 开发 发人 人员 开发人员 的 心智 负担 。 \n", "title_s": "前端 分层 架构 实战 （ 一 ）"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/10-db-transaction-lock/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第十天：事务和锁", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/10-db-transaction-lock/", "content": "事务 是 DBMS 中一个非常重要的基本概念，主要用于处理操作量大，复杂度高的数据，比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！当我们在启动一个事务时，这里就引出了锁概念，并且这 2 个者对于初学者容易搞混淆。虽然事务和锁的基本原理是一样的，但是不同 RDBMS 的实现是有差别的，这里还是以 MySQL 中的事务和锁来讲解和说明基本操作。\n知识要点\n 事务基本概念 MySQL 事务操作 MySQL 锁  \n事物 像上面说的一样，在使用 MySQL 处理大量数据操作或负载数据操作时，就会启用事务！一般来说，事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）\n 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性 ： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。  在 MySQL 中要使用事务时，需要注意以下内容：\n 在MySQL中只有使用了 Innodb 数据库引擎的数据库或表才支持事务 事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行 事务主要用来管理insert,update,delete语句   在我们使用 insert,update,delete 语句时，会自动启用事务。事务其实也会影响到 select 语句的查询结果，这个主要是受 MySQL 事务隔离级别决定的。对于表结构更改语句，不受事务控制，只要执行会立即提交当前更改。\n在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。\n 事务隔离级别 SQL 标准中定义了 4 个隔离级别：未提交读（Read uncommitted）、已提交读（Read committed）、可重复读（Repeatable read）、可序列化（Serializable）\n 未提交读（Read uncommitted）：一个事务修改了一行，另一个事务也可以读到该行。 已提交读（Read committed（RC））：试图通过只读取提交的值的方式来解决脏读的问题，但是这又引起了不可重复读取的问题。 可重复读（Repeatable read（RR））：在一个事务对数据行执行读取或写入操作时锁定了这些数据行，但是这种方式又引发了幻想读的问题。 因为只能锁定读取或写入的行，不能阻止另一个事务插入数据，后期执行同样的查询会产生更多的结果。InnoDB通过多版本并发控制机制（MVCC）解决的幻读的问题。 可序列化（Serializable）：事务被强制为依次执行。这是 SQL 标准建议的默认行为。  上面可以看到不同的隔离级别会导致数据的脏读、不可重复读或幻读，这个也是通常说的事务的级别，它们关系如下：\n   隔离级别/读数据一致性及允许的并发副作用 读数据一致性 脏读 不可重复读 幻读     未提交读（Read uncommitted） 最低级别，只能保证不读取物理上损坏的数据 是 是 是   已提交读（Read committed） 语句级 否 是 是   可重复读（Repeatable read） 事务级 否 否 是   可序列化（Serializable） 最高级别，事务级 否 否 否     比较常用的级别是：RC 和 RR。\n在 MySQL 中可以查看 当前会话的事务级别 和 系统当前事务 级别。\n MySQL 事务控制语句  BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。  MySQL 事务处理的主要两种方式：\n 用 BEGIN, ROLLBACK, COMMIT来实现  BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认  直接用 SET 来改变 MySQL 的自动提交模式:  SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交   测试  使用 navcat 打开 2 个查询页面，分别制定为 Query1 和 Query2\n 在 Query2 中查询班级所有信息，看现在表表中已有的数据，和后面做对比\nselect * from class;  在 Query1 启动一个事务，且插入一条数据，但是不要提交事务\n# 开启事务 begin; # 插入数据 INSERT INTO `sql-learn`.`class` VALUES (-1, '事务测试 1', '老师1', '2018-04-02', '2018-04-18', 1, '2018-04-18 14:16:22');  再在 Query2 中执行第 2 步中的查询语句，现在看到的数据，应该和第 2 步中的一样\n 现在在 Query1 提交事务\n# 提交事务 commit  最后在 Query2 中执行第 2 步中相同的查询语句，这时会在返回结果的第一行看到我们我们刚插入的测试数据。\n  锁 事务的隔离级别就是由锁实现的，理解清楚它们之间的关系对分析和理解问题会有很大帮助。\n共享锁和排他锁：在一般的应用中，为了应付大量并发，我们一般使用一次封锁法，在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。在这种方法在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）。\n 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。  大多数数据库的MVCC通过对数据版本的乐观锁实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n  MySQL 做种类很多，常见的有：表级锁、行级锁和页级索。不多存储引擎支持有所不同。 所有表类型都支持表级锁，但是 MyISAM 只支持表级锁 有两种类型的表级锁：读锁(共享锁)和写锁(排它锁)。  读锁是共享锁，支持并发读，写操作被锁。 写锁是独占锁，上锁期间其他线程不能读表或写表。    不同事务隔离级别，读和写的所操作有所不同，（在分析的时候还需要结合表存储引擎支持的锁种类进行）\n  在 RC 级别下，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。 RR 级别（InnoDB 默认使用此级别）  读：读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时，会看到同样的数据行。 写：针对需要修改的数据加入排它锁    总结  事务：事务基本特性、开始事务、事务提交、事务回滚 事务隔离级别 锁：MySQL锁类型和事务的关系 ", "content_s": "事务   是   DBMS   中 一个 非常 重要 的 基本 概念 基本概念 ， 主要 用于 处理 操作 量 大 ， 复杂 复杂度 高 的 数据 ， 比如 比如说 ， 在 人员 管理 系统 管理系 管理系统 中 ， 你 删除 一个 人员 ， 你 即 需要 删除 人员 的 基本 资料 ， 也 要 删除 和 该 人员 相关 的 信息 ， 如 信箱 ， 文章 等等 ， 这样 ， 这些 数据 据库 数据库 操作 语句 就 构成 一个 事务 ！ 当 我们 在 启动 一个 事务 事务时 ， 这里 就 引出 了 锁 概念 ， 并且 这   2   个者 对于 初学 学者 初学者 容易 搞 混淆 。 虽然 事务 和 锁 的 基本 本原 原理 基本原理 是 一样 的 ， 但是 不同   RDBMS   的 实现 是 有 差别 的 ， 这里 还是 以   MySQL   中 的 事务 和 锁 来 讲解 和 说明 基本 操作 基本操作 。 \n 知识 要点 \n   事务 基本 概念 基本概念   MySQL   事务 操作   MySQL   锁     \n 事物   像 上面 说 的 一样 ， 在 使用   MySQL   处理 大量 数据 操作 或 负载 数据 操作 时 ， 就 会 启用 事务 ！ 一般 来说 一般来说 ， 事务 是 必须 满足 4 个 条件 （ ACID ） ：   Atomicity （ 原子 性 ） 、 Consistency （ 一致 一致性 ） 、 Isolation （ 隔离 性 ） 、 Durability （ 持久 持久性 ） \n   原子 性 ： 一个 事务 （ transaction ） 中 的 所有 操作 ， 要么 全部 完成 ， 要么 全部 不 完成 ， 不会 结束 在 中间 某个 环节 。 事务 在 执行 过程 中 发生 错误 ， 会 被 回滚 （ Rollback ） 到 事务 开始 前 的 状态 ， 就 像 这个 事务 从来 没有 执行 过 一样 。   一致 一致性   ：   在 事务 开始 之前 和 事务 结束 以后 ， 数据 据库 数据库 的 完整 完整性 没有 被 破坏 。 这 表示 写入 的 资料 必须 完全 符合 完全符合 所有 的 预设 规则 ， 这 包含 资料 的 精确 精确度 、 串联 性 以及 后续 数据 据库 数据库 可以 自发 发性 自发性 地 完成 预定 的 工作 。   隔离 性 ： 数据 据库 数据库 允许 多个 并发 事务 同时 对 其 数据 进行 读写 和 修改 的 能力 ， 隔离 性 可以 防止 多个 事务 并发 执行 时 由于 交叉 执行 而 导致 数据 的 不 一致 。 事务 隔离 分为 不同 级别 ， 包括 读未 提交 （ Read   uncommitted ） 、 读 提交 （ read   committed ） 、 可 重复 读 （ repeatable   read ） 和 串行 串行化 （ Serializable ） 。   持久 持久性 ： 事务 处理 事务处 事务处理 结束 后 ， 对 数据 的 修改 就是 永久 的 ， 即便 系统 故障 系统故障 也 不会 丢失 。     在   MySQL   中要 使用 事务 事务时 ， 需要 注意 以下 内容 以下内容 ： \n   在 MySQL 中 只有 使用 了   Innodb   数据 据库 数据库 引擎 的 数据 据库 数据库 或表才 支持 事务   事务 处理 事务处 事务处理 可以 用来 维护 数据 据库 数据库 的 完整 完整性 ， 保证 成批 的 SQL 语句 要么 全部 执行 ， 要么 全部 不 执行   事务 主要 用来 管理 insert , update , delete 语句       在 我们 使用   insert , update , delete   语句 时 ， 会 自动 启用 事务 。 事务 其实 也 会 影响 到   select   语句 的 查询 结果 ， 这个 主要 是 受   MySQL   事务 隔离 级别 决定 的 。 对于 表 结构 更改 语句 ， 不 受 事务 控制 ， 只要 执行 会 立即 提交 当前 更改 。 \n 在   MySQL   命令 命令行 的 默认 设置 默认设置 下 ， 事务 都 是 自动 提交 的 ， 即 执行   SQL   语句 后 就 会 马上 执行   COMMIT   操作 。 因此 要 显式 地 开启 一个 事务 务须 使用 命令   BEGIN   或   START   TRANSACTION ， 或者 执行 命令 执行命令   SET   AUTOCOMMIT = 0 ， 用来 禁止 使用 当前 会话 的 自动 提交 。 \n   事务 隔离 级别   SQL   标准 中 定义 了   4   个 隔离 级别 ： 未 提交 读 （ Read   uncommitted ） 、 已 提交 读 （ Read   committed ） 、 可 重复 读 （ Repeatable   read ） 、 可 序列 序列化 （ Serializable ） \n   未 提交 读 （ Read   uncommitted ） ： 一个 事务 修改 了 一行 ， 另 一个 事务 也 可以 读 到 该行 。   已 提交 读 （ Read   committed （ RC ） ） ： 试图 通过 只 读取 提交 的 值 的 方式 来 解决 脏读 的 问题 ， 但是 这 又 引起 了 不可 重复 读取 的 问题 。   可 重复 读 （ Repeatable   read （ RR ） ） ： 在 一个 事务 对 数据 行 执行 读取 或 写入 操作 时 锁定 了 这些 数据 行 ， 但是 这种 方式 又 引发 了 幻想 读 的 问题 。   因为 只能 锁定 读取 或 写入 的 行 ， 不能 阻止 另 一个 事务 插入 数据 ， 后期 执行 同样 的 查询 会 产生 更 多 的 结果 。 InnoDB 通过 多 版本 并发 控制 机制 （ MVCC ） 解决 的 幻读 的 问题 。   可 序列 序列化 （ Serializable ） ： 事务 被 强制 为 依次 执行 。 这是   SQL   标准 建议 的 默认 行为 。     上面 可以 看到 不同 的 隔离 级别 会 导致 数据 的 脏读 、 不可 重复 读 或 幻读 ， 这个 也 是 通常 说 的 事务 的 级别 ， 它们 关系 如下 ： \n       隔离 级别 / 读数 数据 读数据 一致 一致性 及 允许 的 并发 作用 副作用   读数 数据 读数据 一致 一致性   脏读   不可 重复 读   幻读           未 提交 读 （ Read   uncommitted ）   最低 级别 ， 只能 保证 不 读取 物理 上 损坏 的 数据   是   是   是       已 提交 读 （ Read   committed ）   语句 级   否   是   是       可 重复 读 （ Repeatable   read ）   事务 级   否   否   是       可 序列 序列化 （ Serializable ）   最高 高级 级别 最高级 高级别 最高级别 ， 事务 级   否   否   否           比较 常用 的 级别 是 ： RC   和   RR 。 \n 在   MySQL   中 可以 查看   当前 会话 的 事务 级别   和   系统 当前 事务   级别 。 \n   MySQL   事务 控制 语句     BEGIN 或 START   TRANSACTION ； 显式 地 开启 一个 事务 ；   COMMIT ； 也 可以 使用 COMMIT   WORK ， 不过 二者 是 等价 的 。 COMMIT 会 提交 事务 ， 并 使 已 对 数据 据库 数据库 进行 的 所有 修改 称为 永久 永久性 的 ；   ROLLBACK ； 有 可以 使用 ROLLBACK   WORK ， 不过 二者 是 等价 的 。 回滚会 结束 用户 的 事务 ， 并 撤销 正在 进行 的 所有 未 提交 的 修改 ；   SAVEPOINT   identifier ； SAVEPOINT 允许 在 事务 中 创建 一个 保存 点 ， 一个 事务 中 可以 有 多个 SAVEPOINT ；   RELEASE   SAVEPOINT   identifier ； 删除 一个 事务 的 保存 点 ， 当 没有 指定 的 保存 点时 ， 执行 该 语句 会 抛出 一个 异常 ；   ROLLBACK   TO   identifier ； 把 事务 回滚 到 标记 点 ；   SET   TRANSACTION ； 用来 设置 事务 的 隔离 级别 。 InnoDB 存储 引擎 提供 事务 的 隔离 级别 有 READ   UNCOMMITTED 、 READ   COMMITTED 、 REPEATABLE   READ 和 SERIALIZABLE 。     MySQL   事务 处理 事务处 事务处理 的 主要 两种 方式 ： \n   用   BEGIN ,   ROLLBACK ,   COMMIT 来 实现     BEGIN   开始 一个 事务   ROLLBACK   事务 回滚   COMMIT   事务 确认     直接 用   SET   来 改变   MySQL   的 自动 提交 模式 :     SET   AUTOCOMMIT = 0   禁止 自动 提交   SET   AUTOCOMMIT = 1   开启 自动 提交       测试     使用   navcat   打开   2   个 查询 页面 ， 分别 制定 为   Query1   和   Query2 \n   在   Query2   中 查询 班级 所有 信息 ， 看 现在 表表 中 已有 的 数据 ， 和 后面 做 对比 \n select   *   from   class ;     在   Query1   启动 一个 事务 ， 且 插入 一条 数据 ， 但是 不要 提交 事务 \n #   开启 事务   begin ;   #   插入 数据   INSERT   INTO   ` sql - learn ` . ` class `   VALUES   ( - 1 ,   ' 事务 测试   1 ' ,   ' 老师 1 ' ,   ' 2018 - 04 - 02 ' ,   ' 2018 - 04 - 18 ' ,   1 ,   ' 2018 - 04 - 18   14 : 16 : 22 ' ) ;     再 在   Query2   中 执行 第   2   步中 的 查询 语句 ， 现在 看到 的 数据 ， 应该 和 第   2   步中 的 一样 \n   现在 在   Query1   提交 事务 \n #   提交 事务   commit     最后 在   Query2   中 执行 第   2   步中 相同 的 查询 语句 ， 这时 会 在 返回 结果 的 第一 一行 第一行 看到 我们 我们 刚 插入 的 测试 数据 测试数据 。 \n     锁   事务 的 隔离 级别 就是 由锁 实现 的 ， 理解 清楚 它们 之间 的 关系 对 分析 和 理解 问题 会 有 很大 帮助 。 \n 共享 锁 和 排 他 锁 ： 在 一般 的 应用 中 ， 为了 应付 大量 并发 ， 我们 一般 使用 一次 封锁 法 ， 在 方法 的 开始 阶段 ， 已经 预先 知道 会 用到 哪些 数据 ， 然后 全部 锁住 ， 在 方法 运行 之后 ， 再 全部 解锁 。 在 这种 方法 在 数据 据库 数据库 中 却 不 适用 ， 因为 在 事务 开始 阶段 ， 数据 据库 数据库 不知 知道 并不知道 会 用到 哪些 数据 。 数据 据库 数据库 遵循 的 是 两段 锁 协议 ， 将 事务 分成 两个 阶段 ， 加锁 阶段 和 解锁 阶段 （ 所以 叫 两段 锁 ） 。 \n   加锁 阶段 ： 在 该 阶段 可以 进行 加锁 操作 。 在 对 任何 数据 进行 读 操作 之前 要 申请 并 获得 S 锁 （ 共享 锁 ， 其它 事务 可以 继续 加 共享 锁 ， 但 不能 加排 它锁 ） ， 在 进行 写 操作 之前 要 申请 并 获得 X 锁 （ 排它 锁 ， 其它 事务 不能 再 获得 任何 锁 ） 。 加锁 不 成功 ， 则 事务 进入 等待 状态 ， 直到 加锁 成功 才 继续 执行 继续执行 。   解锁 阶段 ： 当 事务 释放 了 一个 封锁 以后 ， 事务 进入 解锁 阶段 ， 在 该 阶段 只能 进行 解锁 操作 不能 再 进行 加锁 操作 。     大多 多数 大多数 数据 据库 数据库 的 MVCC 通过 对 数据 版本 的 乐观 锁 实现 。 何谓 数据 版本 ？ 即 为 数据 增加 一个 版本 标识 ， 在 基于 数据 据库 数据库 表 的 版本 解决 方案 解决方案 中 ， 一般 是 通过 为 数据 据库 数据库 表 增加 一个   “ version ”   字段 来 实现 。 读 取出 数据 时 ， 将 此 版本 版本号 一同 读出 ， 之后 更新 时 ， 对此 版本 版本号 加一 。 此时 ， 将 提交 数据 的 版本 数据 与 数据 据库 数据库 表 对应 记录 的 当前 版本 信息 版本信息 进行 比 对 ， 如果 提交 的 数据 版本 版本号 大于 数据 据库 数据库 表 当前 版本 版本号 ， 则 予以 更新 ， 否则 认为 是 过期 期数 数据 过期数据 。 \n     MySQL   做 种类 很多 ， 常见 的 有 ： 表级 锁 、 行级 锁 和 页 级索 。 不 多 存储 引擎 支持 有所 不同 有所不同 。   所有 表 类型 都 支持 表级 锁 ， 但是   MyISAM   只 支持 表级 锁   有 两种 类型 的 表级 锁 ： 读锁 ( 共享 锁 ) 和 写 锁 ( 排它 锁 ) 。     读锁 是 共享 锁 ， 支持 并发 读 ， 写 操作 被 锁 。   写锁 是 独占 锁 ， 上锁 期间 其他 线程 不能 读表 或 写表 。         不同 事务 隔离 级别 ， 读 和 写 的 所 操作 有所 不同 有所不同 ， （ 在 分析 的 时候 还 需要 结合 表 存储 引擎 支持 的 锁 种类 进行 ） \n     在   RC   级别 下 ， 数据 的 读取 都 是 不 加锁 的 ， 但是 数据 的 写入 、 修改 和 删除 是 需要 加锁 的 。   RR   级别 （ InnoDB   默认 使用 此 级别 ）     读 ： 读 就是 可 重读 ， 可 重读 这个 概念 是 一 事务 的 多个 实例 在 并发 读取 数据 读取数据 时 ， 会 看到 同样 的 数据 行 。   写 ： 针对 需要 修改 的 数据 加入 排它 锁         总结     事务 ： 事务 基本 特性 、 开始 事务 、 事务 提交 、 事务 回滚   事务 隔离 级别   锁 ： MySQL 锁 类型 和 事务 的 关系  ", "title_s": "小白学   SQL   第十 十天 第十天 ： 事务 和 锁"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/9-insert-update-delete/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第九天：数据插入、修改、删除", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/9-insert-update-delete/", "content": "前面七天主要聚焦在数据查询，就是怎么从表里面取出我们想要的数据。但是这些数据是如何录入到数据库的？如果数据错误了需要修改或删除数据怎么操作？我们如何快速的生产测试数据？这些就是这次我们需要讨论的内容。\n知识要点\n 插入数据 修改数据 删除数据  \n插入数据 插入数据使用 insert into 语句，在前面插入数据的时候我们已经使用。\n语法\ninsert into tbl_name [(field1, field2, ...fieldN)] values (value1, value2,...valueN)[,...];   这里的字段可以省略，如果省略就表示依次插入表中的 所有列 可以依次插入多行值，每个 () 表示一行数据，每行之间用,分隔 插入时对于NOT NULL(不能为空) 的列必须输入 如果数据是字符型或日期，必须使用单引号或者双引号，如：&rdquo;value&rdquo;  看一个我们之前使用过的插入语句：\nINSERT INTO student(s_id, s_name, s_sex, s_age, s_birthday, s_addr, s_created, s_status) VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  这个语句的意图是向学生表里面加入一条数据，这里是插入表的所有字段，所以也可以简化成下面这样:\nINSERT INTO student VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  insert into … select insert into … select 语句是select的查询结果加入到某张表中，这个语法是 MySQL 独有的，其他的 RDBMS 的语法略有不同。这个语句常用于数据汇总、存储过程里面的临时表数据插入等地方。也可以使用这个语句快速产生测试数据，下面我们就看如何快速产生测试数据。\n语法\ninsert into tbl_name[(field1, field2,...fieldN)] &lt;select_clause&gt;   &lt;select_clause 是一个完整的select语句，和前面讲解的 select 语句完全一样 insert 中的列描述必须和 select 中的列描述对应：数量、位置和类型。  列数量必须一致； 列的对应关系是和位置依次对应； 每个对应位置的列数据类型必须一致。   快速生成学生测试数据\ninsert into student(`s_name`, `s_sex`, `s_age`, `s_birthday`, `s_addr`, `s_created`, `s_status`) select `s_name`, `s_sex`, `s_age`, `s_birthday`, `s_addr`, `s_created`, `s_status` from student;  不断执行上面这个语句，你的表中数据将会以指数倍增长。这里的 select 子句中的每个返回列，都可以替换成需要的表达式，以满足不同数据需求。\n修改数据 需改数据使用 update 语句来操作。\n语法\nupdate tbl_name set field1=value1, field2=value2 [where Clause]   可以同时更新一个或多个字段 where 子句中可以指定任何条件 可以在一个单独表中同时跟新多条数据 value 可以是一个表达式  计算学生的真实年龄 我们发现学生表中的生日数据和年龄数据是没有对应的，现在我们需要：根据学生的生日计算出实际年龄更新到年龄字段\n 分析：根据学生的生日计算出实际年龄更新到年龄字段\n 操作类型：update （ 更新） 到哪里更新数据：学生 跟新哪些信息：  学生年龄 = 根据生日计算学生真实年龄  过滤条件：无   update 学生 set\n学生年龄=真实年龄\n 真实年龄 的计算要求根据学生生日计算，只需要使用当前的年份减去生日的年份就可以了：year(now() - year(s_birthday)\n 根据以上分析可以得到 SQL\nupdate student set s_age=year(now())-year(s_birthday);  将年龄小于16岁学生年龄增加 5 岁 根据以上修改的年龄数据，将学生生日年份调整正确  删除数据 当我们数据表中的某些数据不再使用时，可以 delete 语句进行删除。\n语法\ndelete from tbl_name [where clause]   如果没有指定 where 子句，将删除表中所有数据 where 子句可以包含任何条件 可以一次删除多条数据   在没有指定 where 子句时，相当于清空表操作。MySQL 中清楚表操作还可以使用： truncate tbl_name\n 删除已结业的班级  分析：删除已结业的班级\n 操作类型：delete（删除） 删除哪里数据：班级 过滤条件：已结业   delete from 班级\nwhere 班级状态=已结业\n  得到以下 SQL\ndelete from class where c_status=4;   这里的 where 子句和查询中的 where 子句一样，可以使用子查询进行更复杂的删除操作。\n 试试\n删除处于异常状态的班级 删除没有学生参与的班级  总结  插入数据：insert 结构、insert select 结构 修改数据：update 语句 删除数据：delete 语句，清空表操作 ", "content_s": "前面 七天 主要 聚焦 在 数据 查询 ， 就是 怎么 从表 里面 取出 我们 想要 的 数据 。 但是 这些 数据 是 如何 录入 到 数据 据库 数据库 的 ？ 如果 数据 错误 了 需要 修改 或 删除 数据 怎么 操作 ？ 我们 如何 快速 的 生产 测试 数据 测试数据 ？ 这些 就是 这次 我们 需要 讨论 的 内容 。 \n 知识 要点 \n   插入 数据   修改 数据   删除 数据     \n 插入 数据   插入 数据 使用   insert   into   语句 ， 在 前面 插入 数据 的 时候 我们 已经 使用 。 \n 语法 \n insert   into   tbl _ name   [ ( field1 ,   field2 ,   ... fieldN ) ]   values   ( value1 ,   value2 , ... valueN ) [ , ... ] ;       这里 的 字 段 可以 省略 ， 如果 省略 就 表示 依次 插入 表中 的   所有 列   可以 依次 插入 多行 值 ， 每个   ( )   表示 一行 数据 ， 每行 之间 用 , 分隔   插入 时 对于 NOT   NULL ( 不能 为空 )   的 列 必须 输入   如果 数据 是 字符 型 或 日期 ， 必须 使用 引号 单引号 或者 引号 双引号 ， 如 ： & rdquo ; value & rdquo ;     看 一个 我们 之前 使用 过 的 插入 语句 ： \n INSERT   INTO   student ( s _ id ,   s _ name ,   s _ sex ,   s _ age ,   s _ birthday ,   s _ addr ,   s _ created ,   s _ status )   VALUES   ( 1 ,   ' 王   1 ' ,   1 ,   16 ,   ' 2007 - 04 - 18 ' ,   ' 重庆 ' ,   ' 2018 - 04 - 18   22 : 29 : 27 ' ,   1 ) ;     这个 语句 的 意图 是 向 学生 表 里面 加入 一条 数据 ， 这里 是 插入 表 的 所有 字 段 ， 所以 也 可以 简化 成 下面 这样 : \n INSERT   INTO   student   VALUES   ( 1 ,   ' 王   1 ' ,   1 ,   16 ,   ' 2007 - 04 - 18 ' ,   ' 重庆 ' ,   ' 2018 - 04 - 18   22 : 29 : 27 ' ,   1 ) ;     insert   into   …   select   insert   into   …   select   语句 是 select 的 查询 结果 加入 到 某 张表中 ， 这个 语法 是   MySQL   独有 的 ， 其他 的   RDBMS   的 语法 略有 不同 略有不同 。 这个 语句 常用 于 数据 汇总 、 存储 过程 里面 的 临时 表 数据 插入 等 地方 。 也 可以 使用 这个 语句 快速 产生 测试 数据 测试数据 ， 下面 我们 就 看 如何 快速 产生 测试 数据 测试数据 。 \n 语法 \n insert   into   tbl _ name [ ( field1 ,   field2 , ... fieldN ) ]   & lt ; select _ clause & gt ;       & lt ; select _ clause   是 一个 完整 的 select 语句 ， 和 前面 讲解 的   select   语句 完全 一样   insert   中 的 列 描述 必须 和   select   中 的 列 描述 对应 ： 数量 、 位置 和 类型 。     列 数量 必须 一致 ；   列 的 对应 关系 是 和 位置 依次 对应 ；   每个 对应 位置 的 列 数据 类型 数据类型 必须 一致 。       快速 生成 学生 测试 数据 测试数据 \n insert   into   student ( ` s _ name ` ,   ` s _ sex ` ,   ` s _ age ` ,   ` s _ birthday ` ,   ` s _ addr ` ,   ` s _ created ` ,   ` s _ status ` )   select   ` s _ name ` ,   ` s _ sex ` ,   ` s _ age ` ,   ` s _ birthday ` ,   ` s _ addr ` ,   ` s _ created ` ,   ` s _ status `   from   student ;     不断 执行 上面 这个 语句 ， 你 的 表中 数据 将会 以 指数 倍 增长 。 这里 的   select   子句 中 的 每个 返回 列 ， 都 可以 替换 换成 替换成 需要 的 表达 达式 表达式 ， 以 满足 不同 数据 需求 。 \n 修改 数据   需改 数据 使用   update   语句 来 操作 。 \n 语法 \n update   tbl _ name   set   field1 = value1 ,   field2 = value2   [ where   Clause ]       可以 同时 更新 一个 或 多个 字 段   where   子句 中 可以 指定 任何 条件   可以 在 一个 单独 表中 同时 跟 新 多条 数据   value   可以 是 一个 表达 达式 表达式     计算 学生 的 真实 年龄   我们 发现 学生 表中 的 生日 数据 和 年龄 数据 是 没有 对应 的 ， 现在 我们 需要 ： 根据 学生 的 生日 计算 出 实际 年龄 更新 到 年龄 字 段 \n   分析 ： 根据 学生 的 生日 计算 出 实际 年龄 更新 到 年龄 字 段 \n   操作 类型 ： update   （   更新 ）   到 哪里 更新 数据 ： 学生   跟 新 哪些 信息 ：     学生 年龄   =   根据 生日 计算 学生 真实 年龄     过滤 条件 ： 无       update   学生   set \n 学生 年龄 = 真实 年龄 \n   真实 年龄   的 计算 要求 根据 学生 生日 计算 ， 只 需要 使用 当前 的 年份 减去 生日 的 年份 就 可以 了 ： year ( now ( )   -   year ( s _ birthday ) \n   根据 以上 分析 可以 得到   SQL \n update   student   set   s _ age = year ( now ( ) ) - year ( s _ birthday ) ;     将 年龄 小于 16 岁 学生 年龄 增加   5   岁   根据 以上 修改 的 年龄 数据 ， 将 学生 生日 年份 调整 正确     删除 数据   当 我们 数据 数据表 中 的 某些 数据 不再 使用 时 ， 可以   delete   语句 进行 删除 。 \n 语法 \n delete   from   tbl _ name   [ where   clause ]       如果 没有 指定   where   子句 ， 将 删除 表中 所有 数据   where   子句 可以 包含 任何 条件   可以 一次 删除 多条 数据       在 没有 指定   where   子句 时 ， 相当 当于 相当于 清空 表 操作 。 MySQL   中 清楚 表 操作 还 可以 使用 ：   truncate   tbl _ name \n   删除 已 结业 的 班级     分析 ： 删除 已 结业 的 班级 \n   操作 类型 ： delete （ 删除 ）   删除 哪里 数据 ： 班级   过滤 条件 ： 已 结业       delete   from   班级 \n where   班级 状态 = 已 结业 \n     得到 以下   SQL \n delete   from   class   where   c _ status = 4 ;       这里 的   where   子句 和 查询 中 的   where   子句 一样 ， 可以 使用 子 查询 进行 更 复杂 的 删除 操作 。 \n   试试 \n 删除 处于 异常 状态 的 班级   删除 没有 学生 参与 的 班级     总结     插入 数据 ： insert   结构 、 insert   select   结构   修改 数据 ： update   语句   删除 数据 ： delete   语句 ， 清空 表 操作  ", "title_s": "小白学   SQL   第九 九天 第九天 ： 数据 插入 、 修改 、 删除"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/8-create-alert-table/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第八天：表结构管理", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/8-create-alert-table/", "content": "前面七天全部聚焦在数据查询，就是怎么从表里面取出我们想要的数据。但是这些表是如何建立？建立的时候需要注意哪些信息？如果修改或删除表结构？。这次就一起来讨论表结构的基本管理操作。\n知识要点\n 创建表 修改表 删除表  \n创建表 创建表所需要基本信息：\n 表名 字段名称 定义每个字段选项 定义表选项  其中 字段选项 和 表选项 每个数据库系统会有所不同。\n基础语法\ncreate [temporary] table table_name ( column_name column_type [column_options] [,...] ) [table_options];   temporary: 表示当前创建的表示临时表。临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。 table_name: 表名称 column_name： 列名称 data_type： 列数据类型。查看数据类型描述 column_options：列定义选项 table_options：表定义选项 [, …]: 表示可以有多个列定义，使用 , 分割  要看 MySQL 详细 create table 语法，请参考 《MySQL 官方手册》。\n首先我们来看一下我们前面用到的班级表的创建语句:\nCREATE TABLE `class` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，主键', `c_name` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班级名称', `c_head_teacher` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班主任名称', `c_start_time` date DEFAULT NULL COMMENT '开班日期', `c_end_time` date DEFAULT NULL COMMENT '结束日期', `c_status` int(11) NOT NULL COMMENT '班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】', `c_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`c_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表';  1 列定义分析: c_id int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，组件'\n c_id 列名 int(11) 列类型为整型。查看其他数据类型描述 not null 定义列不能为空（必须有值） AUTO_INCREMENT 列是否自动增长。一个表只能有一个自动增长列列，并且数据类型必须为数值型 COMMENT '班级 id，主键' 列注释（描述列的作用）  2 主键定义分析： PRIMARY KEY (c_id)\n 定义表的主键，可以同时包含多个列，使用 , 分隔  3 表选项分析：ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表'\n ENGINE=InnoDB 定义表的存储引擎 DEFAULT CHARSET=utf8mb4 表文本采用字符集为 utf8mb4。 COLLATE=utf8mb4_unicode_ci 表校对规则 utf8mb4_unicode_ci COMMENT='班级信息表' 表注释说明   当前数据库支持字符集和校对规则可以使用 SHOW CHARACTER SET; 查看。\n字符集详细信息请查看 MySQL 字符集说明文档\n create table learn_test ( col_1 int not null, col_2 varchar(12) default null, primary key(col_1) ) engine=InnoDB default charset=utf8 comment='学习测试';  使用 desc learn_test 查看表结构：\n修改表 修改表的 alter table 语句作用很多，里面的语法也比较多，这里只列举常见的用法，详细的使用和语法参考 《Mysql 官方文档》。\n增加列 语法\nALTER TABLE tbl_name ADD column_name column_type [column_options];  增加 col_3 列，数据类型为 int，其不能为空 :（执行过后可以使用desc learn_test 查看最新表结构）\nalter table learn_test add col_3 int not null;  删除列 语法\nALTER TABLE tbl_name DROP column_name;  删除 col_1 列\nalter table learn_test drop col_1;  请使用 desc learn_test 查看最新表结构。\n修改列名字和类型 语法\nALTER TABLE tbl_name CHANGE column_name new_column_name new_column_type [new_column_options];  修改 col_2 为 col_0 ，数据类型 bigint ,默认值 0 且不为空\nalter table learn_test change col_2 col_0 bigint not null default 0;  请使用 desc learn_test 查看最新表结构。\n 如果这里不修改列名可以使用 modify 关键字：ALTER TABLE tbl_name MODIFY column_name column_type [column_options];\n 修改表名 语法\nALTER TABLE tbl_name RENAME TO new_tbl_name;  修改 learn_test 为 learn_temp\nalter table learn_test rename to learn_temp;  可以使用 show tables; 查看修改结果。\n修改表存储类型 ALTER TABLE tbl_name TYPE = MYISAM;  其他的表选项语法相似：alter table table_name option_name=option_value\n修改表字符集 ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;  删除表 DROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name] ... [RESTRICT | CASCADE]   TEMPORARY 表示删除的是临时表 IF EXISTS 如果表存在就删除，不存无操作。语句永远正确 RESTRICT 确保只有不存在相关视图和 完整性约束的表才能删除 CASCADE 任何相关视图和完整性约束一并被删除  drop table if exists learn_test, learn_temp;  可以再次执行上面的 sql 和 drop table learn_test, learn_temp; 看有什么不同返回信息。\n总结  创建表： create 语句语法、表存储引擎、字符集、列 修改表：增加/删除字段、重命名字段、修改字段类型 表删除：drop 语法 ", "content_s": "前面 七天 全部 聚焦 在 数据 查询 ， 就是 怎么 从表 里面 取出 我们 想要 的 数据 。 但是 这些 表是 如何 建立 ？ 建立 的 时候 需要 注意 哪些 信息 ？ 如果 修改 或 删除 表 结构 ？ 。 这次 就 一 起来 讨论 表 结构 的 基本 管理 操作 。 \n 知识 要点 \n   创建 表   修改 表   删除 表     \n 创建 表   创建 表所 需要 基本 信息 ： \n   表名   字段 字段名 称   定义 每个 字 段 选项   定义 表 选项     其中   字 段 选项   和   表 选项   每个 数据 据库 系统 数据库 数据库系统 会 有所 不同 有所不同 。 \n 基础 语法 \n create   [ temporary ]   table   table _ name   (   column _ name   column _ type   [ column _ options ]   [ , ... ]   )   [ table _ options ] ;       temporary :   表示 当前 创建 的 表示 临时 表 。 临时 表只 在 当前 连接 可见 ， 当 关闭 连接 时 ， MySQL 会 自动 删除 表并 释放 所有 空间 。   table _ name :   表 名称   column _ name ：   列 名称   data _ type ：   列 数据 类型 数据类型 。 查看 数据 类型 数据类型 描述   column _ options ： 列 定义 选项   table _ options ： 表 定义 选项   [ ,   … ] :   表示 可以 有 多个 列 定义 ， 使用   ,   分割     要 看   MySQL   详细   create   table   语法 ， 请 参考   《 MySQL   官方 手册 》 。 \n 首先 我们 来看 一下 我们 前面 用到 的 班级 表 的 创建 语句 : \n CREATE   TABLE   ` class `   (   ` c _ id `   int ( 11 )   NOT   NULL   AUTO _ INCREMENT   COMMENT   ' 班级   id ， 主键 ' ,   ` c _ name `   varchar ( 512 )   COLLATE   utf8mb4 _ unicode _ ci   NOT   NULL   COMMENT   ' 班级 名称 ' ,   ` c _ head _ teacher `   varchar ( 64 )   COLLATE   utf8mb4 _ unicode _ ci   NOT   NULL   COMMENT   ' 班主 主任 班主任 名称 ' ,   ` c _ start _ time `   date   DEFAULT   NULL   COMMENT   ' 开班 日期 ' ,   ` c _ end _ time `   date   DEFAULT   NULL   COMMENT   ' 结束 日期 ' ,   ` c _ status `   int ( 11 )   NOT   NULL   COMMENT   ' 班级 状态 【 0 ： 报名 未 开始 ， 1 ： 报名 中 ， 2 ： 报名 完成 ， 3 ： 已 开学 ， 4 ： 已 结业 】 ' ,   ` c _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 创建 时间 ' ,   PRIMARY   KEY   ( ` c _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COLLATE = utf8mb4 _ unicode _ ci   COMMENT = ' 班级 信息 表 ' ;     1   列 定义 分析 :   c _ id   int ( 11 )   NOT   NULL   AUTO _ INCREMENT   COMMENT   ' 班级   id ， 组件 ' \n   c _ id   列名   int ( 11 )   列 类型 为 整型 。 查看 其他 数据 类型 数据类型 描述   not   null   定义 列 不能 为空 （ 必须 有值 ）   AUTO _ INCREMENT   列 是否 自动 增长 。 一个 表 只能 有 一个 自动 增长 列列 ， 并且 数据 类型 数据类型 必须 为 数值 型   COMMENT   ' 班级   id ， 主键 '   列 注释 （ 描述 列 的 作用 ）     2   主键 定义 分析 ：   PRIMARY   KEY   ( c _ id ) \n   定义 表 的 主键 ， 可以 同时 包含 多个 列 ， 使用   ,   分隔     3   表 选项 分析 ： ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COLLATE = utf8mb4 _ unicode _ ci   COMMENT = ' 班级 信息 表 ' \n   ENGINE = InnoDB   定义 表 的 存储 引擎   DEFAULT   CHARSET = utf8mb4   表 文本 采用 字符 字符集 为   utf8mb4 。   COLLATE = utf8mb4 _ unicode _ ci   表 校对 规则   utf8mb4 _ unicode _ ci   COMMENT = ' 班级 信息 表 '   表 注释 说明       当前 数据 据库 数据库 支持 字符 字符集 和 校对 规则 可以 使用   SHOW   CHARACTER   SET ;   查看 。 \n 字符 字符集 详细 信息 详细信息 请 查看   MySQL   字符 字符集 说明 文档 \n   create   table   learn _ test   (   col _ 1   int   not   null ,   col _ 2   varchar ( 12 )   default   null ,   primary   key ( col _ 1 )   )   engine = InnoDB   default   charset = utf8   comment = ' 学习 测试 ' ;     使用   desc   learn _ test   查看 表 结构 ： \n 修改 表   修改 表 的   alter   table   语句 作用 很多 ， 里面 的 语法 也 比较 多 ， 这里 只 列举 常见 的 用法 ， 详细 的 使用 和 语法 参考   《 Mysql   官方 文档 》 。 \n 增加 列   语法 \n ALTER   TABLE   tbl _ name   ADD   column _ name   column _ type   [ column _ options ] ;     增加   col _ 3   列 ， 数据 类型 数据类型 为   int ， 其 不能 为空   : （ 执行 过后 可以 使用 desc   learn _ test   查看 最新 表 结构 ） \n alter   table   learn _ test   add   col _ 3   int   not   null ;     删除 列   语法 \n ALTER   TABLE   tbl _ name   DROP   column _ name ;     删除   col _ 1   列 \n alter   table   learn _ test   drop   col _ 1 ;     请 使用   desc   learn _ test   查看 最新 表 结构 。 \n 修改 列 名字 和 类型   语法 \n ALTER   TABLE   tbl _ name   CHANGE   column _ name   new _ column _ name   new _ column _ type   [ new _ column _ options ] ;     修改   col _ 2   为   col _ 0   ， 数据 类型 数据类型   bigint   , 默认 默认值   0   且 不 为 空 \n alter   table   learn _ test   change   col _ 2   col _ 0   bigint   not   null   default   0 ;     请 使用   desc   learn _ test   查看 最新 表 结构 。 \n   如果 这里 不 修改 列名 可以 使用   modify   关键 关键字 ： ALTER   TABLE   tbl _ name   MODIFY   column _ name   column _ type   [ column _ options ] ; \n   修改 表名   语法 \n ALTER   TABLE   tbl _ name   RENAME   TO   new _ tbl _ name ;     修改   learn _ test   为   learn _ temp \n alter   table   learn _ test   rename   to   learn _ temp ;     可以 使用   show   tables ;   查看 修改 结果 。 \n 修改 表 存储 类型   ALTER   TABLE   tbl _ name   TYPE   =   MYISAM ;     其他 的 表 选项 语法 相似 ： alter   table   table _ name   option _ name = option _ value \n 修改 表 字符 字符集   ALTER   TABLE   tbl _ name   CONVERT   TO   CHARACTER   SET   charset _ name ;     删除 表   DROP   [ TEMPORARY ]   TABLE   [ IF   EXISTS ]   tbl _ name   [ ,   tbl _ name ]   ...   [ RESTRICT   |   CASCADE ]       TEMPORARY   表示 删除 的 是 临时 表   IF   EXISTS   如果 表 存在 就 删除 ， 不存 无 操作 。 语句 永远 正确   RESTRICT   确保 只有 不 存在 相关 视图 和   完整 完整性 约束 的 表 才能 删除   CASCADE   任何 相关 视图 和 完整 完整性 约束 一并 被 删除     drop   table   if   exists   learn _ test ,   learn _ temp ;     可以 再次 执行 上面 的   sql   和   drop   table   learn _ test ,   learn _ temp ;   看 有 什么 不同 返回 信息 。 \n 总结     创建 表 ：   create   语句 语法 、 表 存储 引擎 、 字符 字符集 、 列   修改 表 ： 增加 / 删除 字 段 、 命名 重命名 字 段 、 修改 字 段 类型   表 删除 ： drop   语法  ", "title_s": "小白学   SQL   第八 八天 第八天 ： 表 结构 管理"}, {"description": "impress.js 是一个使用 html 模拟 ppt 播放效果的 js 工具。将 impress.js 集成到 Hugo 主题中，可以在静态博客中快速做出演示效果，并且将精力集中在内容上，展示效果就交给 impress.js 吧。当然需要实现自定义效果也是非常方便的。", "objectID": "https://blog.threeq.me/post/ppt/integrate-impress/", "tags": ["hugo"], "title": "Hugo 集成 impress.js 实现 ppt 播放效果", "uri": "https://blog.threeq.me/post/ppt/integrate-impress/", "content": "这是一个 Hugo Even 主题集成 impress.js 实现幻灯片效果和集成过程的演示。\n支持功能\n 支持 markdown 语法 支持 html 语法 支持 css 动画 支持自定义 js 交互逻辑  实现依赖工具\n impress.js showdown.js mermaid.js  \ndata-x: -1000\ndata-y: -1500 Hugo 中简单 PPT 效果演示 使用 Impress.js 实现  markdown 支持 html 支持 依赖库  showdown impress.js   data-rel-x: 1000\ndata-rel-y: 0 支持 markdown 样式  可以使用常用 markdown 语法 例如：italics 、 bold 、 code  分页和配置语法  由于 markdown 本身没有分页支持，所以这里使用 ----- 作为分页标志 每个页面都可以有自己的配置，配置必须放在页面的最前面放在 两个 --- 之间 例如  ----- --- data-rel-x: 1000 data-rel-y: 0 --- 你的内容   data-rel-x: 300 data-rel-y: 1100\ndata-rotate: 90 html 和 动画支持 这是一个 html 元素支持的演示。 Fly in\nFade in\nAnd zoom in\n这个有点像 ppt。需要使用 css3 动画库. 如果只要 html 解析，请加入配置选项： html: true\nid: acme graph 演示        Q1￥234 Q2￥255 Q3￥(insert here) Q4￥   ----- # 2 ``` data-rel-x: 800 data-rel-y: 800 data-rotate: 60 ``` ----- --- data-x: 6200 data-y: 4300 data-z: -100 data-rotate-x: -40 data-rotate-y: 10 data-scale: 2 class: step slide markdown step-3d --- # This is 3D  have you noticed it’s in 3D*? * beat that, prezi ;) ----- # 子步骤演示 1 ## 多步骤显示  Press 'P' to open a presenter console. When you move the mouse, navigation controls are visible on your bottom left Autoplay makes the slides advance after a timeout Relative positioning plugin is often a more convenient way to position your slides when editing. (See html for this presentation.)  ----- # 子步骤演示 2 ## 单步骤显示 Press 'P' to open a presenter console. When you move the mouse, navigation controls are visible on your bottom left Autoplay makes the slides advance after a timeout Relative positioning plugin is often a more convenient way to position your slides when editing. (See html for this presentation.)   ", "content_s": "这是 一个   Hugo   Even   主题 集成   impress . js   实现 幻灯 幻灯片 效果 和 集成 过程 的 演示 。 \n 支持 功能 \n   支持   markdown   语法   支持   html   语法   支持   css   动画   支持 自定 定义 自定义   js   交互 逻辑     实现 依赖 工具 \n   impress . js   showdown . js   mermaid . js     \n data - x :   - 1000 \n data - y :   - 1500   Hugo   中 简单   PPT   效果 演示   使用   Impress . js   实现     markdown   支持   html   支持   依赖 库     showdown   impress . js       data - rel - x :   1000 \n data - rel - y :   0   支持   markdown   样式     可以 使用 常用   markdown   语法   例如 ： italics   、   bold   、   code     分页 和 配置 语法     由于   markdown   本身 没有 分页 支持 ， 所以 这里 使用   - - - - -   作为 分页 标志   每个 页面 都 可以 有 自己 的 配置 ， 配置 必须 放在 页面 的 最 前面 放在   两个   - - -   之间   例如     - - - - -   - - -   data - rel - x :   1000   data - rel - y :   0   - - -   你 的 内容       data - rel - x :   300   data - rel - y :   1100 \n data - rotate :   90   html   和   动画 支持   这是 一个   html   元素 支持 的 演示 。   Fly   in \n Fade   in \n And   zoom   in \n 这个 有点 有点像   ppt 。 需要 使用   css3   动画 库 .   如果 只要   html   解析 ， 请 加入 配置 选项 ：   html :   true \n id :   acme   graph   演示                 Q1 ￥ 234   Q2 ￥ 255   Q3 ￥ ( insert   here )   Q4 ￥       - - - - -   #   2   ` ` `   data - rel - x :   800   data - rel - y :   800   data - rotate :   60   ` ` `   - - - - -   - - -   data - x :   6200   data - y :   4300   data - z :   - 100   data - rotate - x :   - 40   data - rotate - y :   10   data - scale :   2   class :   step   slide   markdown   step - 3d   - - -   #   This   is   3D     have   you   noticed   it ’ s   in   3D * ?   *   beat   that ,   prezi   ; )   - - - - -   #   子 步骤 演示   1   ##   多 步骤 显示     Press   ' P '   to   open   a   presenter   console .   When   you   move   the   mouse ,   navigation   controls   are   visible   on   your   bottom   left   Autoplay   makes   the   slides   advance   after   a   timeout   Relative   positioning   plugin   is   often   a   more   convenient   way   to   position   your   slides   when   editing .   ( See   html   for   this   presentation . )     - - - - -   #   子 步骤 演示   2   ##   单 步骤 显示   Press   ' P '   to   open   a   presenter   console .   When   you   move   the   mouse ,   navigation   controls   are   visible   on   your   bottom   left   Autoplay   makes   the   slides   advance   after   a   timeout   Relative   positioning   plugin   is   often   a   more   convenient   way   to   position   your   slides   when   editing .   ( See   html   for   this   presentation . )      ", "title_s": "Hugo   集成   impress . js   实现   ppt   播放 效果"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/7-query-multi-table/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第七天：多表查询", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/7-query-multi-table/", "content": "之前学习的查询都只涉及到单表，但在实际应用中还有很大一部分需求，只靠单表查询是实现不了的，比如：查询一个班上的所有人；统计每个班的人数等。那这些需求或问题应该怎么分析和实现，这就是今天要讲解的多表查询。\n知识要点：\n 子查询 表连接  \n 多表查询有两种形式：一种是子查询，一种表连接。那什么时候使用子查询？什么时候使用表连接呢？这里说一下我个人的分析和使用步骤 1. 如果所有需要获得信息列在一张表里可以找到，就用子查询；\n 2. 其他情况肯定需要表连接；\n 3. 如果数据量很大，先子查询再使用表连接\n 4. 使用性能工具分析 SQL 进行优化（执行计划和执行 profile）\n  子查询 子查询可以使用在 select 语句的 2 个地方，一个是在 from 子句中，一个是在 where 子句中，在使用的时候需要放在哪里就看是要从这个子句结果中返回信息，还是这个子句结果只是作为过滤条件。我们通过 2 个 sql 具体分析\n查询参与班级 id 为 1或2 的所有学生信息  分析：查询参与班级 id 为 1和2 的所有学生信息\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：所有学生信息 过滤条件：班级 id 为 1 或 2 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select * from 学生\nwhere 班级 id 为 1 或 2 ;\n 这里学生表里面是没有班级信息的，并且返回的信息只有学生信息，班级 id 只是作为过滤条件，所以这里能确定 where 条件为一个子查询。那这个子查询应该如何分析呢？我们回到最开始的 ER 图\n可以发现和学生信息有直接联系的是 参加 这个关系，同时它还和班级信息 最近 （这里是直接联系），就从 参加 这个关系入手。由于在转换成数据库物理存储的时候，参加 这个关系我们也是在一种独立的数据表中存储的，所以我们首先看这个表的实际物理存储\nCREATE TABLE student_join_class ( c_id int(11) NOT NULL COMMENT '班级 id', s_id int(11) NOT NULL COMMENT '学生 id', cs_created timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', PRIMARY KEY (c_id,s_id) ) COMMENT='学生班级关联表';  发现这个表里面已经了班级 id c_id ，同时还包含学生 id s_id ，这样就可以可以做到从 c_id -&gt; s_id 的转换，在我们知道了 s_id 的情况下，上面分析的 sql 结构可以表示成，这里用 in 是由于通过 student_join_class 得到的 s_id 有可能是多个\n select * from 学生\nwhere s_id in (参加班级 1 或 2 的学生 id);\n 通过上面的分析知道：可以通过 student_join_class 表数据，用已知的班级 id c_id 数据查询出参与班级的学生 id s_id ，这个 sql 通过之前的单表分析方式，不能得到查询语句：\nselect s_id from student_join_class where c_id in (1,2)  将此语句放入分析得到的 sql 语句结构，就得到最终的查询 sql 语句。\n 通过上面的分析，得到如下 sql 语句\nselect * from student where s_id in ( select s_id from student_join_class where c_id in (1,2) );  执行得到如下结果\n查询参与人数大于 3 的班级个数  分析：查询参与人数大于 3 的班级个数\n 操作类型：select （查询） 到哪里取数据：未知 （由于没有任何一张物理表有班级参与人数信息） 得到哪些信息：班级个数 过滤条件：班级参与人数大于 3 排序字段：无 取多少数据：所有数据（无 limit）  通过上面分析得到如下查询结构\n select count(*) from 未知\nwhere 班级参与人数大于 3;\n  这里如果我们将 未知 理解成一张表的话，问题就转换成：分析 未知表 里面应该包含哪些信息？。其实从查询结构不难分析 未知表 只需要包含每个班级的参与人数就够了。因为返回的信息只是统计班级的数量(这里统计之关系有这条数据，不关心数据里的具体内容），但是过滤条件需要使用班级的参与人数进行比较，所以这里 未知表 的 最小信息就是 班级参与人数 。现在问题转变成 查询每个班级的参与人数 (未知表)\n  每个班级有哪些人参与的信息，全部都在关联表 student_join_class 里面，所以通过统计不难得出每个班级的参与人数 sql\nselect c_id, count(*) from student_join_class group by c_id  这里所有我们需要的条件都完成了，组合得到的查询结构和 sql 就行。\n 通过上面的分析得到如下是 SQL。注意：这里在组合的时候对 count(*) 使用了别名 (as 关键字)，这是由于需要在外部查询中使用结果值时，是不能直接用count（*）作为其列名称。其实所有的函数操作都不行。\n使用建议：对查询返回中使用的所有函数列操作都定义别名\nselect count(*) from ( select c_id, count(*) as number from student_join_class group by c_id ) a where number &gt; 3;  执行的结果为：3 。\n 在分析的时候将 未知表 理解成一张表，这里数据库实际执行的时候确实会生成一张表，称作 临时表 。数据库在执行 sql 的时候，会为每一个子查询生成一个临时表（没有执行优化的情况），看数据库是否为一个 sql 查询生成临时表可以通过查询 SQL 执行计划 来判断。\n查询 SQL 执行计划使用 explain 关键字，执行以下 sql 查看结果输出\nexplain select count(*) from ( select c_id, count(*) as number from student_join_class group by c_id ) a where number &gt; 3;   表连接 为了让大家更好的理解表连接，这里先讲解一下表连接的基本知识。这里假设我们有 A、B 两张表，表中的数据数量分别是 m 和 n。我们现在分别创建 A、B 两张表，并且录入一些数据\n-- ---------------------------- -- Table structure for A -- ---------------------------- CREATE TABLE `A` ( `a_id` int(11) NOT NULL ); -- ---------------------------- -- Records of A -- ---------------------------- BEGIN; INSERT INTO `A` VALUES (1),(2),(3),(4),(4),(5),(5); COMMIT; -- ---------------------------- -- Table structure for B -- ---------------------------- CREATE TABLE `B` ( `b_id` int(11) NOT NULL ); -- ---------------------------- -- Records of B -- ---------------------------- BEGIN; INSERT INTO `B` VALUES (2),(3),(5),(7),(4),(4),(4); COMMIT;  笛卡尔积  我们来看第一个基本概念：笛卡尔积（也叫全连接）。在数学中笛卡尔积的定义是 两个集合 X 和 Y 的笛卡儿积（Cartesian product），又称直积，表示为 X × *Y*，是其第一个对象是 X 的成员而第二个对象是 Y 的一个成员的所有可能的有序对 。\n  这个难以理解的定义在 SQL 里面怎么理解呢？我们链接 A、B 两个表的时候，不加入任何条件，让 A 表中的每一条数据都和 B 表中的每一条数据做关联，就是 A 和 B 的笛卡尔积，也叫全连接。具体 SQL 实现如下：\nselect * from A,B; select * from A join B; select * from A cross join B;  会发现上面的 3 个 sql 语句执行的结果是一样的。我们再看这 3 中链接形式过后的数据量\nselect count(*) from A,B; select count(*) from A join B; select count(*) from A cross join B;  我们会发现 2 点\n 全连接后的数据量是 m × n 全连接后的绝大部分数据是没有意义的  我们可以试想一下如果每个表的数据量都在 100w 这个数量级（在真实生产环境这个数据量是小的），那全连接过后的数据量将是 1亿 数量级，里面的绝大多数数据是没有意义的，并且这里才考虑了 2 个表，这个很可怕的。所以在使用表连接时尽量避免产生全连接。\n普通链接 既然上面说到使用 全连接后的绝大部分数据是没有意义的 ，那我们怎么产生有意义的链接呢？其实也很简单，我们只需要在链接的时候加上有意义的链接条件就行。以下 3 个语句其实是一样的，只是表现形式不同\nselect * from A,B where a_id=b_id; select * from A join B on a_id=b_id; select * from A join B where a_id=b_id;  大家可以发现这里出现的结果其实都在上面的 笛卡尔积 中，只是从 笛卡尔积 中按照 a_id=b_id 的过滤条件选出了少部分数据，这里的 a_id=b_id 就是 有意义的条件 。在解决实际的问题的时候，什么是有 意义的条件 要根据你的问题和设计仔细分析。\n明白了上面的 笛卡尔积 和 有意义的条件 ，我们来看一下最常用的 3 中连接方式：内连接、左连接、右连接。再具体说明之前，先看一下示意图。\n这个示意图和大家在网上使用集合表示的示意图有些不同，主要是我感觉使用集合的示意图不能完全诠释 左连接 和 右连接 的概念和数据量，所以这里根据我自己的理解画了这个示意图。\n  A表数据量 m，B 表数据量 n A、B 的数据量 m x n，这个笛卡尔积后的结果集和原来的 A、B 没有任何关系 在笛卡尔积中满足过滤条件的数据(a, b)，其中 a 是 A表满足过滤条件的数量，b 是 B 表满足过滤条件的数量。但是注意满足条件的数据量并不是 a x b A表中还有 m-a 条数据不满足过滤条件，B 表中还有 n-b 条数据不满足过滤条件   内连接 内连接使用 inner join 子句，表示笛卡尔积中满足过滤条件的数据，也是我们在有过滤条件时的默认方式。\nselect * from A inner join B on a_id=b_id;  这其实和普通连接里的 3 个语句是一样的。\n左连接 内连接使用 left join 子句，表示笛卡尔积中满足过滤条件的数据，在合并左表中不满足过滤条件的数据。\nselect * from A left join B on a_id=b_id;  这里就是表示返回图中满足过滤条件的 a x b 和 不满足过滤条件的 A(m-a)\n右连接 内连接使用 left join 子句，表示笛卡尔积中满足过滤条件的数据，在合并右表中不满足过滤条件的数据。\nselect * from A right join B on a_id=b_id;  这里就是表示返回图中满足过滤条件的 (a , b) 和 不满足过滤条件的 B(n-b)\n 在分析任何链接查询数据量的时候，都可以简单的把查询过程抽象成 3 个逻辑步骤：\n 现将需要链接的表（实体表或临时表）做笛卡尔积 根据过滤条件删选需要的数据 根据不同查询方式合并剩余数据  注意：这个抽象过程只针对数据量分析，并不是数据库的真实执行过程**\n 下面我们来看一下实际怎么在问题中分析使用\n查询学生的姓名、性别和参与班级名称  分析：查询学生的姓名、性别和参与班级名称\n 操作类型：select （查询） 到哪里取数据：学生、班级、学生参与班级表 得到哪些信息：学生姓名、学生性别、参与班级名称 过滤条件：学生参与的班级 排序字段：无 取多少数据：所有数据（无 limit）  通过上面分析得到如下查询结构\n select 学生姓名,学生性别,参与班级名称\nfrom 学生,班级,学生参与班级表\nwhere 学生参与的班级;\n 由上面关于表连接的方式知道，这里需要一个有意义的过滤条件：学生参与的班级 ，由于学生参与班级的信息存储在学生参与班级表 student_join_class 中，所以这里需要连接此表。并且有意的过滤条件也是通过关联表进行匹配的。\n select s.s_name, s.s_sex, c.c_name from student s, class c, student_join_class sjc where s.s_id=sjc.s_id and c.c_id=sjc.c_id;  执行 sql 得到如下结果\n思考：这里为什么 s.s_id=sjc.s_id and c.c_id=sjc.c_id 是有意义的 ？\n查询所有班级名称和参与学生数量  分析：查询所有班级名称和参与学生数量\n 操作类型：select （查询） 到哪里取数据：班级、未知 得到哪些信息：班级名称，参与学生数量 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  通过上面分析得到如下查询结构\n select 班级名称，参与学生数量\nfrom 班级，未知;\n 根据需求可以知道，这里所有的班级名称都需要获取到，不论这个班级有没有人参与，所以这里基本可以确定使用 左连接 。由上了 SQL 实例分析已经得到查询一个班级的人数只需要 student_join_class 就可以了，所以可以确定 班级表左连接学生参与表 就行。表之间的关联关系是使用的数据字段是班级 id，所以这里的有意义过滤条件就是 班级 id 相等。最后为了得到每个班级的参与人数需要根据 班级信息作为分组统计条件。\n select 班级名称，参与学生数量\nfrom 班级\nleft join 学生参与表 on 班级 id 相等\ngroup by 班级;\n  这里班级的区分是通过班级 id 进行唯一区分的，可以有相同的班级名称，所以不能只以班级名称作为分组或分类条件。\nselect c.c_id, c.c_name, count(sjc.c_id) from class c left join student_join_class sjc on sjc.c_id=c.c_id group by c.c_id, c.c_name;   注意：这里是 count(sjc.c_id) ，不能是 count(*) 。可以使用 count(*) 替换 count(sjc.c_id) 看看结果会有什么不同。 为什么请查看前面统计里面关于 count 函数的说明。\n 试试\n查询每个学生报了多少班级 查询有参与2个及以上班级的学生 查询所有班级信息和参与学生数量  总结  子查询：from 子查询、where 子查询 表连接：笛卡尔积、内连接、左连接、右连接 多表查询分析方法  SQL 里面的查询语句学习到这里就截止了，后面将学习 DDL(数据定义语句) 学习和数据据的插入、修改、删除操作，最后简要介绍表索引、试图和存储过程。\n", "content_s": "之前 学习 的 查询 都 只 涉及 到 单表 ， 但 在 实际 应用 中 还有 很大 一部 部分 一部分 需求 ， 只靠 单表 查询 是 实现 不了 的 ， 比如 ： 查询 一个 班上 的 所有 有人 所有人 ； 统计 每个 班 的 人数 等 。 那 这些 需求 或 问题 应该 怎么 分析 和 实现 ， 这 就是 今天 要 讲解 的 多表 查询 。 \n 知识 要点 ： \n   子 查询   表 连接     \n   多表 查询 有 两种 形式 ： 一种 是子 查询 ， 一种 表 连接 。 那 什么 时候 使用 子 查询 ？ 什么 时候 使用 表 连接 呢 ？ 这里 说 一下 我 个人 的 分析 和 使用 步骤   1 .   如果 所有 需要 获得 信息 列 在 一张 表里 可以 找到 ， 就 用子 查询 ； \n   2 .   其他 情况 肯定 需要 表 连接 ； \n   3 .   如果 数据 数据量 很大 ， 先子 查询 再 使用 表 连接 \n   4 .   使用 性能 使用性能 工具 分析   SQL   进行 优化 （ 执行 计划 和 执行   profile ） \n     子 查询   子 查询 可以 使用 在   select   语句 的   2   个 地方 ， 一个 是 在   from   子句 中 ， 一个 是 在   where   子句 中 ， 在 使用 的 时候 需要 放在 哪里 就 看 是 要 从 这个 子句 结果 中 返回 信息 ， 还是 这个 子句 结果 只是 作为 过滤 条件 。 我们 通过   2   个   sql   具体 分析 具体分析 \n 查询 参与 班级   id   为   1 或 2   的 所有 学生 信息     分析 ： 查询 参与 班级   id   为   1 和 2   的 所有 学生 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 所有 学生 信息   过滤 条件 ： 班级   id   为   1   或   2   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   *   from   学生 \n where   班级   id   为   1   或   2   ; \n   这里 学生 表 里面 是 没有 班级 信息 的 ， 并且 返回 的 信息 只有 学生 信息 ， 班级   id   只是 作为 过滤 条件 ， 所以 这里 能 确定   where   条件 为 一个 子 查询 。 那 这个 子 查询 应该 如何 分析 呢 ？ 我们 回到 最 开始 的   ER   图 \n 可以 发现 和 学生 信息 有 直接 联系 的 是   参加   这个 关系 ， 同时 它 还 和 班级 信息   最近   （ 这里 是 直接 联系 ） ， 就 从   参加   这个 关系 入手 。 由于 在 转换 换成 转换成 数据 据库 数据库 物理 存储 的 时候 ， 参加   这个 关系 我们 也 是 在 一种 独立 的 数据 数据表 中 存储 的 ， 所以 我们 首先 看 这个 表 的 实际 物理 存储 \n CREATE   TABLE   student _ join _ class   (   c _ id   int ( 11 )   NOT   NULL   COMMENT   ' 班级   id ' ,   s _ id   int ( 11 )   NOT   NULL   COMMENT   ' 学生   id ' ,   cs _ created   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 加入 时间 ' ,   PRIMARY   KEY   ( c _ id , s _ id )   )   COMMENT = ' 学生 班级 关联 表 ' ;     发现 这个 表 里面 已经 了 班级   id   c _ id   ， 同时 还 包含 学生   id   s _ id   ， 这样 就 可以 可以 做到 从   c _ id   - & gt ;   s _ id   的 转换 ， 在 我们 知道 了   s _ id   的 情况 下 ， 上面 分析 的   sql   结构 可以 表示 成 ， 这里 用   in   是 由于 通过   student _ join _ class   得到 的   s _ id   有 可能 是 多个 \n   select   *   from   学生 \n where   s _ id   in   ( 参加 班级   1   或   2   的 学生   id ) ; \n   通过 上面 的 分析 知道 ： 可以 通过   student _ join _ class   表 数据 ， 用 已知 的 班级   id   c _ id   数据 查询 出 参与 班级 的 学生   id   s _ id   ， 这个   sql   通过 之前 的 单表 分析 方式 ， 不能 得到 查询 语句 ： \n select   s _ id   from   student _ join _ class   where   c _ id   in   ( 1 , 2 )     将 此 语句 放入 分析 得到 的   sql   语句 结构 ， 就 得到 最终 的 查询   sql   语句 。 \n   通过 上面 的 分析 ， 得到 如下   sql   语句 \n select   *   from   student   where   s _ id   in   (   select   s _ id   from   student _ join _ class   where   c _ id   in   ( 1 , 2 )   ) ;     执行 得到 如下 结果 \n 查询 参与 人数 大于   3   的 班级 个数     分析 ： 查询 参与 人数 大于   3   的 班级 个数 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 未知   （ 由于 没有 任何 一张 物理 表有 班级 参与 人数 信息 ）   得到 哪些 信息 ： 班级 个数   过滤 条件 ： 班级 参与 人数 大于   3   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     通过 上面 分析 得到 如下 查询 结构 \n   select   count ( * )   from   未知 \n where   班级 参与 人数 大于   3 ; \n     这里 如果 我们 将   未知   理解 成 一张 表 的话 ， 问题 就 转换 换成 转换成 ： 分析   未知 表   里面 应该 包含 哪些 信息 ？ 。 其实 从 查询 结构 不难 分析   未知 表   只 需要 包含 每个 班级 的 参与 人数 就够 了 。 因为 返回 的 信息 只是 统计 班级 的 数量 ( 这里 统计 之 关系 有 这条 数据 ， 不 关心 数据 里 的 具体 体内 内容 具体内容 ） ， 但是 过滤 条件 需要 使用 班级 的 参与 人数 进行 比较 ， 所以 这里   未知 表   的   最小 信息 就是   班级 参与 人数   。 现在 问题 转变 变成 转变成   查询 每个 班级 的 参与 人数   ( 未知 表 ) \n     每个 班级 有 哪些 人 参与 的 信息 ， 全部 都 在 关联 表   student _ join _ class   里面 ， 所以 通过 统计 不难 得出 每个 班级 的 参与 人数   sql \n select   c _ id ,   count ( * )   from   student _ join _ class   group   by   c _ id     这里 所有 我们 需要 的 条件 都 完成 了 ， 组合 得到 的 查询 结构 和   sql   就行 。 \n   通过 上面 的 分析 得到 如下 是   SQL 。 注意 ： 这里 在 组合 的 时候 对   count ( * )   使用 了 别名   ( as   关键 关键字 ) ， 这是 由于 需要 在 外部 查询 中 使用 结果 值时 ， 是 不能 直接 用 count （ * ） 作为 其列 名称 。 其实 所有 的 函数 操作 都 不行 。 \n 使用 建议 ： 对 查询 返回 中 使用 的 所有 函数 列 操作 都 定义 别名 \n select   count ( * )   from   (   select   c _ id ,   count ( * )   as   number   from   student _ join _ class   group   by   c _ id   )   a   where   number   & gt ;   3 ;     执行 的 结果 为 ： 3   。 \n   在 分析 的 时候 将   未知 表   理解 成 一张 表 ， 这里 数据 据库 数据库 实际 执行 的 时候 确实 会 生成 一张 表 ， 称作   临时 表   。 数据 据库 数据库 在 执行   sql   的 时候 ， 会为 每 一个 子 查询 生成 一个 临时 表 （ 没有 执行 优化 的 情况 ） ， 看 数据 据库 数据库 是否 为 一个   sql   查询 生成 临时 表 可以 通过 查询   SQL   执行 计划   来 判断 。 \n 查询   SQL   执行 计划 使用   explain   关键 关键字 ， 执行 以下   sql   查看 结果 输出 \n explain   select   count ( * )   from   (   select   c _ id ,   count ( * )   as   number   from   student _ join _ class   group   by   c _ id   )   a   where   number   & gt ;   3 ;       表 连接   为了 让 大家 更好 的 理解 表 连接 ， 这里 先 讲解 一下 表 连接 的 基本 知识 基本知识 。 这里 假设 我们 有   A 、 B   两张 表 ， 表中 的 数据 数量 分别 是   m   和   n 。 我们 现在 分别 创建   A 、 B   两张 表 ， 并且 录入 一些 数据 \n - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - -   Table   structure   for   A   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   CREATE   TABLE   ` A `   (   ` a _ id `   int ( 11 )   NOT   NULL   ) ;   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - -   Records   of   A   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   BEGIN ;   INSERT   INTO   ` A `   VALUES   ( 1 ) , ( 2 ) , ( 3 ) , ( 4 ) , ( 4 ) , ( 5 ) , ( 5 ) ;   COMMIT ;   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - -   Table   structure   for   B   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   CREATE   TABLE   ` B `   (   ` b _ id `   int ( 11 )   NOT   NULL   ) ;   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   - -   Records   of   B   - -   - - - - - - - - - - - - - - - - - - - - - - - - - - - -   BEGIN ;   INSERT   INTO   ` B `   VALUES   ( 2 ) , ( 3 ) , ( 5 ) , ( 7 ) , ( 4 ) , ( 4 ) , ( 4 ) ;   COMMIT ;     卡尔 笛卡尔 积     我们 来看 第一 一个 第一个 基本 概念 基本概念 ： 卡尔 笛卡尔 积 （ 也 叫 全 连接 ） 。 在 数学 中 卡尔 笛卡尔 积 的 定义 是   两个 集合   X   和   Y   的 笛卡儿 积 （ Cartesian   product ） ， 又称 直积 ， 表示 为   X   ×   * Y * ， 是 其 第一 一个 第一个 对象 是   X   的 成员 而 第二 二个 第二个 对象 是   Y   的 一个 成员 的 所有 可能 的 有序 对   。 \n     这个 难以 理解 的 定义 在   SQL   里面 怎么 理解 呢 ？ 我们 链接   A 、 B   两个 表 的 时候 ， 不 加入 任何 条件 ， 让   A   表中 的 每 一条 数据 都 和   B   表中 的 每 一条 数据 做 关联 ， 就是   A   和   B   的 卡尔 笛卡尔 积 ， 也 叫 全 连接 。 具体   SQL   实现 如下 ： \n select   *   from   A , B ;   select   *   from   A   join   B ;   select   *   from   A   cross   join   B ;     会 发现 上面 的   3   个   sql   语句 执行 的 结果 是 一样 的 。 我们 再 看 这   3   中 链接 形式 过后 的 数据 数据量 \n select   count ( * )   from   A , B ;   select   count ( * )   from   A   join   B ;   select   count ( * )   from   A   cross   join   B ;     我们 会 发现   2   点 \n   全 连接 后 的 数据 数据量 是   m   ×   n   全 连接 后 的 绝大 大部 部分 大部分 绝大部分 数据 是 没有 意义 的     我们 可以 试想 一下 如果 每个 表 的 数据 数据量 都 在   100w   这个 数量 量级 数量级 （ 在 真实 生产 环境 这个 数据 数据量 是 小 的 ） ， 那全 连接 过后 的 数据 数据量 将 是   1 亿   数量 量级 数量级 ， 里面 的 绝大 大多 多数 大多数 绝大多数 数据 是 没有 意义 的 ， 并且 这里 才 考虑 了   2   个表 ， 这个 很 可怕 的 。 所以 在 使用 表 连接 时 尽量 避免 尽量避免 产生 全 连接 。 \n 普通 链接   既然 上面 说 到 使用   全 连接 后 的 绝大 大部 部分 大部分 绝大部分 数据 是 没有 意义 的   ， 那 我们 怎么 产生 有 意义 的 链接 呢 ？ 其实 也 很 简单 ， 我们 只 需要 在 链接 的 时候 加上 有 意义 的 链接 条件 就行 。 以下   3   个 语句 其实 是 一样 的 ， 只是 表现 现形 形式 表现形式 不同 \n select   *   from   A , B   where   a _ id = b _ id ;   select   *   from   A   join   B   on   a _ id = b _ id ;   select   *   from   A   join   B   where   a _ id = b _ id ;     大家 可以 发现 这里 出现 的 结果 其实 都 在 上面 的   卡尔 笛卡尔 积   中 ， 只是 从   卡尔 笛卡尔 积   中 按照   a _ id = b _ id   的 过滤 条件 选出 了 部分 少部分 数据 ， 这里 的   a _ id = b _ id   就是   有 意义 的 条件   。 在 解决 实际 的 问题 的 时候 ， 什么 是 有   意义 的 条件   要 根据 你 的 问题 和 设计 仔细 细分 分析 仔细分析 。 \n 明白 了 上面 的   卡尔 笛卡尔 积   和   有 意义 的 条件   ， 我们 来看 一下 最 常用 的   3   中 连接 方式 ： 内 连接 、 左 连接 、 右 连接 。 再 具体 说明 之前 ， 先看 一下 示意 意图 示意图 。 \n 这个 示意 意图 示意图 和 大家 在 网上 使用 集合 表示 的 示意 意图 示意图 有些 不同 ， 主要 是 我 感觉 使用 集合 的 示意 意图 示意图 不能 完全 诠释   左 连接   和   右 连接   的 概念 和 数据 数据量 ， 所以 这里 根据 我 自己 的 理解 画 了 这个 示意 意图 示意图 。 \n     A 表 数据 数据量   m ， B   表 数据 数据量   n   A 、 B   的 数据 数据量   m   x   n ， 这个 卡尔 笛卡尔 积后 的 结果 集 和 原来 的   A 、 B   没有 任何 关系   在 卡尔 笛卡尔 积中 满足 过滤 条件 的 数据 ( a ,   b ) ， 其中   a   是   A 表 满足 过滤 条件 的 数量 ， b   是   B   表 满足 过滤 条件 的 数量 。 但是 注意 满足 条件 满足条件 的 数据 数据量 并 不是   a   x   b   A 表中 还有   m - a   条 数据 不 满足 过滤 条件 ， B   表中 还有   n - b   条 数据 不 满足 过滤 条件       内 连接   内 连接 使用   inner   join   子句 ， 表示 卡尔 笛卡尔 积中 满足 过滤 条件 的 数据 ， 也 是 我们 在 有 过滤 条件 时 的 默认 方式 。 \n select   *   from   A   inner   join   B   on   a _ id = b _ id ;     这 其实 和 普通 连接 里 的   3   个 语句 是 一样 的 。 \n 左 连接   内 连接 使用   left   join   子句 ， 表示 卡尔 笛卡尔 积中 满足 过滤 条件 的 数据 ， 在 合并 左表中 不 满足 过滤 条件 的 数据 。 \n select   *   from   A   left   join   B   on   a _ id = b _ id ;     这里 就是 表示 返回 图中 满足 过滤 条件 的   a   x   b   和   不 满足 过滤 条件 的   A ( m - a ) \n 右 连接   内 连接 使用   left   join   子句 ， 表示 卡尔 笛卡尔 积中 满足 过滤 条件 的 数据 ， 在 合并 右表中 不 满足 过滤 条件 的 数据 。 \n select   *   from   A   right   join   B   on   a _ id = b _ id ;     这里 就是 表示 返回 图中 满足 过滤 条件 的   ( a   ,   b )   和   不 满足 过滤 条件 的   B ( n - b ) \n   在 分析 任何 链接 查询 数据 数据量 的 时候 ， 都 可以 简单 的 把 查询 过程 抽象 成   3   个 逻辑 步骤 ： \n   现将 需要 链接 的 表 （ 实体 表 或 临时 表 ） 做 卡尔 笛卡尔 积   根据 过滤 条件 删选 需要 的 数据   根据 不同 查询 方式 合并 剩余 数据     注意 ： 这个 抽象 过程 只 针对 数据 数据量 分析 ， 并 不是 数据 据库 数据库 的 真实 执行 过程 * * \n   下面 我们 来看 一下 实际 怎么 在 问题 中 分析 使用 \n 查询 学生 的 姓名 、 性别 和 参与 班级 名称     分析 ： 查询 学生 的 姓名 、 性别 和 参与 班级 名称 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生 、 班级 、 学生 参与 班级 表   得到 哪些 信息 ： 学生 姓名 、 学生 性别 、 参与 班级 名称   过滤 条件 ： 学生 参与 的 班级   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     通过 上面 分析 得到 如下 查询 结构 \n   select   学生 姓名 , 学生 性别 , 参与 班级 名称 \n from   学生 , 班级 , 学生 参与 班级 表 \n where   学生 参与 的 班级 ; \n   由 上面 关于 表 连接 的 方式 知道 ， 这里 需要 一个 有 意义 的 过滤 条件 ： 学生 参与 的 班级   ， 由于 学生 参与 班级 的 信息 存储 在 学生 参与 班级 表   student _ join _ class   中 ， 所以 这里 需要 连接 此表 。 并且 有意 的 过滤 条件 也 是 通过 关联 表 进行 匹配 的 。 \n   select   s . s _ name ,   s . s _ sex ,   c . c _ name   from   student   s ,   class   c ,   student _ join _ class   sjc   where   s . s _ id = sjc . s _ id   and   c . c _ id = sjc . c _ id ;     执行   sql   得到 如下 结果 \n 思考 ： 这里 什么 为什么   s . s _ id = sjc . s _ id   and   c . c _ id = sjc . c _ id   是 有 意义 的   ？ \n 查询 所有 班级 名称 和 参与 学生 数量     分析 ： 查询 所有 班级 名称 和 参与 学生 数量 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级 、 未知   得到 哪些 信息 ： 班级 名称 ， 参与 学生 数量   过滤 条件 ： 无   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     通过 上面 分析 得到 如下 查询 结构 \n   select   班级 名称 ， 参与 学生 数量 \n from   班级 ， 未知 ; \n   根据 需求 可以 知道 ， 这里 所有 的 班级 名称 都 需要 获取 到 ， 不论 这个 班级 没有 有没有 人 参与 ， 所以 这里 基本 可以 确定 使用   左 连接   。 由 上 了   SQL   实例 分析 已经 得到 查询 一个 班级 的 人数 只 需要   student _ join _ class   就 可以 了 ， 所以 可以 确定   班级 表左 连接 学生 参与 表   就行 。 表 之间 的 关联 关系 是 使用 的 数据 数据字 段 是 班级   id ， 所以 这里 的 有 意义 过滤 条件 就是   班级   id   相等 。 最后 为了 得到 每个 班级 的 参与 人数 需要 根据   班级 信息 作为 分组 统计 条件 。 \n   select   班级 名称 ， 参与 学生 数量 \n from   班级 \n left   join   学生 参与 表   on   班级   id   相等 \n group   by   班级 ; \n     这里 班级 的 区分 是 通过 班级   id   进行 唯一 区分 的 ， 可以 有 相同 的 班级 名称 ， 所以 不能 只以 班级 名称 作为 分组 或 分类 条件 。 \n select   c . c _ id ,   c . c _ name ,   count ( sjc . c _ id )   from   class   c   left   join   student _ join _ class   sjc   on   sjc . c _ id = c . c _ id   group   by   c . c _ id ,   c . c _ name ;       注意 ： 这里 是   count ( sjc . c _ id )   ， 不能 是   count ( * )   。 可以 使用   count ( * )   替换   count ( sjc . c _ id )   看看 结果 会 有 什么 不同 。   什么 为什么 请 查看 前面 统计 里面 关于   count   函数 的 说明 。 \n   试试 \n 查询 每个 学生 报 了 多少 班级   查询 有 参与 2 个 及 以上 班级 的 学生   查询 所有 班级 信息 和 参与 学生 数量     总结     子 查询 ： from   子 查询 、 where   子 查询   表 连接 ： 卡尔 笛卡尔 积 、 内 连接 、 左 连接 、 右 连接   多表 查询 分析 方法 分析方法     SQL   里面 的 查询 语句 学习 到 这里 就 截止 了 ， 后面 将 学习   DDL ( 数据 定义 语句 )   学习 和 数据 据 的 插入 、 修改 、 删除 操作 ， 最后 简要 介绍 表 索引 、 试图 和 存储 过程 。 \n", "title_s": "小白学   SQL   第七 七天 第七天 ： 多表 查询"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/6-query-statistics/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第六天：统计查询", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/6-query-statistics/", "content": "今天我们来学习涉及单表查询的最后一种查询方式：统计查询，但让统计查询并不只能用于单表查询的，也可用于多表查询。其实我们前面所有的查询子句都可以用于单表和多表查询，具体多表查询中的使用将在第七天介绍。首先还是看看统计查询里面内容概要，也是今天的知识要点。\n知识要点：\n 统计函数 分组统计 过滤分组统计  \n统计函数 SQL聚集函数有 5 个\n   函数 说明     AVG() 返回某列的平均值   COUNT() 返回某列的函数   MIN() 返回某列的最小值   MAX() 返回某列的最大值   SUM() 返回某列值之和      对所有执行计算，指定ALL参数或不指定参数（因为ALL是默认行为）；只包含不同的值，指定distinct参数 使用 count(*) 对表中行的数目进行计数，不管表列中包含的是空值（null）还是非空值 使用 count(column) 对特定列中具有值得行进行计数，忽略null值。   查询班级总数和设置了开班时间的班级个数 select count(*), count(c_start_time) from class;  执行 SQL 得到结果。这里注意 count(*) 和 count(c_start_time) 的区别\n查询班主任的个数 select count(distinct c_head_teacher) from class;  得到如下结果\n 大家注意这里为什么使用 count(distinct c_head_teacher) 。大家可以执行下面语句，看两个之前的差别在哪里。\nselect count(c_head_teacher) from class;\n 查询生日在 2008-01-18 这天的学生数量 select count(*) from student where s_birthday='2008-01-18';  得到如下结果\n试试\n查询所有学生数量、平均年龄、最小年龄、最大年龄、年龄总和  分组统计：group 子句 在使用统计查询的时候，常常会遇到对数据进行分类排序的需求，这个时候就需要使用到 group 子句，子句格式:\n[GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]]  进行分组或分类的条件可以是一个，也可以是多个；既可以是列，也可以是表达式。\n 使用 group 子句时，select 返回的信息必须是统计信息或分组信息\n 统计不同性别的学生数量和平均年龄，返回性别信息(显示男或女)、数量信息、平均年龄 select case s_sex when 0 then '女' when 1 then '男' end, count(*), avg(s_age) from student group by s_sex  得到如下结果\n试试：去除平均年龄中的小数\n统计不同年龄段学生数量，每10岁为一个年龄段，数量最多的在前面，输出年龄段信息和数量 select concat((ceil(s_age / 10)-1)*10+1, '~', ceil(s_age / 10)*10, '岁') as seg, count(*) from student group by seg order by count(*) desc ;  得到如下结果\n试试\n查询负责班级最多的班主任和负责班级数量  过滤分组统计：having 子句 有时我们会遇到查找满足指定统计条件的数据，这个时候需要使用到 having 子句。having子句类似于where，having支持所有得where操作符，它们得句法是相同的，却别是：where是过滤行，having是过滤分组\n查询学生数量大于1排前三的地区 select s_addr, count(*) from student group by s_addr HAVING count(*)&gt;1 order by count(*) desc limit 0,3 ;  执行结果\n试试\n查询负责2个班级的班主任  总计  统计函数：count、max、min、avg、sum 分组统计：group by 子句 过滤分组统计：having 子句  至此针对单表的常用查询讲解都完了，这里做一个 SQL 语句结构的整理。\nselect子句及其顺序\n   子句 说明 是否必须使用     select 要返回的列或表达式 是   from 从中检索数据的表 仅在从表中选择数据时使用   where 行级过滤 否   group by 分组说明 仅在按组计算聚集时使用   having 组级过滤 否   order by 输出排序顺序 否   limit 限定结果集大小 否    SELECT select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY {col_name | expr | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] ] ", "content_s": "今天 我们 来 学习 涉及 单表 查询 的 最后 一种 查询 方式 ： 统计 查询 ， 但 让 统计 查询 并 不 只能 用于 单表 查询 的 ， 也 可 用于 多表 查询 。 其实 我们 前面 所有 的 查询 子句 都 可以 用于 单表 和 多表 查询 ， 具体 多表 查询 中 的 使用 将 在 第七 七天 第七天 介绍 。 首先 还是 看看 统计 查询 里面 内容 概要 ， 也 是 今天 的 知识 要点 。 \n 知识 要点 ： \n   统计 函数   分组 统计   过滤 分组 统计     \n 统计 函数   SQL 聚集 函数 有   5   个 \n       函数   说明           AVG ( )   返回 某列 的 平均 均值 平均值       COUNT ( )   返回 某列 的 函数       MIN ( )   返回 某列 的 最小 最小值       MAX ( )   返回 某列 的 最大 大值 最大值       SUM ( )   返回 某列值 之 和             对 所有 执行 计算 ， 指定 ALL 参数 或 不 指定 参数 （ 因为 ALL 是 默认 行为 ） ； 只 包含 不同 的 值 ， 指定 distinct 参数   使用   count ( * )   对表 中行 的 数目 进行 计数 ， 不管 表列 中 包含 的 是 空值 （ null ） 还 是非 空值   使用   count ( column )   对 特定 列中 具有 值得 行 进行 计数 ， 忽略 null 值 。       查询 班级 总数 和 设置 了 开班 时间 的 班级 个数   select   count ( * ) ,   count ( c _ start _ time )   from   class ;     执行   SQL   得到 结果 。 这里 注意   count ( * )   和   count ( c _ start _ time )   的 区别 \n 查询 班主 主任 班主任 的 个数   select   count ( distinct   c _ head _ teacher )   from   class ;     得到 如下 结果 \n   大家 注意 这里 什么 为什么 使用   count ( distinct   c _ head _ teacher )   。 大家 可以 执行 下面 语句 ， 看 两个 之前 的 差别 在 哪里 。 \n select   count ( c _ head _ teacher )   from   class ; \n   查询 生日 在   2008 - 01 - 18   这天 的 学生 数量   select   count ( * )   from   student   where   s _ birthday = ' 2008 - 01 - 18 ' ;     得到 如下 结果 \n 试试 \n 查询 所有 学生 数量 、 平均 年龄 平均年龄 、 最小 年龄 、 最大 年龄 、 年龄 总和     分组 统计 ： group   子句   在 使用 统计 查询 的 时候 ， 常常 会 遇到 对 数据 进行 分类 排序 的 需求 ， 这个 时候 就 需要 使用 到   group   子句 ， 子句 格式 : \n [ GROUP   BY   { col _ name   |   expr   |   position }   [ ASC   |   DESC ] ,   ...   [ WITH   ROLLUP ] ]     进行 分组 或 分类 的 条件 可以 是 一个 ， 也 可以 是 多个 ； 既 可以 是 列 ， 也 可以 是 表达 达式 表达式 。 \n   使用   group   子句 时 ， select   返回 的 信息 必须 是 统计 信息 或 分组 信息 \n   统计 不同 性别 的 学生 数量 和 平均 年龄 平均年龄 ， 返回 性别 信息 ( 显示 男 或 女 ) 、 数量 信息 、 平均 年龄 平均年龄   select   case   s _ sex   when   0   then   ' 女 '   when   1   then   ' 男 '   end ,   count ( * ) ,   avg ( s _ age )   from   student   group   by   s _ sex     得到 如下 结果 \n 试试 ： 去除 平均 年龄 平均年龄 中 的 小数 \n 统计 不同 年龄 年龄段 学生 数量 ， 每 10 岁 为 一个 年龄 年龄段 ， 数量 最多 的 在 前面 ， 输出 年龄 年龄段 信息 和 数量   select   concat ( ( ceil ( s _ age   /   10 ) - 1 ) * 10 + 1 ,   ' ~ ' ,   ceil ( s _ age   /   10 ) * 10 ,   ' 岁 ' )   as   seg ,   count ( * )   from   student   group   by   seg   order   by   count ( * )   desc   ;     得到 如下 结果 \n 试试 \n 查询 负责 班级 最多 的 班主 主任 班主任 和 负责 班级 数量     过滤 分组 统计 ： having   子句   有时 我们 会 遇到 查找 满足 指定 统计 条件 的 数据 ， 这个 时候 需要 使用 到   having   子句 。 having 子句 类似 于 where ， having 支持 所有 得 where 操作 操作符 ， 它们 得 句法 是 相同 的 ， 却别 是 ： where 是 过滤 行 ， having 是 过滤 分组 \n 查询 学生 数量 大于 1 排前 三 的 地区   select   s _ addr ,   count ( * )   from   student   group   by   s _ addr   HAVING   count ( * ) & gt ; 1   order   by   count ( * )   desc   limit   0 , 3   ;     执行 结果 \n 试试 \n 查询 负责 2 个 班级 的 班主 主任 班主任     总计     统计 函数 ： count 、 max 、 min 、 avg 、 sum   分组 统计 ： group   by   子句   过滤 分组 统计 ： having   子句     至此 针对 单表 的 常用 查询 讲解 都 完 了 ， 这里 做 一个   SQL   语句 结构 的 整理 。 \n select 子句 及其 顺序 \n       子句   说明   是否 必须 使用           select   要 返回 的 列 或 表达 达式 表达式   是       from   从中 检索 数据 的 表   仅 在 从表中 选择 数据 时 使用       where   行级 过滤   否       group   by   分组 说明   仅 在 按组 计算 聚集 时 使用       having   组级 过滤   否       order   by   输出 排序 顺序   否       limit   限定 结果 集 大小   否         SELECT   select _ expr   [ ,   select _ expr   ... ]   [ FROM   table _ references   [ WHERE   where _ condition ]   [ GROUP   BY   { col _ name   |   expr   |   position }   [ ASC   |   DESC ] ,   ...   [ WITH   ROLLUP ] ]   [ HAVING   where _ condition ]   [ ORDER   BY   { col _ name   |   expr   |   position }   [ ASC   |   DESC ] ,   ... ]   [ LIMIT   { [ offset , ]   row _ count   |   row _ count   OFFSET   offset } ]   ]  ", "title_s": "小白学   SQL   第六 六天 第六天 ： 统计 查询"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/5-query-function/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第五天：数据操作函数", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/5-query-function/", "content": "我们之前已经学习很多的 SQL 查询支持，但是这些查询只能原样返回数据库里存储的数据，那如果我们需要对这些数据做一个处理怎么办呢？比如：合并2个字段、返回的学生年龄2倍等。这就是今天要一起学习的内容：数据操作函数。每个 RDBMS 提供提供的函数操作都不一样，这里还是以 MySQL 为例子讲解，其他的 RDBMS 请查阅相关文档。由于数据处理函数比较多，这里没有办法全部覆盖，只会列举我们常用的一些操作函数，我把他们分成 5 类：字符串函数、数值函数、时间函数、统计函数、流程控制函数。想知道更多函数详情请参考 MySQL 官方文档。\n知识要点：\n 计算字段、计算列、虚拟列 常用字符串函数 常用数值计算、数值函数 常用日期时间函数 流程控制函数  这里列举的使平时常用的 4 中类型函数分类，另外的统计函数将在下次单独说明。\n\n在查询里面使用计算表达式或函数表达式的列称为计算列或计算字段。它是一个虚拟列，数据库并不实际存储在表中，计算列的表达式可以使用其他列中的数据来计算其所属列的值。\n字符串函数 下面是常用的一些字符处理函数\n   函数 描述 实例     concat() 拼接字符串 SELECT concat(&lsquo;Hello&rsquo;, &lsquo;, &lsquo;, &lsquo;World&rsquo;,&lsquo;!&rsquo;);   format() 格式化数字到字符串 SELECT format(12332.1,4);   length() 返回字符串长度 SELECT length(&lsquo;xxx&rsquo;);   lcase()/lower() 转换小写 SELECT lower(&lsquo;ABcDef&rsquo;);   ltrim() 去掉左边空白字符 SELECT ltrim(&rsquo; AB cD f &lsquo;);   repeat() 重复输出字符串 SELECT repeat(&lsquo;A&rsquo;, 3);   replace() 替换字符串 SELECT replace(&lsquo;ABBCD&rsquo;, &lsquo;BB&rsquo;, &lsquo;W&rsquo;);   reverse() 翻转输出字符串 SELECT reverse(&lsquo;abcd&rsquo;);   left() 返回左边字符串 SELECT left(&lsquo;abcdf&rsquo;, 2);   right() 返回右边字符串 SELECT right(&lsquo;abcdf&rsquo;, 2);   rtrim() 去掉右边空白字符 SELECT rtrim(&rsquo; AB cD f &lsquo;);   substr()/substring() 截取子字符串 SELECT substr(&lsquo;Quadratically&rsquo;,5);\nSELECT substr(&lsquo;Quadratically&rsquo;,5,6);   trim() 去掉空白字符 SELECT trim(&rsquo; AB cD f &lsquo;);   ucase()/upper() 转换大写 SELECT upper(&lsquo;ABcDef&rsquo;);    还是通过实例分析他们的使用\n查询班主任信息，输出3遍老师信息  分析：查询老师信息，输出3遍老师信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：3 遍班主任信息 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 班主任 * 3\nfrom 班级;\n  班主任 * 3 由于班主任存储的是字符串类型，重复3次表示为 repeat(c_head_teacher, 3)   得到如下 SQL\nselect repeat(c_head_teacher, 3) from class;  执行得到如下结果\n试试\n查询班级名称长度并将班级名称翻转输出  数值计算、数值函数 数值计算操作符\n   操作符 描述 实例     + 加 select 2+3;   - 减 或 取反 select 2-1, -2;   * 乘 select 2*3;   / 或 div 除 select 2&frasl;4, 2 div 4;   % 或 mod 取余 或 取模 select 2%4, 2 mod 4;    数值计算函数\n   函数 描述 实例     abs() 绝对值 SELECT abs(-10), abs(9);   ceil()/ceilling() 上取整 SELECT ceiling(3.4), ceil(3.5), ceil(3.6);   conv() 进制转换 SELECT conv(10,10 ,2), conv(10,2 ,10);   exp() 自然数数 e 的 n 次方 SELECT exp(1), exp(0), exp(-1);   floor() 下取整 SELECT floor(3.4), floor(3.5), floor(3.6);   pow()/power() 指数函数 SELECT POW(1,3), pow(2,3), pow(4,2);   round() 四舍五入取整 SELECT round(3.4), round(3.5), round(3.6);   rand() 随机数 SELECT rand(), rand()*10;   mod() 取余/取模 SELECT mod(25, 7), 25 % 7, mod(25.4, 7), 25.4 % 7;   pi() PI 值 SELECT pi(), pi()+0.0000000000;    查询所有学生姓名和年龄，将所有学生的年龄翻倍，且年龄大的在后面  分析：查询所有学生信息，将所有学生的年龄翻倍，且年龄大的在后面\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：姓名、年龄翻倍 过滤条件：无 排序字段：龄大的在后面 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 姓名, 年龄翻倍\nfrom 学生\norder by 龄大的在后面;\n  得到如下 SQL\nselect s_name, s_age * 2 from student order by s_age * 2 asc;  执行得到如下结果\n查询学生年龄和姓名，并按照年龄的 1&frasl;3 下取整输出  分析：查询学生年龄和姓名，并按照年龄的的 1&frasl;3 下取整输出\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：姓名、年龄的 1&frasl;3 下取整 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 姓名, 年龄的 1&frasl;3 下取整\nfrom 学生\norder by 龄大的在后面;\n 年龄的 1&frasl;3 下取整 先求出年龄的 1/3，再用 下取整函数处理\n 得到如下 SQL\nselect s_name, floor(s_age/3) from student;  执行得到如下结果\n试试\n查询所有10岁的学生姓名和年龄，要求输出2遍姓名和5年后的年龄  日期时间函数    函数 描述 实例     now() 当前日期时间 select now(), CURRENT_TIMESTAMP();   curtime() 当前时间 select curtime();   curdate() 当前日期 select curdate();   from_unixtime() 从时间戳到日期 select from_unixtime(1);   unix_timestamp() 返回日期时间戳 select unix_timestamp(now());   time() 从时间里面获取时间部分 select time(now())   date() 从时间里面获取日期部分 select now(), date(now());   date_format() 格式化日期/时间数据\ndate_format(date, format) select date_format(now(),&lsquo;%b %d %Y %h:%i %p&rsquo;),\ndate_format(now(),&lsquo;%m-%d-%Y&rsquo;);   adddate()/date_add() 向日期添加指定的时间间隔\nadddate(date, interval num unit) select date_add(now() ,interval 45 DAY), adddate(now() ,interval 45 DAY);   subdate()/date_sub() 向日期减去指定的时间间隔\nsubdate(date, interval num Type) select date_sub(now() ,interval 45 DAY), subdate(now() ,interval 45 DAY);   datediff() 返回两个日期之间的天数 SELECT datediff(&lsquo;2018-01-30&rsquo;,&lsquo;2018-04-27&rsquo;);    还有很多的时间获取函数，这里不再列举，在用到的时候查下文件就行 《MySQL 日期时间函数》\n时间 ADD 和 SUB 的 unit 可取值有    Type 值     MICROSECOND   SECOND   MINUTE   HOUR   DAY   WEEK   MONTH   QUARTER   YEAR   SECOND_MICROSECOND   MINUTE_MICROSECOND   MINUTE_SECOND   HOUR_MICROSECOND   HOUR_SECOND   HOUR_MINUTE   DAY_MICROSECOND   DAY_SECOND   DAY_MINUTE   DAY_HOUR   YEAR_MONTH    时间 format 可使用的格式有：    格式 描述     %a 缩写星期名   %b 缩写月名   %c 月，数值   %D 带有英文前缀的月中的天   %d 月的天，数值（00-31）   %e 月的天，数值（0-31）   %f 微秒   %H 小时（00-23）   %h 小时（01-12）   %I 小时（01-12）   %i 分钟，数值（00-59）   %j 年的天（001-366）   %k 小时（0-23）   %l 小时（1-12）   %M 月名   %m 月，数值（00-12）   %p AM 或 PM   %r 时间，12-小时（hh:mm:ss AM 或 PM）   %S 秒（00-59）   %s 秒（00-59）   %T 时间, 24-小时（hh:mm:ss）   %U 周（00-53）星期日是一周的第一天   %u 周（00-53）星期一是一周的第一天   %V 周（01-53）星期日是一周的第一天，与 %X 使用   %v 周（01-53）星期一是一周的第一天，与 %x 使用   %W 星期名   %w 周的天（0=星期日, 6=星期六）   %X 年，其中的星期日是周的第一天，4 位，与 %V 使用   %x 年，其中的星期一是周的第一天，4 位，与 %v 使用   %Y 年，4 位   %y 年，2 位    查询学生在哪一年出生，年份早的排在前面  分析：查询学生在哪一年出生，年份早的排在前面\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：在哪一年出生 过滤条件：无 排序字段：年份早的排在前面 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 在哪一年出生\nfrom 学生\norder by 年份早的排在前面;\n 在哪一年出生 这个信息是在生日字段里面，生日字段是包含了年月日信息，只需要使用 year 函数处理就能得到年了：year(s_birthday)\n 得到 SQL 语句\nselect year(s_birthday) from student order by year(s_birthday) asc;  执行得到如下结果\n试试\n大家发现学生表里面有年龄字段和生日字段，上面我们使用了生日计算出生年，现在使用年龄计算出生年，看看会是什么结果，应该是和生日不一样的（这里是故意的，后面在修改数据时候会改过来） 计算班级从开班时间到结束时间持续了多少天  流程控制函数 MySQL 流程控制函数有 4 个：CASE、IF()、IFNULL 、NULLIF ，我自己平时用的最多的是 CASE ，这里只演示 CASE 的使用，其他几个在一个特定的场景下使用，到时候遇到了查下文档吧。\nCASE 语法 CASE 语句有2中语法，一种是值判断，一种是条件判断。\n值判断语法 CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END  条件判断语法 CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END  查询学生性别和姓名，性别输出文中文男和女（0：女，1：男） select s_name, case c_sex when 0 then '女' when 1 then '男' end as '性别' from student  查询学习性别和年龄段，年龄段输出为：1~10的为小，11~15的中，16~20的大 select s_name, case when s_age&gt;=1 and s_age&lt;=10 then '小' when s_age&gt;=11 and s_age&lt;=15 then '中' when s_age&gt;=16 and s_age&lt;=20 then '大' end as '年龄段' from student;  试试\n查询学生生日的月份，要求中文数值输出月份(比如：一月、二月、三月)   上面最后两个 SQL 没有给出详细的分析过程，对于这个分析过程可以自行按照之前的模式进行，这种分析模式掌握过后，不论多复杂的需求和 SQL 都可以做到游刃有余，所以大家一定要掌握。对于后面简单的 SQL 不再给出详细分析过程，分析过程只针对复杂 SQL 和关键部分，如果大家对于哪个问题和SQL 需要分析过程的，可以在后面留言或联系我。\n 总结  计算字段、计算列、虚拟列 常用字符串函数 常用数值计算、数值函数 常用日期时间函数 流程控制函数：case 语句的 2 种格式 ", "content_s": "我们 之前 已经 学习 很多 的   SQL   查询 支持 ， 但是 这些 查询 只能 原样 返回 数据 据库 数据库 里 存储 的 数据 ， 那 如果 我们 需要 对 这些 数据 做 一个 处理 怎么 怎么办 呢 ？ 比如 ： 合并 2 个 字 段 、 返回 的 学生 年龄 2 倍 等 。 这 就是 今天 要 一起 学习 的 内容 ： 数据 操作 函数 。 每个   RDBMS   提供 提供 的 函数 操作 都 不 一样 ， 这里 还是 以   MySQL   为 例子 讲解 ， 其他 的   RDBMS   请 查阅 相关 文档 。 由于 数据 处理 数据处理 函数 比较 多 ， 这里 没有 办法 全部 覆盖 ， 只会 列举 我们 常用 的 一些 操作 函数 ， 我 把 他们 分成   5   类 ： 字符 字符串 函数 、 数值 函数 、 时间 函数 、 统计 函数 、 流程 控制 函数 。 想 知道 更 多 函数 详情 详情请 参考   MySQL   官方 文档 。 \n 知识 要点 ： \n   计算 字 段 、 计算 列 、 虚拟 列   常用 字符 字符串 函数   常用 数值 计算 、 数值 函数   常用 日期 时间 函数   流程 控制 函数     这里 列举 的 使 平时 常用 的   4   中 类型 函数 分类 ， 另外 的 统计 函数 将 在 下次 单独 说明 。 \n \n 在 查询 里面 使用 计算 表达 达式 表达式 或 函数 表达 达式 表达式 的 列 称为 计算 列 或 计算 字 段 。 它 是 一个 虚拟 列 ， 数据 据库 数据库 并 不 实际 存储 在 表中 ， 计算 列 的 表达 达式 表达式 可以 使用 其他 列中 的 数据 来 计算 其 所属 列 的 值 。 \n 字符 字符串 函数   下面 是 常用 的 一些 字符 处理 函数 处理函数 \n       函数   描述   实例           concat ( )   拼接 字符 字符串   SELECT   concat ( & lsquo ; Hello & rsquo ; ,   & lsquo ; ,   & lsquo ; ,   & lsquo ; World & rsquo ; , & lsquo ; ! & rsquo ; ) ;       format ( )   格式 格式化 数字 到 字符 字符串   SELECT   format ( 12332.1 , 4 ) ;       length ( )   返回 字符 字符串 长度   SELECT   length ( & lsquo ; xxx & rsquo ; ) ;       lcase ( ) / lower ( )   转换 小写   SELECT   lower ( & lsquo ; ABcDef & rsquo ; ) ;       ltrim ( )   去掉 左边 空白 字符   SELECT   ltrim ( & rsquo ;   AB   cD   f   & lsquo ; ) ;       repeat ( )   重复 输出 字符 字符串   SELECT   repeat ( & lsquo ; A & rsquo ; ,   3 ) ;       replace ( )   替换 字符 字符串   SELECT   replace ( & lsquo ; ABBCD & rsquo ; ,   & lsquo ; BB & rsquo ; ,   & lsquo ; W & rsquo ; ) ;       reverse ( )   翻转 输出 字符 字符串   SELECT   reverse ( & lsquo ; abcd & rsquo ; ) ;       left ( )   返回 左边 字符 字符串   SELECT   left ( & lsquo ; abcdf & rsquo ; ,   2 ) ;       right ( )   返回 右边 字符 字符串   SELECT   right ( & lsquo ; abcdf & rsquo ; ,   2 ) ;       rtrim ( )   去掉 右边 空白 字符   SELECT   rtrim ( & rsquo ;   AB   cD   f   & lsquo ; ) ;       substr ( ) / substring ( )   截取 子 字符 字符串   SELECT   substr ( & lsquo ; Quadratically & rsquo ; , 5 ) ; \n SELECT   substr ( & lsquo ; Quadratically & rsquo ; , 5 , 6 ) ;       trim ( )   去掉 空白 字符   SELECT   trim ( & rsquo ;   AB   cD   f   & lsquo ; ) ;       ucase ( ) / upper ( )   转换 大写   SELECT   upper ( & lsquo ; ABcDef & rsquo ; ) ;         还是 通过 实例 分析 他们 的 使用 \n 查询 班主 主任 班主任 信息 ， 输出 3 遍 老师 信息     分析 ： 查询 老师 信息 ， 输出 3 遍 老师 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 3   遍 班主 主任 班主任 信息   过滤 条件 ： 无   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   班主 主任 班主任   *   3 \n from   班级 ; \n     班主 主任 班主任   *   3   由于 班主 主任 班主任 存储 的 是 字符 字符串 类型 ， 重复 3 次 表示 为   repeat ( c _ head _ teacher ,   3 )       得到 如下   SQL \n select   repeat ( c _ head _ teacher ,   3 )   from   class ;     执行 得到 如下 结果 \n 试试 \n 查询 班级 名称 长度 并 将 班级 名称 翻转 输出     数值 计算 、 数值 函数   数值 计算 操作 操作符 \n       操作 操作符   描述   实例           +   加   select   2 + 3 ;       -   减   或   取反   select   2 - 1 ,   - 2 ;       *   乘   select   2 * 3 ;       /   或   div   除   select   2 & frasl ; 4 ,   2   div   4 ;       %   或   mod   取余   或   取模   select   2% 4 ,   2   mod   4 ;         数值 计算 函数 \n       函数   描述   实例           abs ( )   绝对 绝对值   SELECT   abs ( - 10 ) ,   abs ( 9 ) ;       ceil ( ) / ceilling ( )   上 取整   SELECT   ceiling ( 3.4 ) ,   ceil ( 3.5 ) ,   ceil ( 3.6 ) ;       conv ( )   进制 转换   SELECT   conv ( 10 , 10   , 2 ) ,   conv ( 10 , 2   , 10 ) ;       exp ( )   自然 自然数 数   e   的   n   次方   SELECT   exp ( 1 ) ,   exp ( 0 ) ,   exp ( - 1 ) ;       floor ( )   下 取整   SELECT   floor ( 3.4 ) ,   floor ( 3.5 ) ,   floor ( 3.6 ) ;       pow ( ) / power ( )   指数 函数 指数函数   SELECT   POW ( 1 , 3 ) ,   pow ( 2 , 3 ) ,   pow ( 4 , 2 ) ;       round ( )   四舍五入 取整   SELECT   round ( 3.4 ) ,   round ( 3.5 ) ,   round ( 3.6 ) ;       rand ( )   随机 机数 随机数   SELECT   rand ( ) ,   rand ( ) * 10 ;       mod ( )   取余 / 取模   SELECT   mod ( 25 ,   7 ) ,   25   %   7 ,   mod ( 25.4 ,   7 ) ,   25.4   %   7 ;       pi ( )   PI   值   SELECT   pi ( ) ,   pi ( ) + 0.0000000000 ;         查询 所有 学生 姓名 和 年龄 ， 将 所有 学生 的 年龄 翻倍 ， 且 年龄 大 的 在 后面     分析 ： 查询 所有 学生 信息 ， 将 所有 学生 的 年龄 翻倍 ， 且 年龄 大 的 在 后面 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 姓名 、 年龄 翻倍   过滤 条件 ： 无   排序 字 段 ： 龄 大 的 在 后面   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   姓名 ,   年龄 翻倍 \n from   学生 \n order   by   龄 大 的 在 后面 ; \n     得到 如下   SQL \n select   s _ name ,   s _ age   *   2   from   student   order   by   s _ age   *   2   asc ;     执行 得到 如下 结果 \n 查询 学生 年龄 和 姓名 ， 并 按照 年龄 的   1 & frasl ; 3   下 取整 输出     分析 ： 查询 学生 年龄 和 姓名 ， 并 按照 年龄 的 的   1 & frasl ; 3   下 取整 输出 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 姓名 、 年龄 的   1 & frasl ; 3   下 取整   过滤 条件 ： 无   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   姓名 ,   年龄 的   1 & frasl ; 3   下 取整 \n from   学生 \n order   by   龄 大 的 在 后面 ; \n   年龄 的   1 & frasl ; 3   下 取整   先求 出 年龄 的   1 / 3 ， 再用   下 取整 函数 处理 \n   得到 如下   SQL \n select   s _ name ,   floor ( s _ age / 3 )   from   student ;     执行 得到 如下 结果 \n 试试 \n 查询 所有 10 岁 的 学生 姓名 和 年龄 ， 要求 输出 2 遍 姓名 和 5 年 后 的 年龄     日期 时间 函数         函数   描述   实例           now ( )   当前 日期 时间   select   now ( ) ,   CURRENT _ TIMESTAMP ( ) ;       curtime ( )   当前 时间   select   curtime ( ) ;       curdate ( )   当前 日期   select   curdate ( ) ;       from _ unixtime ( )   从 时间 戳 到 日期   select   from _ unixtime ( 1 ) ;       unix _ timestamp ( )   返回 日期 时间 戳   select   unix _ timestamp ( now ( ) ) ;       time ( )   从 时间 里面 获取 时间 部分   select   time ( now ( ) )       date ( )   从 时间 里面 获取 日期 部分   select   now ( ) ,   date ( now ( ) ) ;       date _ format ( )   格式 格式化 日期 / 时间 数据 \n date _ format ( date ,   format )   select   date _ format ( now ( ) , & lsquo ; % b   % d   % Y   % h : % i   % p & rsquo ; ) , \n date _ format ( now ( ) , & lsquo ; % m - % d - % Y & rsquo ; ) ;       adddate ( ) / date _ add ( )   向 日期 添加 指定 的 时间 间隔 \n adddate ( date ,   interval   num   unit )   select   date _ add ( now ( )   , interval   45   DAY ) ,   adddate ( now ( )   , interval   45   DAY ) ;       subdate ( ) / date _ sub ( )   向 日期 减去 指定 的 时间 间隔 \n subdate ( date ,   interval   num   Type )   select   date _ sub ( now ( )   , interval   45   DAY ) ,   subdate ( now ( )   , interval   45   DAY ) ;       datediff ( )   返回 两个 日期 之间 的 天数   SELECT   datediff ( & lsquo ; 2018 - 01 - 30 & rsquo ; , & lsquo ; 2018 - 04 - 27 & rsquo ; ) ;         还有 很多 的 时间 获取 函数 ， 这里 不再 列举 ， 在 用到 的 时候 查下 文件 就行   《 MySQL   日期 时间 函数 》 \n 时间   ADD   和   SUB   的   unit   可 取值 有         Type   值           MICROSECOND       SECOND       MINUTE       HOUR       DAY       WEEK       MONTH       QUARTER       YEAR       SECOND _ MICROSECOND       MINUTE _ MICROSECOND       MINUTE _ SECOND       HOUR _ MICROSECOND       HOUR _ SECOND       HOUR _ MINUTE       DAY _ MICROSECOND       DAY _ SECOND       DAY _ MINUTE       DAY _ HOUR       YEAR _ MONTH         时间   format   可 使用 的 格式 有 ：         格式   描述           % a   缩写 星期 名       % b   缩写 月 名       % c   月 ， 数值       % D   带有 英文 前缀 的 月 中 的 天       % d   月 的 天 ， 数值 （ 00 - 31 ）       % e   月 的 天 ， 数值 （ 0 - 31 ）       % f   微秒       % H   小时 （ 00 - 23 ）       % h   小时 （ 01 - 12 ）       % I   小时 （ 01 - 12 ）       % i   分钟 ， 数值 （ 00 - 59 ）       % j   年 的 天 （ 001 - 366 ）       % k   小时 （ 0 - 23 ）       % l   小时 （ 1 - 12 ）       % M   月 名       % m   月 ， 数值 （ 00 - 12 ）       % p   AM   或   PM       % r   时间 ， 12 - 小时 （ hh : mm : ss   AM   或   PM ）       % S   秒 （ 00 - 59 ）       % s   秒 （ 00 - 59 ）       % T   时间 ,   24 - 小时 （ hh : mm : ss ）       % U   周 （ 00 - 53 ） 星期 期日 星期日 是 一周 的 第一 一天 第一天       % u   周 （ 00 - 53 ） 星期 星期一 是 一周 的 第一 一天 第一天       % V   周 （ 01 - 53 ） 星期 期日 星期日 是 一周 的 第一 一天 第一天 ， 与   % X   使用       % v   周 （ 01 - 53 ） 星期 星期一 是 一周 的 第一 一天 第一天 ， 与   % x   使用       % W   星期 名       % w   周 的 天 （ 0 = 星期 期日 星期日 ,   6 = 星期 星期六 ）       % X   年 ， 其中 的 星期 期日 星期日 是 周 的 第一 一天 第一天 ， 4   位 ， 与   % V   使用       % x   年 ， 其中 的 星期 星期一 是 周 的 第一 一天 第一天 ， 4   位 ， 与   % v   使用       % Y   年 ， 4   位       % y   年 ， 2   位         查询 学生 在 一年 哪一年 出生 ， 年份 早 的 排 在 前面     分析 ： 查询 学生 在 一年 哪一年 出生 ， 年份 早 的 排 在 前面 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 在 一年 哪一年 出生   过滤 条件 ： 无   排序 字 段 ： 年份 早 的 排 在 前面   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   在 一年 哪一年 出生 \n from   学生 \n order   by   年份 早 的 排 在 前面 ; \n   在 一年 哪一年 出生   这个 信息 是 在 生日 字 段 里面 ， 生日 字段 是 包含 了 年月日 信息 ， 只 需要 使用   year   函数 处理 就 能 得到 年 了 ： year ( s _ birthday ) \n   得到   SQL   语句 \n select   year ( s _ birthday )   from   student   order   by   year ( s _ birthday )   asc ;     执行 得到 如下 结果 \n 试试 \n 大家 发现 学生 表 里面 有 年龄 字段 和 生日 字 段 ， 上面 我们 使用 了 生日 计算 出生 年 ， 现在 使用 年龄 计算 出生 年 ， 看看 会 是 什么 结果 ， 应该 是 和 生日 不 一样 的 （ 这里 是 故意 的 ， 后面 在 修改 数据 时候 会 改过 过来 改过来 ）   计算 班级 从 开班 时间 到 结束 时间 持续 了 多少 天     流程 控制 函数   MySQL   流程 控制 函数 有   4   个 ： CASE 、 IF ( ) 、 IFNULL   、 NULLIF   ， 我 自己 平时 用 的 最 多 的 是   CASE   ， 这里 只 演示   CASE   的 使用 ， 其他 几个 在 一个 特定 的 场景 下 使用 ， 时候 到时候 遇到 了 查下 文档 吧 。 \n CASE   语法   CASE   语句 有 2 中 语法 ， 一种 是 值 判断 ， 一种 是 条件 判断 。 \n 值 判断 语法   CASE   value   WHEN   [ compare _ value ]   THEN   result   [ WHEN   [ compare _ value ]   THEN   result   ... ]   [ ELSE   result ]   END     条件 判断 语法   CASE   WHEN   [ condition ]   THEN   result   [ WHEN   [ condition ]   THEN   result   ... ]   [ ELSE   result ]   END     查询 学生 性别 和 姓名 ， 性别 输出 文 中文 男和女 （ 0 ： 女 ， 1 ： 男 ）   select   s _ name ,   case   c _ sex   when   0   then   ' 女 '   when   1   then   ' 男 '   end   as   ' 性别 '   from   student     查询 学习 性别 和 年龄 年龄段 ， 年龄 年龄段 输出 为 ： 1 ~ 10 的 为 小 ， 11 ~ 15 的 中 ， 16 ~ 20 的 大   select   s _ name ,   case   when   s _ age & gt ; = 1   and   s _ age & lt ; = 10   then   ' 小 '   when   s _ age & gt ; = 11   and   s _ age & lt ; = 15   then   ' 中 '   when   s _ age & gt ; = 16   and   s _ age & lt ; = 20   then   ' 大 '   end   as   ' 年龄 年龄段 '   from   student ;     试试 \n 查询 学生 生日 的 月份 ， 要求 中文 数值 输出 月份 ( 比如 ： 一月 、 二月 、 三月 )       上面 最后 两个   SQL   没有 给出 详细 的 分析 过程 ， 对于 这个 分析 过程 可以 自行 按照 之前 的 模式 进行 ， 这种 分析 模式 掌握 过后 ， 不论 多 复杂 的 需求 和   SQL   都 可以 做到 游刃 有余 游刃有余 ， 所以 大家 一定 要 掌握 。 对于 后面 简单 的   SQL   不再 给出 详细 细分 分析 详细分析 过程 ， 分析 过程 只 针对 复杂   SQL   和 关键 部分 ， 如果 大家 对于 哪个 问题 和 SQL   需要 分析 过程 的 ， 可以 在 后面 留言 或 联系 我 。 \n   总结     计算 字 段 、 计算 列 、 虚拟 列   常用 字符 字符串 函数   常用 数值 计算 、 数值 函数   常用 日期 时间 函数   流程 控制 函数 ： case   语句 的   2   种 格式  ", "title_s": "小白学   SQL   第五 五天 第五天 ： 数据 操作 函数"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/4-query-where/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第四天：数据过滤查询", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/4-query-where/", "content": "在第三天的时候学习了数据的基本查询结构，包括：查询指定列，返回指定大小结果集，数据排序，数据去重。今天将学习查询里面另外一个基础且重要的查询结构：过滤查询（也叫条件查询），可以说现今你能看到的所有涉及到 RDBMS 软件一定都有 过滤查询 。所以今天的内容一定要掌握，也是一切用到 RDBMS 系统的所需掌握的基础知识之一。\n今天涉及到的知识要点：\n where子句子结构 数值、时间 字符串匹配： like、百分号（%）通配符、下划线（_）通配符 范围值检查：between 、in 空值查询：is null、not 组合查询：and、or、求值顺序  \nWHERE 子句结构 既然是子句就一定是跟在主句后面，where 子句可以用在 select、update、delete 语句中。今天只会讲解在 select 语句中的使用，update 和 delete 中的使用会在后面 数据插入、修改和删除 中讲解。首先还是来看一下 where 子句在 select 中的结构\nselect [distinct] 列1，列2，... from table_name [where 条件1 [and|or] 条件2 ...] [order by 列1 desc[, 列2 asc]] [limit offset, size];   where 条件1 [and|or] 条件2 … 过滤条件。可以使用逻辑连接符（and 或 or）连接多个条件。\n条件N 每个条件。格式： &lt;列&gt; &lt;操作符&gt; &lt;值&gt;\n 大家可以和前一天的 Select 语句做对比看有什么不同\n操作符    操作符 说明 操作符 说明     = 等于 &gt; 大于   &lt;&gt; 不等于 &gt;= 大于等于   != 不等于 !&gt; 不大于   &lt; 小于 between 在指定两个值之间   &lt;= 小于等于 is null 为null的值   !&lt; 不小于 like 匹配   and 逻辑与 or 逻辑或   not 逻辑非      数值、时间过滤 还记得之前在《数据表创建》时说明的数据类型吗？如果没有什么印象可以转过去浏览一遍。在做数据过滤查询的，我们要关注所使用过滤列的数据类型，判断我们所需要使用的操作符和数值表达方式，我们还是通过实例讲解。\n查询已开学班级的名称和班主任  分析：查询 已开学 班级 的 名称 和 班主任\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：名称、班主任 过滤条件：已开学 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,班主任\nfrom 班级\nwhere 已开学;\n  这里的 已开学 怎么表示呢？我们看班级的创建 SQL，会发现列 c_status 的描述是 班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】\n  在结合*条件格式： &lt;列&gt; &lt;操作符&gt; &lt;值&gt;，这时候就比较清晰了吧：班级状态 是/等于 已开学，班级状态在数据库存的数据类型是 数值型 ，这里也就是 3 。这个时候在将语言翻译成代码表达：c_status = 3 。\n 现在所有需要的信息都收集完成了，组装我们 SQL 语句：\nselect c_name, c_head_teacher from class where c_status = 3;  执行这个语句会的一下结果\n查询标识 id大于10 的班级的标识 id 和名称信息  分析：查询 标识 id大于10** 班级 的 标识 id 和 名称 信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：标识 id，名称 过滤条件：标识 id大于10 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,班主任\nfrom 班级\nwhere 标识 id 大于 10;\n 结合上面的操作符描述 标识 id 大于 10 的代码标识：c_id &gt; 10\n 所以的 SQL 语句：\nselect c_name, c_head_teacher from class where c_id &gt; 10;  执行这个语句会的一下结果\n查询在2018年4月2日开班的班级名称、标识 id和开班时间  分析：查询 在 在 2018年4月2日开班 的 班级名称 和 标识 id\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：标识 id，名称，开班时间 过滤条件：在 2018年4月2日开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,标识 id,开班时间\nfrom 班级\nwhere 在 2018年4月2日开班;\n 在这里我们发现 开班时间 在表里面的存储类型是日期 date 类型，这里就涉及到日志的表示方式，以下是默认表示方式:\n    日志类型 表示格式 例子     year YYYY 或 YY 第一种是直接插入4位字符串或者4位数字（推荐）。\n第二种是插入2位字符串。如插入‘00’~‘69’，则相当于插入2000~2069；如果插入‘70’~‘99’，则相当于插入1970~1999。第二种情况下插入的如果是‘0’，则与插入‘00’效果相同，都是表示2000年。\n第三种是插入2位数字，它与第二种（插入两位字符串）不同之处仅在于：如果插入的是一位数字0，则表示的是0000，而不是2000年。所以在给YEAR类型赋值时，一定要分清0和‘0’，虽然两者相差个引号，但实际效果确实相差了2000年。   time HH:MM:SS 14:23:23   date YYYY-MM-DD 2018-04-23   datetime YYYY-MM-DD HH:MM:SS 2018-04-23 14:23:23   timestamp YYYY-MM-DD HH:MM:SS A、CURRENT_TIMESTAMP或 NULL或无任何输入 这时系统会自动填入当前 timestamp 值（这个需要创建列时设置）\nB、`2018-04-23 14:23:23\n注意： timestamp数值是与时区相关的。    通过以上分析，得到 SQL 语句：\nselect c_name, c_status, c_start_time, c_end_time from class where c_start_time='2018-04-02';  执行这个语句会的一下结果\n试试\n查找还未结束的且开始时间最晚的前6个班级的名称、状态、开始时间和结束时间信息  字符串匹配 首先字符串在 SQL 中需要单引号包裹起来，比如：'字符串1'、'hello world!'。\n查询班主任姓名为 老师10 的班级信息，结束时间最晚的在前面  分析：查询 在 班主任姓名为 老师10 的 班级信息，结束时间最晚的在前面\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：班主任姓名为 老师10 排序字段：结束时间 -&gt; 倒序（结束时间最晚的在前面） 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 班主任姓名为 老师10\norder by 结束时间 倒序;\n  所以得到 SQL\nselect * from class where c_head_teacher = '老师10' order by c_end_time desc;  执行 sql 得到如下结果\n 在实际使用字符串匹配查询的时候，处理上面例子演示的 精确查找 以外，我们还会有 模糊查找 的需求（也叫 *模糊匹配*）。比如我们常常有 查找姓王的用户 、 查询名字中含有水字的用户 等需求。\n字符串的模糊匹配使用 like 关键字，既然是模式匹配就说明列里面的部分信息我们是不关心的，也不知道他们具体是什么值，这时对于这些不关心的数据我们使用 占位符 。MySQL 数据库支持的占位符有 2 个: % 和 _ ，这两个的比较说明如下：\n   占位符 说明 实例     % 一次匹配多个任意字符 王%：所有以 王 开头的任意长度的数据，例如：王，王x、王 xx\n%王：所有以 王 开头的任意长度的数据，例如：王，x王、xx王\n%王%：所有包含 王 的数据，不论王所在位置   _ 一次匹配一个任意字符 王_：所以以 王 开头的 2 个长度的数据，例如：王 x，王2    \n试试\n大家可以思考一下 %刘_ 是匹配什么样的数据   查询所有以老师开头的班主任信息，结果去重  分析：查询 所有 以老师开头 的 班主任信息，结果去重\n 操作类型：select （查询） 到哪里取数据：班级（班主任信息在班级表里） 得到哪些信息：班主任信息 过滤条件：以 &ldquo;老师&rdquo; 开头的班主任 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 去重 班主任\nfrom 班级\nwhere 以 &ldquo;老师&rdquo; 开头的班主任;\n  所得 SQL\nselect distinct c_head_teacher from class where c_head_teacher like '老师%';  直接结果\n试试\n查询所有姓张且姓名包含三个字的学生信息  空值查询 在数据库里面还存在一种类型：null ，他表示没有值，意味着我们什么都没有输入。注意这个值和 空字符串'' 的区别：'' 标识值是空字符串(有值)；null 标识无值。我们要查询一个列是否包含有无值得数据使用 is null 。大家可以执行下面这个 SQL ，大家可以自行分析一下这个 SQL 所表达的需求\nselect * from class where c_start_time is null;  由于我们现在数据库里面没有无值的数据，所以结果是空的\n现在我们在加入 2 条空值数据，请执行下面的插入 SQL\nINSERT INTO `sql-learn`.`class`(`c_id`, `c_name`, `c_head_teacher`, `c_start_time`, `c_end_time`, `c_status`, `c_created`) VALUES (17, '酱油班1', '酱油老师', NULL, NULL, 3, '2018-04-24 13:03:39'), (18, '酱油班2', '酱油老师', NULL, NULL, 2, '2018-04-24 13:03:33');  插入完成过后，再执行上面的查询 SQL ，这时候就会出现我们刚才插入的 2 条数据：酱油班1 和 酱油班2 。这时我们查询出了所有的 无值 数据，那我们怎么得到所有 有值 数据呢？这里只要我们对过滤条件取反（或叫取非）就可以了：关键字 not 。请大家执行下面 SQL 分析结果：\nselect * from class where not c_start_time is null;   not 关键字就是对某一过滤条件取反，它不仅仅是用在 is null 条件上面，可以用在任何一个过滤条件上，甚至后面的组合查询里面的组合条件也是可以使用的。大家可以将前面实验的 SQL 语句的查询条件上面加上 not 在执行看看结果，是否和你理解的一致。\n建议大家不要随意使用 not ，这个会导致你的 SQL 语句变复制、不易理解，同时导致后面优化 SQL 变得困难。建议只使用在 is null 和 like 操作上。\n 范围查询 前面的所有查询都是单个值查询，现在如果我们知道了 2 个班主任老师的名称：酱油老师 和 *会计老师1*，我们需要查询这 2 个老师的负责的所有班级怎么办呢？用我们的上面的查询都办不到，现在需要一种新的查询类型：范文查询。范围查询有 2 中格式：between start_value and end_value 和 in ，between 表示连续值范围查询，多用在数值和时间范围；in 表示非连续值范围，多用在字符串范围查询。具体我们通过实例分析\n查询 会计老师1 和 酱油老师 2个老师负责的所有班级信息  分析：查询 会计老师1 和 酱油老师 2个老师负责的所有班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：会计老师1 和 酱油老师 (使用 in) 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 会计老师1 和 酱油老师;\n 在这里我们可以看到同时有 2 个值，同时这两个值没有相关性和连续性，所以这里使用 in\n 得到以下 SQL\nselect * from class where c_head_teacher in ('会计老师1', '酱油老师');  执行 SQL 得到以下结果\n查询开班时间在2017-12-03到2018-04-01之间的所有班级信息  分析：查询开班时间在2017-12-03到2018-04-01之间的所有班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：开班时间在2017-12-03到2018-04-01之间（使用 between） 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 开班时间在2017-12-03到2018-04-01之间;\n 在这里我们发现也是 2 个条件值，但是这次的要求是找到 2017-12-03到2018-04-01之间 的所有班级，因为在我们查询数据之前没有办法知道每个班级的具体开班时间，同时从2017-12-03到2018-04-01之间 的所有日期时间点我们没有办法穷举出来（这里可能有人会说可以列举出来，这之间也没有多少天，但是如果我们这里存入的不是天，而是需要精确到秒呢，更进一步这里需要精确到毫秒呢（如创建时间）），所以这里我们就不能用 in 了，需要使用 between\n 通过上面分析，得到如下 SQL\nselect * from class where c_start_time between '2017-12-03' and '2018-04-01';  得到如下结果\n试试\n查询开班时间是 2017-10-09 和 2018-04-02 的班级信息 在 between 语句中的 2 值有包含在查询结果集里面吗？写出 SQL 验证你的结论  组合查询 在前面我们已经学习了很多的过滤条件，但是大家会发现这些条件都是基于某一个属性的单个值或多个值进行查询，那我们如果我们需要同时匹配多个属性的值查询应该怎么办呢？这个时候就需要用到我们接下来学习的 组合查询 了。组合查询顾名思义就是组合了多个过滤条件的查询语句，其中组合的方式有 2 中：and 和 or 。这两个的含义和区别如下：\n   组合方式 含义 实例     and 逻辑与（同时满足） A and B and C：A、B、C 3个条件必须全部为真才满足   or 逻辑或（满足其一） A or B or C：A、B、C 3个条件 只要其中一个为真就满足    下面我们还是通过 2 个实例来具体学习\n查询老师10在2018-04-02这天开班的班级信息  分析：查询老师10在2018-04-02这天开班的班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：老师10 、2018-04-02开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 老师10 、2018-04-02开班;\n 这这里我们看到有 老师10 和 2018-04-02开班 2 个值，我们发现 老师10 是班主任信息字段，而 2018-04-02开班 是开班时间字段，两个不是同一个字段，这样就不能使用上面的范围查询了(between 和 in)。既然是 2 个字段条件，那我们就来分开分析：\n 老师10：要求班主任是老师10 =&gt; c_head_teacher='老师10' 2018-04-02开班：开班时间在2018-04-02 =&gt; c_start_time='2018-04-02'  现在两个条件都分析清楚了，那这两个条件的组合方式是什么呢？根据问题 *老师10在 2018-04-02这天开班*： 必须需要 老师10 在 2018-04-02 这天开班的班级信息，老师和开班时间 2 个条件必须满足，所以组合方式是 and，组合得到的过滤条件就是:c_head_teacher='老师10' and c_start_time='2018-04-02' 。现在所有的分析都完成了，来看我们得到的 SQL 语句\n 所得 SQL 语句\nselect * from class where c_head_teacher='老师10' and c_start_time='2018-04-02';  执行得到以下结果\n查询老师5 或 2018-04-02这天开班的班级信息  分析：查询老师10在2018-04-02这天开班的班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：老师10 或 2018-04-02开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 老师10 或 2018-04-02开班;\n 根据之前的分析这里的两个条件\n c_head_teacher='老师5' c_start_time='2018-04-02'  但是这里这里的组合方式和上面会不一样，有发现吗？这里的需求是: 老师5 或 2018-04-02 ，应该使用的组合方式是 or。\n所以组合得到的过滤条件就是:c_head_teacher='老师5' or c_start_time='2018-04-02'\n 所得 SQL 语句\nselect * from class where c_head_teacher='老师5' or c_start_time='2018-04-02';  执行得到以下结果\n  当组合多个过滤的时候如果同时有 and 和 or 的组合方式，需要注意执行的优先级和先后顺序 sql语句中not and or的执行优先级从高到低依次为: not &gt; and &gt; or\n 执行时从左到右依次执行\n 重要建议 对于不能确定的时候可以使用小括号 () 改变或指明优先级\n 对于同时又 not、and、or 的组合查询始终使用 () 指明优先级\n   试试\n试着把上面使用 in 的查询改成组合查询：查询 会计老师1和酱油老师2个老师负责的所有班级信息 查询姓王且年龄在16岁以下学生和在西安的学生，年龄最小的排在前面  总结 这次的东西有点多，特别是组合查询需要多多联系和实践，\n where子句子结构，操作符 数值、时间：时间的表示方法 字符串匹配： like、百分号（%）通配符、下划线（_）通配符 范围值检查：between … and … 、in 空值查询：is null、not 组合查询：and、or、优先级和求值顺序 ", "content_s": "在 第三 三天 第三天 的 时候 学习 了 数据 的 基本 查询 结构 ， 包括 ： 查询 指定 列 ， 返回 指定 大小 结果 集 ， 数据 排序 ， 数据 去 重 。 今天 将 学习 查询 里面 另外 一个 基础 且 重要 的 查询 结构 ： 过滤 查询 （ 也 叫 条件 查询 ） ， 可以 说 现今 你 能 看到 的 所有 涉及 到   RDBMS   软件 一定 都 有   过滤 查询   。 所以 今天 的 内容 一定 要 掌握 ， 也 是 一切 用到   RDBMS   系统 的 所 需 掌握 的 基础 知识 基础知识 之一 。 \n 今天 涉及 到 的 知识 要点 ： \n   where 子 句子 结构   数值 、 时间   字符 字符串 匹配 ：   like 、 百分 分号 百分号 （ % ） 通配符 、 下划 划线 下划线 （ _ ） 通配符   范围 值 检查 ： between   、 in   空值 查询 ： is   null 、 not   组合 查询 ： and 、 or 、 求值 顺序     \n WHERE   子句 结构   既然 是 子句 就 一定 是 跟 在 主句 后面 ， where   子句 可以 用 在   select 、 update 、 delete   语句 中 。 今天 只会 讲解 在   select   语句 中 的 使用 ， update   和   delete   中 的 使用 会 在 后面   数据 插入 、 修改 和 删除   中 讲解 。 首先 还是 来看 一下   where   子句 在   select   中 的 结构 \n select   [ distinct ]   列 1 ， 列 2 ， ...   from   table _ name   [ where   条件 1   [ and | or ]   条件 2   ... ]   [ order   by   列 1   desc [ ,   列 2   asc ] ]   [ limit   offset ,   size ] ;       where   条件 1   [ and | or ]   条件 2   …   过滤 条件 。 可以 使用 逻辑 连接 连接符 （ and   或   or ） 连接 多个 条件 。 \n 条件 N   每个 条件 。 格式 ：   & lt ; 列 & gt ;   & lt ; 操作 操作符 & gt ;   & lt ; 值 & gt ; \n   大家 可以 和 一天 前一天 的   Select   语句 做 对比 看 有 什么 不同 \n 操作 操作符         操作 操作符   说明   操作 操作符   说明           =   等于   & gt ;   大于       & lt ; & gt ;   不 等于   & gt ; =   大于 等于       ! =   不 等于   ! & gt ;   不 大于       & lt ;   小于   between   在 指定 两个 值 之间       & lt ; =   小于 等于   is   null   为 null 的 值       ! & lt ;   不 小于   like   匹配       and   逻辑 与   or   逻辑 或       not   逻辑 非             数值 、 时间 过滤   还 记得 之前 在 《 数据 数据表 创建 》 时 说明 的 数据 类型 数据类型 吗 ？ 如果 没有 什么 印象 可以 转过 去 浏览 一遍 。 在 做 数据 过滤 查询 的 ， 我们 要 关注 所 使用 过滤 列 的 数据 类型 数据类型 ， 判断 我们 所 需要 使用 的 操作 操作符 和 数值 表达 方式 表达方式 ， 我们 还是 通过 实例 讲解 。 \n 查询 已 开学 班级 的 名称 和 班主 主任 班主任     分析 ： 查询   已 开学   班级   的   名称   和   班主 主任 班主任 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 名称 、 班主 主任 班主任   过滤 条件 ： 已 开学   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称 , 班主 主任 班主任 \n from   班级 \n where   已 开学 ; \n     这里 的   已 开学   怎么 表示 呢 ？ 我们 看 班级 的 创建   SQL ， 会 发现 列   c _ status   的 描述 是   班级 状态 【 0 ： 报名 未 开始 ， 1 ： 报名 中 ， 2 ： 报名 完成 ， 3 ： 已 开学 ， 4 ： 已 结业 】 \n     在 结合 * 条件 格式 ：   & lt ; 列 & gt ;   & lt ; 操作 操作符 & gt ;   & lt ; 值 & gt ; ， 这时 时候 这时候 就 比较 清晰 了 吧 ： 班级 状态   是 / 等于   已 开学 ， 班级 状态 在 数据 据库 数据库 存 的 数据 类型 数据类型 是   数值 型   ， 这里 也 就是   3   。 这个 时候 在 将 语言 翻译 译成 翻译成 代码 表达 ： c _ status   =   3   。 \n   现在 所有 需要 的 信息 都 收集 完成 了 ， 组装 我们   SQL   语句 ： \n select   c _ name ,   c _ head _ teacher   from   class   where   c _ status   =   3 ;     执行 这个 语句 会 的 一下 结果 \n 查询 标识   id 大于 10   的 班级 的 标识   id   和 名称 信息     分析 ： 查询   标识   id 大于 10 * *   班级   的   标识   id   和   名称   信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 标识   id ， 名称   过滤 条件 ： 标识   id 大于 10   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称 , 班主 主任 班主任 \n from   班级 \n where   标识   id   大于   10 ; \n   结合 上面 的 操作 操作符 描述   标识   id   大于   10   的 代码 标识 ： c _ id   & gt ;   10 \n   所以 的   SQL   语句 ： \n select   c _ name ,   c _ head _ teacher   from   class   where   c _ id   & gt ;   10 ;     执行 这个 语句 会 的 一下 结果 \n 查询 在 2018 年 4 月 2 日 开班 的 班级 名称 、 标识   id 和 开班 时间     分析 ： 查询   在   在   2018 年 4 月 2 日 开班   的   班级 名称   和   标识   id \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 标识   id ， 名称 ， 开班 时间   过滤 条件 ： 在   2018 年 4 月 2 日 开班   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称 , 标识   id , 开班 时间 \n from   班级 \n where   在   2018 年 4 月 2 日 开班 ; \n   在 这里 我们 发现   开班 时间   在 表 里面 的 存储 类型 是 日期   date   类型 ， 这里 就 涉及 到 日志 的 表示 方式 ， 以下 是 默认 表示 方式 : \n         日志 类型   表示 格式   例子           year   YYYY   或   YY   第一 一种 第一种 是 直接 接插 插入 直接插入 4 位 字符 字符串 或者 4 位 数字 （ 推荐 ） 。 \n 第二 二种 第二种 是 插入 2 位 字符 字符串 。 如 插入 ‘ 00 ’ ~ ‘ 69 ’ ， 则 相当 当于 相当于 插入 2000 ~ 2069 ； 如果 插入 ‘ 70 ’ ~ ‘ 99 ’ ， 则 相当 当于 相当于 插入 1970 ~ 1999 。 第二 二种 第二种 情况 下 插入 的 如果 是 ‘ 0 ’ ， 则 与 插入 ‘ 00 ’ 效果 相同 ， 都 是 表示 2000 年 。 \n 第三 三种 第三种 是 插入 2 位 数字 ， 它 与 第二 二种 第二种 （ 插入 两位 字符 字符串 ） 不同 之处 不同之处 仅 在于 ： 如果 插入 的 是 一位 数字 0 ， 则 表示 的 是 0000 ， 而 不是 2000 年 。 所以 在 给 YEAR 类型 赋值 时 ， 一定 要 分清 0 和 ‘ 0 ’ ， 虽然 两者 相差 个 引号 ， 但 实际 效果 实际效果 确实 相差 了 2000 年 。       time   HH : MM : SS   14 : 23 : 23       date   YYYY - MM - DD   2018 - 04 - 23       datetime   YYYY - MM - DD   HH : MM : SS   2018 - 04 - 23   14 : 23 : 23       timestamp   YYYY - MM - DD   HH : MM : SS   A 、 CURRENT _ TIMESTAMP 或   NULL 或 无 任何 输入   这时 系统 会 自动 填入 当前   timestamp   值 （ 这个 需要 创建 列时 设置 ） \n B 、 ` 2018 - 04 - 23   14 : 23 : 23 \n 注意 ：   timestamp 数值 是 与 时区 相关 的 。         通过 以上 分析 ， 得到   SQL   语句 ： \n select   c _ name ,   c _ status ,   c _ start _ time ,   c _ end _ time   from   class   where   c _ start _ time = ' 2018 - 04 - 02 ' ;     执行 这个 语句 会 的 一下 结果 \n 试试 \n 查找 还 未 结束 的 且 开始 时间 最晚 的 前 6 个 班级 的 名称 、 状态 、 开始 时间 和 结束 时间 信息     字符 字符串 匹配   首先 字符 字符串 在   SQL   中 需要 引号 单引号 包裹 起来 ， 比如 ： ' 字符 字符串 1 ' 、 ' hello   world ! ' 。 \n 查询 班主 主任 班主任 姓名 为   老师 10   的 班级 信息 ， 结束 时间 最晚 的 在 前面     分析 ： 查询   在   班主 主任 班主任 姓名 为   老师 10   的   班级 信息 ， 结束 时间 最晚 的 在 前面 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 班主 主任 班主任 姓名 为   老师 10   排序 字 段 ： 结束 时间   - & gt ;   倒序 （ 结束 时间 最晚 的 在 前面 ）   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   班主 主任 班主任 姓名 为   老师 10 \n order   by   结束 时间   倒序 ; \n     所以 得到   SQL \n select   *   from   class   where   c _ head _ teacher   =   ' 老师 10 '   order   by   c _ end _ time   desc ;     执行   sql   得到 如下 结果 \n   在 实际 使用 字符 字符串 匹配 查询 的 时候 ， 处理 上面 例子 演示 的   精确 查找   以外 ， 我们 还会 有   模糊 查找   的 需求 （ 也 叫   * 模糊 匹配 * ） 。 比如 我们 常常 有   查找 姓王 的 用户   、   查询 名字 中 含有 水字 的 用户   等 需求 。 \n 字符 字符串 的 模糊 匹配 使用   like   关键 关键字 ， 既然 是 模式 匹配 模式匹配 就 说明 列 里面 的 部分 信息 我们 是 不 关心 的 ， 也 不 知道 他们 具体 是 什么 值 ， 这时 对于 这些 不 关心 的 数据 我们 使用   占位 符   。 MySQL   数据 据库 数据库 支持 的 占位 符有   2   个 :   %   和   _   ， 这 两个 的 比较 说明 如下 ： \n       占位 符   说明   实例           %   一次 匹配 多个 任意 字符   王 % ： 所有 以   王   开头 的 任意 长度 的 数据 ， 例如 ： 王 ， 王 x 、 王   xx \n % 王 ： 所有 以   王   开头 的 任意 长度 的 数据 ， 例如 ： 王 ， x 王 、 xx 王 \n % 王 % ： 所有 包含   王   的 数据 ， 不论 王 所在 在位 位置 所在位置       _   一次 匹配 一个 任意 字符   王 _ ： 所以 以   王   开头 的   2   个 长度 的 数据 ， 例如 ： 王   x ， 王 2         \n 试试 \n 大家 可以 思考 一下   % 刘 _   是 匹配 什么 什么样 的 数据       查询 所有 以 老师 开头 的 班主 主任 班主任 信息 ， 结果 去 重     分析 ： 查询   所有   以 老师 开头   的   班主 主任 班主任 信息 ， 结果 去 重 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级 （ 班主 主任 班主任 信息 在 班级 表里 ）   得到 哪些 信息 ： 班主 主任 班主任 信息   过滤 条件 ： 以   & ldquo ; 老师 & rdquo ;   开头 的 班主 主任 班主任   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   去 重   班主 主任 班主任 \n from   班级 \n where   以   & ldquo ; 老师 & rdquo ;   开头 的 班主 主任 班主任 ; \n     所得   SQL \n select   distinct   c _ head _ teacher   from   class   where   c _ head _ teacher   like   ' 老师 % ' ;     直接 结果 \n 试试 \n 查询 所有 姓张 且 姓名 包含 三个 字 的 学生 信息     空值 查询   在 数据 据库 数据库 里面 还 存在 一种 类型 ： null   ， 他 表示 没有 值 ， 意味 意味着 我们 什么 都 没有 输入 。 注意 这个 值 和   空 字符 字符串 ' '   的 区别 ： ' '   标识 值 是 空 字符 字符串 ( 有值 ) ； null   标识 无值 。 我们 要 查询 一个 列 是否 包含 有无 值得 数据 使用   is   null   。 大家 可以 执行 下面 这个   SQL   ， 大家 可以 自行 分析 一下 这个   SQL   所 表达 的 需求 \n select   *   from   class   where   c _ start _ time   is   null ;     由于 我们 现在 数据 据库 数据库 里面 没有 无值 的 数据 ， 所以 结果 是 空 的 \n 现在 我们 在 加入   2   条 空值 数据 ， 请 执行 下面 的 插入   SQL \n INSERT   INTO   ` sql - learn ` . ` class ` ( ` c _ id ` ,   ` c _ name ` ,   ` c _ head _ teacher ` ,   ` c _ start _ time ` ,   ` c _ end _ time ` ,   ` c _ status ` ,   ` c _ created ` )   VALUES   ( 17 ,   ' 酱油 班 1 ' ,   ' 酱油 老师 ' ,   NULL ,   NULL ,   3 ,   ' 2018 - 04 - 24   13 : 03 : 39 ' ) ,   ( 18 ,   ' 酱油 班 2 ' ,   ' 酱油 老师 ' ,   NULL ,   NULL ,   2 ,   ' 2018 - 04 - 24   13 : 03 : 33 ' ) ;     插入 完成 过后 ， 再 执行 上面 的 查询   SQL   ， 这时 时候 这时候 就 会 出现 我们 刚才 插入 的   2   条 数据 ： 酱油 班 1   和   酱油 班 2   。 这时 我们 查询 出 了 所有 的   无值   数据 ， 那 我们 怎么 得到 所有   有值   数据 呢 ？ 这里 只要 我们 对 过滤 条件 取反 （ 或 叫 取非 ） 就 可以 了 ： 关键 关键字   not   。 请 大家 执行 下面   SQL   分析 结果 ： \n select   *   from   class   where   not   c _ start _ time   is   null ;       not   关键 关键字 就是 对 某 一 过滤 条件 取反 ， 它 不仅 仅仅 不仅仅 是 用 在   is   null   条件 上面 ， 可以 用 在 任何 一个 过滤 条件 上 ， 甚至 后面 的 组合 查询 里面 的 组合 条件 也 是 可以 使用 的 。 大家 可以 将 前面 实验 的   SQL   语句 的 查询 条件 上面 加上   not   在 执行 看看 结果 ， 是否 和 你 理解 的 一致 。 \n 建议 大家 不要 随意 使用   not   ， 这个 会 导致 你 的   SQL   语句 变 复制 、 不易 理解 ， 同时 导致 后面 优化   SQL   变得 困难 。 建议 只 使用 在   is   null   和   like   操作 上 。 \n   范围 查询   前面 的 所有 查询 都 是 单个 值 查询 ， 现在 如果 我们 知道 了   2   个 班主 主任 班主任 老师 的 名称 ： 酱油 老师   和   * 会计 老师 1 * ， 我们 需要 查询 这   2   个 老师 的 负责 的 所有 班级 怎么 怎么办 呢 ？ 用 我们 的 上面 的 查询 都 不到 办不到 ， 现在 需要 一种 新 的 查询 类型 ： 范文 查询 。 范围 查询 有   2   中 格式 ： between   start _ value   and   end _ value   和   in   ， between   表示 连续 值 范围 查询 ， 多用 在 数值 和 时间 范围 ； in   表示 非 连续 值 范围 ， 多用 在 字符 字符串 范围 查询 。 具体 我们 通过 实例 分析 \n 查询   会计 老师 1   和   酱油 老师   2 个 老师 负责 的 所有 班级 信息     分析 ： 查询   会计 老师 1   和   酱油 老师   2 个 老师 负责 的 所有 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 会计 老师 1   和   酱油 老师   ( 使用   in )   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   会计 老师 1   和   酱油 老师 ; \n   在 这里 我们 可以 看到 同时 有   2   个值 ， 同时 这 两个 值 没有 相关 相关性 和 连续 连续性 ， 所以 这里 使用   in \n   得到 以下   SQL \n select   *   from   class   where   c _ head _ teacher   in   ( ' 会计 老师 1 ' ,   ' 酱油 老师 ' ) ;     执行   SQL   得到 以下 结果 \n 查询 开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 的 所有 班级 信息     分析 ： 查询 开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 的 所有 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 （ 使用   between ）   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 ; \n   在 这里 我们 发现 也 是   2   个 条件 值 ， 但是 这次 的 要求 是 找到   2017 - 12 - 03 到 2018 - 04 - 01 之间   的 所有 班级 ， 因为 在 我们 查询 数据 之前 没有 办法 知道 每个 班级 的 具体 开班 时间 ， 同时 从 2017 - 12 - 03 到 2018 - 04 - 01 之间   的 所有 日期 时间 点 我们 没有 办法 穷举 出来 （ 这里 可能 有人 会 说 可以 列举 出来 ， 这 之间 也 没有 多少 天 ， 但是 如果 我们 这里 存入 的 不是 天 ， 而是 需要 精确 到 秒 呢 ， 一步 进一步 更进一步 这里 需要 精确 到 毫秒 呢 （ 如 创建 时间 ） ） ， 所以 这里 我们 就 不能 用   in   了 ， 需要 使用   between \n   通过 上面 分析 ， 得到 如下   SQL \n select   *   from   class   where   c _ start _ time   between   ' 2017 - 12 - 03 '   and   ' 2018 - 04 - 01 ' ;     得到 如下 结果 \n 试试 \n 查询 开班 时间 是   2017 - 10 - 09   和   2018 - 04 - 02   的 班级 信息   在   between   语句 中 的   2   值有 包含 在 查询 结果 集 里面 吗 ？ 写出   SQL   验证 你 的 结论     组合 查询   在 前面 我们 已经 学习 了 很多 的 过滤 条件 ， 但是 大家 会 发现 这些 条件 都 是 基于 某 一个 属性 的 单个 值 或 多个 值 进行 查询 ， 那 我们 如果 我们 需要 同时 匹配 多个 属性 的 值 查询 应该 怎么 怎么办 呢 ？ 这个 时候 就 需要 用到 我们 接下 下来 接下来 学习 的   组合 查询   了 。 组合 查询 顾名 顾名思义 就是 组合 了 多个 过滤 条件 的 查询 语句 ， 其中 组合 的 方式 有   2   中 ： and   和   or   。 这 两个 的 含义 和 区别 如下 ： \n       组合 方式   含义   实例           and   逻辑 与 （ 同时 满足 ）   A   and   B   and   C ： A 、 B 、 C   3 个 条件 必须 全部 为 真 才 满足       or   逻辑 或 （ 满足 其一 ）   A   or   B   or   C ： A 、 B 、 C   3 个 条件   只要 其中 一个 为 真 就 满足         下面 我们 还是 通过   2   个 实例 来 具体 学习 \n 查询 老师 10 在 2018 - 04 - 02 这天 开班 的 班级 信息     分析 ： 查询 老师 10 在 2018 - 04 - 02 这天 开班 的 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 老师 10   、 2018 - 04 - 02 开班   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   老师 10   、 2018 - 04 - 02 开班 ; \n   这 这里 我们 看到 有   老师 10   和   2018 - 04 - 02 开班   2   个值 ， 我们 发现   老师 10   是 班主 主任 班主任 信息 字 段 ， 而   2018 - 04 - 02 开班   是 开班 时间 字 段 ， 两个 不是 同一 一个 同一个 字 段 ， 这样 就 不能 使用 上面 的 范围 查询 了 ( between   和   in ) 。 既然 是   2   个 字 段 条件 ， 那 我们 就 来 分开 分析 ： \n   老师 10 ： 要求 班主 主任 班主任 是 老师 10   = & gt ;   c _ head _ teacher = ' 老师 10 '   2018 - 04 - 02 开班 ： 开班 时间 在 2018 - 04 - 02   = & gt ;   c _ start _ time = ' 2018 - 04 - 02 '     现在 两个 条件 都 分析 清楚 了 ， 那 这 两个 条件 的 组合 方式 是 什么 呢 ？ 根据 问题   * 老师 10 在   2018 - 04 - 02 这天 开班 * ：   必须 需要   老师 10   在   2018 - 04 - 02   这天 开班 的 班级 信息 ， 老师 和 开班 时间   2   个 条件 必须 满足 ， 所以 组合 方式 是   and ， 组合 得到 的 过滤 条件 就是 : c _ head _ teacher = ' 老师 10 '   and   c _ start _ time = ' 2018 - 04 - 02 '   。 现在 所有 的 分析 都 完成 了 ， 来看 我们 得到 的   SQL   语句 \n   所得   SQL   语句 \n select   *   from   class   where   c _ head _ teacher = ' 老师 10 '   and   c _ start _ time = ' 2018 - 04 - 02 ' ;     执行 得到 以下 结果 \n 查询 老师 5   或   2018 - 04 - 02 这天 开班 的 班级 信息     分析 ： 查询 老师 10 在 2018 - 04 - 02 这天 开班 的 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 老师 10   或   2018 - 04 - 02 开班   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   老师 10   或   2018 - 04 - 02 开班 ; \n   根据 之前 的 分析 这里 的 两个 条件 \n   c _ head _ teacher = ' 老师 5 '   c _ start _ time = ' 2018 - 04 - 02 '     但是 这里 这里 的 组合 方式 和 上面 会 不 一样 ， 有 发现 吗 ？ 这里 的 需求 是 :   老师 5   或   2018 - 04 - 02   ， 应该 使用 的 组合 方式 是   or 。 \n 所以 组合 得到 的 过滤 条件 就是 : c _ head _ teacher = ' 老师 5 '   or   c _ start _ time = ' 2018 - 04 - 02 ' \n   所得   SQL   语句 \n select   *   from   class   where   c _ head _ teacher = ' 老师 5 '   or   c _ start _ time = ' 2018 - 04 - 02 ' ;     执行 得到 以下 结果 \n     当 组合 多个 过滤 的 时候 如果 同时 有   and   和   or   的 组合 方式 ， 需要 注意 执行 的 优先 优先级 和 先后 顺序 先后顺序   sql 语句 中 not   and   or 的 执行 优先 优先级 从 高到 低 依次 为 :   not   & gt ;   and   & gt ;   or \n   执行 时 从左到右 依次 执行 \n   重要 建议   对于 不能 确定 的 时候 可以 使用 括号 小括号   ( )   改变 或 指明 优先 优先级 \n   对于 同时 又   not 、 and 、 or   的 组合 查询 始终 使用   ( )   指明 优先 优先级 \n       试试 \n 试着 把 上面 使用   in   的 查询 改成 组合 查询 ： 查询   会计 老师 1 和 酱油 老师 2 个 老师 负责 的 所有 班级 信息   查询 姓 王且 年龄 在 16 岁 以下 学生 和 在 西安 的 学生 ， 年龄 最小 的 排 在 前面     总结   这次 的 东西 有点 多 ， 特别 是 组合 查询 需要 多多 联系 和 实践 ， \n   where 子 句子 结构 ， 操作 操作符   数值 、 时间 ： 时间 的 表示 方法   字符 字符串 匹配 ：   like 、 百分 分号 百分号 （ % ） 通配符 、 下划 划线 下划线 （ _ ） 通配符   范围 值 检查 ： between   …   and   …   、 in   空值 查询 ： is   null 、 not   组合 查询 ： and 、 or 、 优先 优先级 和 求值 顺序  ", "title_s": "小白学   SQL   第四 四天 第四天 ： 数据 过滤 查询"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/3-query-data/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第三天：单表数据查询", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/3-query-data/", "content": "《小白学 SQL》第三天\n数据查询应该是我们平时用得最多的数据库操作，所以我们优先学习数据查询，今天我们就来看看基础的数据查询操作：单表数据查询，涉及到的知识点有：\n 检索单个列 检索多个列 数据去重 返回定量数据集 排序检索数据  \n先启动联系环境，具体启动方式和步骤请参看《小白学 SQL 第二天：数据表创建》。\nSELECT 语句结构 查询数据使用的到时 SELECT 语句，首先一起看一下今天用到 SELECT 语句结构：（这里不能理解没有关系，有个印象就行，稍后我们通过后面的例子理解）\nselect [distinct] 列1，列2，... from table_name [order by 列1 desc[, 列2 asc]] [limit offset, size];   列1、列2 列。在实际使用的时候，就是表示我们需要得到的信息，就是 E-R 图里面 椭圆 的部分\ntable_name 表名。在实际使用的时候，就是表示我们需要到哪里获得数据，就是 E-R 图里面 矩形 的部分\ndistinct 去重标识。如果多条数据完全相同的时候，只保留一条数据结果\norder by 排序语句。指定查询结果集按照特定列排序，可以同时多个列排序用,分割。排序可以正序(asc)或倒序(desc)\nlimit offset, size 数据限定。在实际使用的时候，就是表示我们需要获得多少数据，就是常说的分页查询。当没有 limit 限定时，表示取到所有数据\n 要学习详细完整的 SELECT 语句结构请查看 MySQL 官方文档。\n查询实例 我们的学习主要是以实际使用为主，所以所有的 SQL 语句之前都会给出命题和分析。\n还记得我们之前建立的数据表结构吧，这里我们会用到班级表，建议大家回顾一个班级的 E-R 图和创建表 SQL。\n查询所有班级的所有信息  分析：查询 所有 班级 的 所有信息\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：所有信息 （所有的*椭圆*） 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 班级所有信息 from 班级;\n 由于 班级所有信息 的所有椭圆是：标识 id、名称、班主任、开班时间、结束时间、状态、创建时间，这样我们可以得到下面的分析结果：\n select 标识 id,名称,班主任,开班时间,结束时间,状态,创建时间 from 班级;\n  通过上面的分析我们得到了和 E-R 图对应的类 SQL 语句，现在需要把这个 sql 翻译成数据库可以执行的正式 SQL。在从 E-R 图到数据表的过程中我们在名字上有这样的对应的关系：\n   E-R 图中的名称 数据库中的对应名称     班级 class   表示 id c_id   名称 c_name   班主任 c_head_teacher   开班时间 c_start_time   结束时间 c_end_time   状态 c_status   创建时间 c_created    按照这个对应表我们替换上面的类 SQL，得到下面的真实可执行 SQL：\nselect c_id,c_name,c_head_teacher,c_start_time,c_end_time,c_status,c_created from class;  copy 到 Navicat 的 SQL 执行其中会得到如下结果：\n执行下面这个 SQL 应该会得到和上面一样的结果\nselect * from calss;  这里的* 表示返回所有列信息，在实际使用中查询所有列或所有信息时，我们常常是用*代替。\n查询所有班级的名称  分析：查询 所有 班级 的 名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：名称 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称 from 班级;\n 这里名称已经是一个存在的特定列（属性）了，所以不再替换分析了。\n 对照上面的映射表，我们很容易得到真实可执行 SQL：\nselect c_name from class;  执行 SQL 语句会得到如下结果\n试试\n查询所有班级的名称和班主任信息  查询前5个班级的标识 id和名称  分析：查询 前5个 班级 的 标识 id和名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id 、名称 取多少数据：5 (前5个) 从哪里开始取：0（前5个）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称 from 班级 limit 0,5;\n  limit 0,5 说明: 我们可以建档的理解成：数据库在执行的时候，先执行没有 limit 限定的 SQL，得到所有的结果；然后在根据 limit 限定条件对数据进行 裁剪 返回。必须这里的limit 0,5: 从第 0 个(不包含 0)开始的 5 条数据（就是前 5 条数据）。大家可以想象 limit 3,4 的含义，并执行看看会有什么结果。\n   对照上面的映射表，转换得到真实可执行 SQL：\nselect c_id,c_name from class limit 0,5;  执行 SQL 语句会得到如下结果\nlimit 在实际使用的时候往往是用在分页数据查询，比如大家逛淘宝、京东都会不断翻页的查找数据。这个时候我们常常使用的表达是：按照每页4条数据大小 分页查询 第3页 班级数据的标识 id 和名称。我们来简单分析一下这个 SQL\n 分析：按照每页4条数据大小 分页查询 第3页 班级数据的标识 id 和名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id 、名称 取多少数据：4 (按照每页4条数据大小 ) 从哪里开始取：4 x (3-1) = 8（第3页，跳过前面2页数据，从第 2 页最后一条数据开始(不包含)往后取）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称 from 班级 limit 8,4;\n 所以得到 SQL\n select c_id, c_name from class limit 8,4;\n 大家执行上面的 SQL 看看结果。\n 试试\n按照每页3条数据大小分页查询第4页班级数据的标识 id 、名称和班主任  数据去重 请执这条 SQL\nselect c_name from class;  大家可以看到里面有2条 会计考试班 2 数据，在实际使用的时候我们常常会遇到去掉重复数据需求，这是往往大家描述的时候会出现 去掉重复、去重 等修饰词。这个时候我们需要使用 SQL 的 distinct 关键字，请大家只想下面的 SQL\nselect distinct c_name from class;   注意: distinct 去重试会比较所有 返回数据列 。请大家执行下面两个 SQL，然后看结果和之前的 2 个 SQL 进行对比，就比较好理解了\n select c_id, c_name from class;\nselect distinct c_id, c_name from class;\n  排序检索 排序我们通过 2 个实例讲解，分别讲解单列排序和多列排序\n查询所有班级信息，标识 id 大的在前面  分析：查询 所有 班级信息，标识 id 大的在前面\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：全部 排序字段：标识 id -&gt; 倒序（大的在前面） 取多少数据：不做限制  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select * from 班级\norder by 标识 id desc;\n 还记得吗！如果返回所有的列，我们可以使用 * 标识\n 现在结合E-R 图到表的映射，我们得到如下SQL\nselect * from class order by c_id desc;  执行这个结果我们会得到如下结果\n大家可以将 desc 改变成 asc 查看一下效果\n查询班级的标识 id、名称、开班时间，按照开班时间先后排列，开班时间相同的标识 id 倒序返回  分析：查询班级的标识 id、名称、开班时间，按照开班时间倒序，开班时间相同的标识 id 倒序返回\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id、名称、开班时间 排序字段1：开班时间 -&gt; 正序 排序字段2：标识 id -&gt; 倒序 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称, 开班时间 from 班级\norder by 开班时间 正序, 标识 id 倒序;\n  现在结合E-R 图到表的映射，我们得到如下SQL\nselect c_id,c_name,c_start_time from class order by c_start_time asc, c_id desc;  执行这个结果我们会得到如下结果\n 当使用多个列排序的时候，排序的处理顺序是从左到右，对于左边列值相同的行数据才会使用后面的列对其排序操作。\n 试试（综合实例）\n查询结束时间最早的 10 个班级的标识 id、名称、开班时间、结束时间；如果结束时间相同，就返回开发时间最好的；如果结束时间和开班时间都相同，就返回标识 id 最大的。查询结果应该如下：  按每页6条数据查询第 3 页班级信息，按照创建时间最大的排在前面，如果创建时间一样就按照 班主任 信息顺序排列。查询结果应该如下：  总结  SELECT 语句基本基本结构 查询需求或问题分析方法：综合 需求或问题描述、E-R 图 和 表结构 3方信息实施从问题到可执行 SQL 的分析设计 查询单列、多列、所有列数据 使用 limit 子句限定返回结果集中的数据的数量(结果集大小) 使用关键字 distinct 进行查询结果去重，注意取重时是比较所有查询列 使用 order by 子句对结果进行排序，可以是单列或多列，每列可以指定自己的排序方式：正序(asc)或倒序(desc)   大家会发现我们这里交替出现 属性、字段、列 如果没有特殊说明，这三个词语表达的含义是一样的，都不是标识数据表列或 ER 图属性。\n", "content_s": "《 小白学   SQL 》 第三 三天 第三天 \n 数据 查询 应该 是 我们 平时 用 得 最 多 的 数据 据库 数据库 操作 ， 所以 我们 优先 学习 数据 查询 ， 今天 我们 就 来 看看 基础 的 数据 查询 操作 ： 单表 数据 查询 ， 涉及 到 的 知识 知识点 有 ： \n   检索 单个 列   检索 多个 列   数据 去 重   返回 定量 数据 集   排序 检索 数据     \n 先 启动 联系 环境 ， 具体 启动 方式 和 步骤 请 参看 《 小白学   SQL   第二 二天 第二天 ： 数据 数据表 创建 》 。 \n SELECT   语句 结构   查询 数据 使用 的 到 时   SELECT   语句 ， 首先 一起 看 一下 今天 用到   SELECT   语句 结构 ： （ 这里 不能 理解 没有 关系 ， 有个 印象 就行 ， 稍后 我们 通过 后面 的 例子 理解 ） \n select   [ distinct ]   列 1 ， 列 2 ， ...   from   table _ name   [ order   by   列 1   desc [ ,   列 2   asc ] ]   [ limit   offset ,   size ] ;       列 1 、 列 2   列 。 在 实际 使用 的 时候 ， 就是 表示 我们 需要 得到 的 信息 ， 就是   E - R   图 里面   椭圆   的 部分 \n table _ name   表名 。 在 实际 使用 的 时候 ， 就是 表示 我们 需要 到 哪里 获得 数据 ， 就是   E - R   图 里面   矩形   的 部分 \n distinct   去 重 标识 。 如果 多条 数据 完全 相同 完全相同 的 时候 ， 只 保留 一条 数据 结果 \n order   by   排序 语句 。 指定 查询 结果 集 按照 特定 列 排序 ， 可以 同时 多个 列 排序 用 , 分割 。 排序 可以 正序 ( asc ) 或 倒序 ( desc ) \n limit   offset ,   size   数据 限定 。 在 实际 使用 的 时候 ， 就是 表示 我们 需要 获得 多少 数据 ， 就是 常说 的 分页 查询 。 当 没有   limit   限定 时 ， 表示 取 到 所有 数据 \n   要 学习 详细 完整 的   SELECT   语句 结构 请 查看   MySQL   官方 文档 。 \n 查询 实例   我们 的 学习 主要 是 以 实际 使用 为主 ， 所以 所有 的   SQL   语句 之前 都 会 给出 命题 和 分析 。 \n 还 记得 我们 之前 建立 的 数据 数据表 结构 吧 ， 这里 我们 会 用到 班级 表 ， 建议 大家 回顾 一个 班级 的   E - R   图 和 创建 表   SQL 。 \n 查询 所有 班级 的 所有 信息     分析 ： 查询   所有   班级   的   所有 信息 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 所有 信息   （ 所有 的 * 椭圆 * ）   取 多少 数据 ： 所有 班级   （ 没有 limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   班级 所有 信息   from   班级 ; \n   由于   班级 所有 信息   的 所有 椭圆 是 ： 标识   id 、 名称 、 班主 主任 班主任 、 开班 时间 、 结束 时间 、 状态 、 创建 时间 ， 这样 我们 可以 得到 下面 的 分析 结果 ： \n   select   标识   id , 名称 , 班主 主任 班主任 , 开班 时间 , 结束 时间 , 状态 , 创建 时间   from   班级 ; \n     通过 上面 的 分析 我们 得到 了 和   E - R   图 对应 的 类   SQL   语句 ， 现在 需要 把 这个   sql   翻译 译成 翻译成 数据 据库 数据库 可以 执行 的 正式   SQL 。 在 从   E - R   图到 数据 数据表 的 过程 中 我们 在 名字 上 有 这样 的 对应 的 关系 ： \n       E - R   图中 的 名称   数据 据库 数据库 中 的 对应 名称           班级   class       表示   id   c _ id       名称   c _ name       班主 主任 班主任   c _ head _ teacher       开班 时间   c _ start _ time       结束 时间   c _ end _ time       状态   c _ status       创建 时间   c _ created         按照 这个 对应 表 我们 替换 上面 的 类   SQL ， 得到 下面 的 真实 可 执行   SQL ： \n select   c _ id , c _ name , c _ head _ teacher , c _ start _ time , c _ end _ time , c _ status , c _ created   from   class ;     copy   到   Navicat   的   SQL   执行 其中 会 得到 如下 结果 ： \n 执行 下面 这个   SQL   应该 会 得到 和 上面 一样 的 结果 \n select   *   from   calss ;     这里 的 *   表示 返回 所有 列 信息 ， 在 实际 使用 中 查询 所有 列 或 所有 信息 时 ， 我们 常常 是 用 * 代替 。 \n 查询 所有 班级 的 名称     分析 ： 查询   所有   班级   的   名称 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 名称   取 多少 数据 ： 所有 班级   （ 没有 limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称   from   班级 ; \n   这里 名称 已经 是 一个 存在 的 特定 列 （ 属性 ） 了 ， 所以 不再 替换 分析 了 。 \n   对照 上面 的 映射 表 ， 我们 很 容易 得到 真实 可 执行   SQL ： \n select   c _ name   from   class ;     执行   SQL   语句 会 得到 如下 结果 \n 试试 \n 查询 所有 班级 的 名称 和 班主 主任 班主任 信息     查询 前 5 个 班级 的 标识   id 和 名称     分析 ： 查询   前 5 个   班级   的   标识   id 和 名称 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 标识   id   、 名称   取 多少 数据 ： 5   ( 前 5 个 )   从 哪里 开始 取 ： 0 （ 前 5 个 ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   标识   id ,   名称   from   班级   limit   0 , 5 ; \n     limit   0 , 5   说明 :   我们 可以 建档 的 理解 成 ： 数据 据库 数据库 在 执行 的 时候 ， 先 执行 没有   limit   限定 的   SQL ， 得到 所有 的 结果 ； 然后 在 根据   limit   限定 条件 对 数据 进行   裁剪   返回 。 必须 这里 的 limit   0 , 5 :   从 第   0   个 ( 不 包含   0 ) 开始 的   5   条 数据 （ 就是 前   5   条 数据 ） 。 大家 可以 想象   limit   3 , 4   的 含义 ， 并 执行 看看 会 有 什么 结果 。 \n       对照 上面 的 映射 表 ， 转换 得到 真实 可 执行   SQL ： \n select   c _ id , c _ name   from   class   limit   0 , 5 ;     执行   SQL   语句 会 得到 如下 结果 \n limit   在 实际 使用 的 时候 往往 是 用 在 分页 数据 查询 ， 比如 大家 逛 淘宝 、 京东 都 会 不断 翻页 的 查找 数据 。 这个 时候 我们 常常 使用 的 表达 是 ： 按照 每页 4 条 数据 大小   分页 查询   第 3 页   班级 数据 的 标识   id   和 名称 。 我们 来 简单 分析 一下 这个   SQL \n   分析 ： 按照 每页 4 条 数据 大小   分页 查询   第 3 页   班级 数据 的 标识   id   和 名称 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 标识   id   、 名称   取 多少 数据 ： 4   ( 按照 每页 4 条 数据 大小   )   从 哪里 开始 取 ： 4   x   ( 3 - 1 )   =   8 （ 第 3 页 ， 跳过 前面 2 页 数据 ， 从 第   2   页 最后 一条 数据 开始 ( 不 包含 ) 往后 取 ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   标识   id ,   名称   from   班级   limit   8 , 4 ; \n   所以 得到   SQL \n   select   c _ id ,   c _ name   from   class   limit   8 , 4 ; \n   大家 执行 上面 的   SQL   看看 结果 。 \n   试试 \n 按照 每页 3 条 数据 大小 分页 查询 第 4 页 班级 数据 的 标识   id   、 名称 和 班主 主任 班主任     数据 去 重   请 执 这条   SQL \n select   c _ name   from   class ;     大家 可以 看到 里面 有 2 条   会计 考试 班   2   数据 ， 在 实际 使用 的 时候 我们 常常 会 遇到 去掉 重复 数据 需求 ， 这是 往往 大家 描述 的 时候 会 出现   去掉 重复 、 去 重   等 修饰 饰词 修饰词 。 这个 时候 我们 需要 使用   SQL   的   distinct   关键 关键字 ， 请 大家 只想 下面 的   SQL \n select   distinct   c _ name   from   class ;       注意 :   distinct   去 重试 会 比较 所有   返回 数据 列   。 请 大家 执行 下面 两个   SQL ， 然后 看 结果 和 之前 的   2   个   SQL   进行 对比 ， 就 比较 好 理解 了 \n   select   c _ id ,   c _ name   from   class ; \n select   distinct   c _ id ,   c _ name   from   class ; \n     排序 检索   排序 我们 通过   2   个 实例 讲解 ， 分别 讲解 单列 排序 和 多列 排序 \n 查询 所有 班级 信息 ， 标识   id   大 的 在 前面     分析 ： 查询   所有   班级 信息 ， 标识   id   大 的 在 前面 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 全部   排序 字 段 ： 标识   id   - & gt ;   倒序 （ 大 的 在 前面 ）   取 多少 数据 ： 不 做 限制     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   *   from   班级 \n order   by   标识   id   desc ; \n   还 记得 吗 ！ 如果 返回 所有 的 列 ， 我们 可以 使用   *   标识 \n   现在 结合 E - R   图到 表 的 映射 ， 我们 得到 如下 SQL \n select   *   from   class   order   by   c _ id   desc ;     执行 这个 结果 我们 会 得到 如下 结果 \n 大家 可以 将   desc   改变 成   asc   查看 一下 效果 \n 查询 班级 的 标识   id 、 名称 、 开班 时间 ， 按照 开班 时间 先后 排列 ， 开班 时间 相同 的 标识   id   倒序 返回     分析 ： 查询 班级 的 标识   id 、 名称 、 开班 时间 ， 按照 开班 时间 倒序 ， 开班 时间 相同 的 标识   id   倒序 返回 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 标识   id 、 名称 、 开班 时间   排序 字段 1 ： 开班 时间   - & gt ;   正序   排序 字段 2 ： 标识   id   - & gt ;   倒序   取 多少 数据 ： 所有 班级   （ 没有 limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   标识   id ,   名称 ,   开班 时间   from   班级 \n order   by   开班 时间   正序 ,   标识   id   倒序 ; \n     现在 结合 E - R   图到 表 的 映射 ， 我们 得到 如下 SQL \n select   c _ id , c _ name , c _ start _ time   from   class   order   by   c _ start _ time   asc ,   c _ id   desc ;     执行 这个 结果 我们 会 得到 如下 结果 \n   当 使用 多个 列 排序 的 时候 ， 排序 的 处理 顺序 是 从左到右 ， 对于 左边 列值 相同 的 行 数据 才 会 使用 后面 的 列 对 其 排序 操作 。 \n   试试 （ 综合 实例 ） \n 查询 结束 时间 最早 的   10   个 班级 的 标识   id 、 名称 、 开班 时间 、 结束 时间 ； 如果 结束 时间 相同 ， 就 返回 开发 时间 最好 的 ； 如果 结束 时间 和 开班 时间 都 相同 ， 就 返回 标识   id   最大 的 。 查询 结果 应该 如下 ：     按 每页 6 条 数据 查询 第   3   页 班级 信息 ， 按照 创建 时间 最大 的 排 在 前面 ， 如果 创建 时间 一样 就 按照   班主 主任 班主任   信息 顺序 排列 顺序排列 。 查询 结果 应该 如下 ：     总结     SELECT   语句 基本 基本 结构   查询 需求 或 问题 分析 方法 分析方法 ： 综合   需求 或 问题 描述 、 E - R   图   和   表 结构   3 方 信息 实施 从 问题 到 可 执行   SQL   的 分析 设计   查询 单列 、 多列 、 所有 列 数据   使用   limit   子句 限定 返回 结果 集中 的 数据 的 数量 ( 结果 集 大小 )   使用 关键 关键字   distinct   进行 查询 结果 去 重 ， 注意 取重 时 是 比较 所有 查询 列   使用   order   by   子句 对 结果 进行 排序 ， 可以 是 单列 或 多列 ， 每列 可以 指定 自己 的 排序 方式 ： 正序 ( asc ) 或 倒序 ( desc )       大家 会 发现 我们 这里 交替 出现   属性 、 字 段 、 列   如果 没有 特殊 说明 ， 这 三个 词语 表达 的 含义 是 一样 的 ， 都 不是 标识 数据 数据表 列 或   ER   图 属性 。 \n", "title_s": "小白学   SQL   第三 三天 第三天 ： 单表 数据 查询"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/2-create-table/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第二天：数据表创建", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/2-create-table/", "content": "《小白学 SQL》第二天\n今天我们来学习数据表（table）的建立，涉及到的内容可能大家还不能完全理解，这里主要是为后面的查询语句做些基本准备和数据准备，后面还会专门学习 DDL（数据学习语言），所以没有关系这里大家只要能执行得到正确结果就行。\n今天涉及到的内容有：\n 表创建语句（create） 数据插入语句（insert ） MySQL 基本数据类型 E-R图（实体关系图）  \n启动学习环境 这里假设你的 docker 服务由于某些原因停止了（如：开关机），需要手动启动相关服务。如果你的 docker 服务和 sql-learn 已经正常启动，请跳过此章节（什么？你还没有 docker 和 sql-learn，请看这里）。这里所有的操作都可以参考第一天的内容，在这里。\n 启动 docker 服务   A、windows 通过桌面图标 或 系统菜单来启动\nB、Mac 通过 Launchpad 面板来图标启动\nC、Linux 通过命令行启动，不同版本会有所不同，可以查看第一天学的内容。\n  启动数据库服务器 (sql-learn 容器)   打开命令行工具输入一下命令，启动 sql-learn 容器\ndocker start sql-learn  输入一下命令查看启动状态\ndocker ps  结果如下：\n 启动数据库客户端（Navicat）  打开 Navicat 软件，通过左边的连接收藏栏，双击 sql-learn 连接，连接到数据库服务器（图中 ）。然后打开 sql-learn 数据库，就是双击 sql-learn 数据库（图中 ）。打开结果如下图：\n 通过以上 3 步，我们就打开了我们的学习环境，对于我们以后的每次学习进来的操作步骤都是一样的，所以这里大家一定要会，如果有什么问题可以给我留言。\n 创建数据表 create table (创建表)语句结构 以下是上面 SQL 语句的简单模板说明，具体完整的 CREATE TABLE 语句语法请参考 MySQL 官方文档。我们这里使用的足够了\nCREATE TABLE &lt;table_name&gt; ( &lt;column_name&gt; &lt;data_type&gt; [column_options] [COMMENT '&lt;comment&gt;'] [, ...] ) [table_options]   table_name: 表名称 column_name： 列名称 data_type： 列数据类型 column_options：列定义选项 comment ：注释 table_options：表定义选项 [, …]: 表示可以有多个列定义，使用 , 分割  设计并创建表 这里我们构想一个培训班的业务场景：\n 一个培训班有很多学生\n每个学生可以参加多个培训班\n 班级信息表 班级表创建 SQL ：\nCREATE TABLE `class` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，组件', `c_name` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班级名称', `c_head_teacher` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班主任名称', `c_start_time` date DEFAULT NULL COMMENT '开班日期', `c_end_time` date DEFAULT NULL COMMENT '结束日期', `c_status` int(11) NOT NULL COMMENT '班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】', `c_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`c_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表';  学生信息表 学生表创建 SQL：\nCREATE TABLE `student` ( `s_id` int(11) NOT NULL AUTO_INCREMENT COMMENT ' 学生 id', `s_name` varchar(64) NOT NULL COMMENT '学生名称', `s_sex` tinyint(4) DEFAULT NULL COMMENT '学生性别', `s_age` int(11) DEFAULT NULL COMMENT '学生年龄', `s_birthday` date NOT NULL COMMENT '学生生日', `s_addr` varchar(512) DEFAULT NULL COMMENT '学生地址', `s_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', `s_status` int(11) DEFAULT NULL COMMENT '状态（0：禁用，1：可用）', PRIMARY KEY (`s_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生信息表';  学生班级关联表 学生班级关联表(记录学生参加了那些培训班) SQL：\nCREATE TABLE `student_join_class` ( `c_id` int(11) NOT NULL COMMENT '班级 id', `s_id` int(11) NOT NULL COMMENT '学生表', `cs_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', PRIMARY KEY (`c_id`,`s_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生班级关联表';  对于以上 SQL 语句可以在 这里下载.\n数据类型说明 在我们的数据表创建语句里面，有个很重要的概念，也是数据库重要概念之一：数据类型（如：int(11)、timestamp、date等）。列的数据类型是描述了列可以接受保持的数据和如何存储数据。每种数据库管理系统的数据类型定义有略微不同，这里我们以 MySQL 数据类型为例说明，其他数据库的请查询相关文档。这里的数据类型大家不用全部记住，只要用到的时候查询参考文档就行。\n在 MySQL 中，有三种主要的类型：文本、数字、和日期/时间类型。\n文本类型（Text）    数据类型 描述     CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。   VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。   TINYTEXT 存放最大长度为 255 个字符的字符串。   TEXT 存放最大长度为 65,535 个字符的字符串。   BLOB 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。   MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。   MEDIUMBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。   LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。   LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。   ENUM(x,y,z,etc.) 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(&lsquo;X&rsquo;,&lsquo;Y&rsquo;,&lsquo;Z&rsquo;)   SET 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。    数字类型（Number）    数据类型 描述     TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。   SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。   MEDIUMINT(size) -8388608 到 8388607 普通。0 到 16777215 无符号*。在括号中规定最大位数。   INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。   BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。   FLOAT(size,d) 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。   DOUBLE(size,d) 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。   DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。     这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。\n 日期/时间类型（Date）    数据类型 描述     DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 &lsquo;1000-01-01&rsquo; 到 &lsquo;9999-12-31&rsquo;   DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 &lsquo;1000-01-01 00:00:00&rsquo; 到 &lsquo;9999-12-31 23:59:59&rsquo;   TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(&lsquo;1970-01-01 00:00:00&rsquo; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 &lsquo;1970-01-01 00:00:01&rsquo; UTC 到 &lsquo;2038-01-09 03:14:07&rsquo; UTC   TIME() 时间。格式：HH:MM:SS 注释：支持的范围是从 &lsquo;-838:59:59&rsquo; 到 &lsquo;838:59:59&rsquo;   YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。     即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。\n 录入数据 数据库插入数据使用 insert 语句，我们使用到的所有数据插入 sql 到 这里下载。下载下来过后将里面所有 SQL 语句拷贝到 Navicat 客户端的查询窗口里面，如下图：\n点击执行，会得到一下结果：\n这时打开左边 Tables 里面 class 表 会看到如下图数据已经进去了\n里面涉及到的 insert 有一下如下两种格式\n语法格式一\nINSERT INTO [数据库名.]表名称[(列1,列2,...)] VALUES (值1, 值2,....)  实例：\nINSERT INTO student(s_id, s_name, s_sex, s_age, s_birthday, s_addr, s_created, s_status) VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  语法格式二（批量插入）\nINSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) [,...]  实例：\nINSERT INTO `sql-learn`.`student_join_class`(`c_id`, `s_id`, `cs_created`) VALUES (1, 2, '2018-03-18 10:37:00'), (1, 3, '2018-02-18 09:41:41'), (1, 4, '2017-04-03 12:10:00'), (1, 5, '2018-01-28 14:30:00'), (1, 10, '2018-04-18 22:26:41');  详细语法格式参考 MySQL 官方文档。\nE-R 图（实体关系图） E-R 图是我个人感觉学习数据库必须掌握的一个技能，它是学习和分析数据库的一个有力工具，能让我们很快的对数据表之间关系形成一个全局观，对我们编写、分析 SQL 也是一个有力的工具。今天先简单讲解一下 E-R 图的基本内容，让大家可以看懂后面出现的 ER 图，后面会有专门的章节详解讲解 E-R 图。\nER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。\nER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。\nER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。\nER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。\nER图中关联关系有三种：\n 1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。 1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。 多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。  实例讲解：这个是上面创建的班级、学生 ER 图（注意：此图的部分画法不是标准的，不过不影响大家理解，也建议大家平时多多手画 ER 图，不是那么标准也没有关系，只要不影响理解就行） 班级、学生 是实体。一个学生一个参加多个(M)班级，一个班级可以包含多个(N)学生。 班级名称、学生性别 是属性。每个实体(班级或学生)都可以有多个属性。 参加 是关系，参见关系本身还包含有 参加时间 属性。学生加入班级的时候有 参加时间 。  有兴趣的可以自己手动画一下下面的 ER 图：有一个 班级 的实体，包含属性：课程名称、课程学分、授课老师。一个班级只授一门课程，但是班级的学生可以多次参加这么课程的考试。\n大家可能已经发现这里和我们实际建立的数据库表有所区别，这里表示的实体只有 2 个，但是我们时间建立的表却有 3 个。这里是我有意为之的，因为我发现很多初学者往往会有一个误区：误认为数据库的每个数据表都会对应 ER 图中的一个实体，其实这个是错误的。\n这是由于我们在实际建立数据库表的时候，会将 多对多（M:N） 关系拆分成 1对多（1:N） 关系，中间会多建立一个 关联表 （关联表也是物理数据表）。所以这里大家记住： ER图 转换成物理数据表的时候，可能会有所不同，但是他们的关系结构一定是一致的。我们有时还会把一个 实体 拆分成多个数据表进行存储，只要到家记住这个误区就行，具体为什么这个不属于这次内容范围，有兴趣的可以自行查找相关文档。\n总结  完成数据表创建和数据导入，知道 create 语句和 insert 语句基本结构和用户（可以看懂别人写的语句程度） 知道数据库基本类型，并且类型是描述列的 E-R 图基本知识：实体、属性、关系。可以看懂别人给出的 E-R 图，可以自己手绘简单 E-R 图，能够分析简单的数据表 E-R 图 ", "content_s": "《 小白学   SQL 》 第二 二天 第二天 \n 今天 我们 来 学习 数据 数据表 （ table ） 的 建立 ， 涉及 到 的 内容 可能 大家 还 不能 完全 理解 ， 这里 主要 是 为 后面 的 查询 语句 做些 基本 准备 和 数据 准备 ， 后面 还会 专门 学习   DDL （ 数据 学习 语言 ） ， 所以 没有 关系 这里 大家 只要 能 执行 得到 正确 结果 就行 。 \n 今天 涉及 到 的 内容 有 ： \n   表 创建 语句 （ create ）   数据 插入 语句 （ insert   ）   MySQL   基本 数据 类型 数据类型   E - R 图 （ 实体 关系 图 ）     \n 启动 学习 环境   这里 假设 你 的   docker   服务 由于 某些 原因 停止 了 （ 如 ： 开关 关机 开关机 ） ， 需要 手动 启动 相关 服务 。 如果 你 的   docker   服务 和   sql - learn   已经 正常 启动 ， 请 跳 过 此 章节 （ 什么 ？ 你 还 没有   docker   和   sql - learn ， 请 看 这里 ） 。 这里 所有 的 操作 都 可以 参考 第一 一天 第一天 的 内容 ， 在 这里 。 \n   启动   docker   服务       A 、 windows   通过 桌面 图标 桌面图 桌面图标   或   系统 菜单 来 启动 \n B 、 Mac   通过   Launchpad   面板 来 图标 启动 \n C 、 Linux   通过 命令 命令行 启动 ， 不同 版本 会 有所 不同 有所不同 ， 可以 查看 第一 一天 第一天 学 的 内容 。 \n     启动 数据 据库 数据库 服务 务器 服务器   ( sql - learn   容器 )       打开 命令 命令行 工具 输入 一下 命令 ， 启动   sql - learn   容器 \n docker   start   sql - learn     输入 一下 命令 查看 启动 状态 \n docker   ps     结果 如下 ： \n   启动 数据 据库 数据库 客户 客户端 （ Navicat ）     打开   Navicat   软件 ， 通过 左边 的 连接 收藏 栏 ， 双击   sql - learn   连接 ， 连接 到 数据 据库 数据库 服务 务器 服务器 （ 图中   ） 。 然后 打开   sql - learn   数据 据库 数据库 ， 就是 双击   sql - learn   数据 据库 数据库 （ 图中   ） 。 打开 结果 如下 图 ： \n   通过 以上   3   步 ， 我们 就 打开 了 我们 的 学习 环境 ， 对于 我们 以后 的 每次 学习 进来 的 操作 步骤 操作步骤 都 是 一样 的 ， 所以 这里 大家 一定 要会 ， 如果 有 什么 问题 可以 给 我 留言 。 \n   创建 数据 数据表   create   table   ( 创建 表 ) 语句 结构   以下 是 上面   SQL   语句 的 简单 模板 说明 ， 具体 完整 的   CREATE   TABLE   语句 语法 请 参考   MySQL   官方 文档 。 我们 这里 使用 的 足够 了 \n CREATE   TABLE   & lt ; table _ name & gt ;   (   & lt ; column _ name & gt ;   & lt ; data _ type & gt ;   [ column _ options ]   [ COMMENT   ' & lt ; comment & gt ; ' ]   [ ,   ... ]   )   [ table _ options ]       table _ name :   表 名称   column _ name ：   列 名称   data _ type ：   列 数据 类型 数据类型   column _ options ： 列 定义 选项   comment   ： 注释   table _ options ： 表 定义 选项   [ ,   … ] :   表示 可以 有 多个 列 定义 ， 使用   ,   分割     设计 并 创建 表   这里 我们 构想 一个 培训 培训班 的 业务 场景 ： \n   一个 培训 培训班 有 很多 学生 \n 每个 学生 可以 参加 多个 培训 培训班 \n   班级 信息 表   班级 表 创建   SQL   ： \n CREATE   TABLE   ` class `   (   ` c _ id `   int ( 11 )   NOT   NULL   AUTO _ INCREMENT   COMMENT   ' 班级   id ， 组件 ' ,   ` c _ name `   varchar ( 512 )   COLLATE   utf8mb4 _ unicode _ ci   NOT   NULL   COMMENT   ' 班级 名称 ' ,   ` c _ head _ teacher `   varchar ( 64 )   COLLATE   utf8mb4 _ unicode _ ci   NOT   NULL   COMMENT   ' 班主 主任 班主任 名称 ' ,   ` c _ start _ time `   date   DEFAULT   NULL   COMMENT   ' 开班 日期 ' ,   ` c _ end _ time `   date   DEFAULT   NULL   COMMENT   ' 结束 日期 ' ,   ` c _ status `   int ( 11 )   NOT   NULL   COMMENT   ' 班级 状态 【 0 ： 报名 未 开始 ， 1 ： 报名 中 ， 2 ： 报名 完成 ， 3 ： 已 开学 ， 4 ： 已 结业 】 ' ,   ` c _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 创建 时间 ' ,   PRIMARY   KEY   ( ` c _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COLLATE = utf8mb4 _ unicode _ ci   COMMENT = ' 班级 信息 表 ' ;     学生 信息 表   学生 表 创建   SQL ： \n CREATE   TABLE   ` student `   (   ` s _ id `   int ( 11 )   NOT   NULL   AUTO _ INCREMENT   COMMENT   '   学生   id ' ,   ` s _ name `   varchar ( 64 )   NOT   NULL   COMMENT   ' 学生 名称 ' ,   ` s _ sex `   tinyint ( 4 )   DEFAULT   NULL   COMMENT   ' 学生 性别 ' ,   ` s _ age `   int ( 11 )   DEFAULT   NULL   COMMENT   ' 学生 年龄 ' ,   ` s _ birthday `   date   NOT   NULL   COMMENT   ' 学生 生日 ' ,   ` s _ addr `   varchar ( 512 )   DEFAULT   NULL   COMMENT   ' 学生 地址 ' ,   ` s _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 加入 时间 ' ,   ` s _ status `   int ( 11 )   DEFAULT   NULL   COMMENT   ' 状态 （ 0 ： 禁用 ， 1 ： 可用 ） ' ,   PRIMARY   KEY   ( ` s _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COMMENT = ' 学生 信息 表 ' ;     学生 班级 关联 表   学生 班级 关联 表 ( 记录 学生 参加 了 那些 培训 培训班 )   SQL ： \n CREATE   TABLE   ` student _ join _ class `   (   ` c _ id `   int ( 11 )   NOT   NULL   COMMENT   ' 班级   id ' ,   ` s _ id `   int ( 11 )   NOT   NULL   COMMENT   ' 学生 表 ' ,   ` cs _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 加入 时间 ' ,   PRIMARY   KEY   ( ` c _ id ` , ` s _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COMMENT = ' 学生 班级 关联 表 ' ;     对于 以上   SQL   语句 可以 在   这里 下载 . \n 数据 类型 数据类型 说明   在 我们 的 数据 数据表 创建 语句 里面 ， 有个 很 重要 的 概念 ， 也 是 数据 据库 数据库 重要 概念 之一 ： 数据 类型 数据类型 （ 如 ： int ( 11 ) 、 timestamp 、 date 等 ） 。 列 的 数据 类型 数据类型 是 描述 了 列 可以 接受 保持 的 数据 和 如何 存储 数据 。 每种 数据 据库 数据库 管理 系统 管理系 管理系统 的 数据 类型 数据类型 定义 有 略微 不同 ， 这里 我们 以   MySQL   数据 类型 数据类型 为例 说明 ， 其他 数据 据库 数据库 的 请 查询 相关 文档 。 这里 的 数据 类型 数据类型 大家 不用 全部 记住 ， 只要 用到 的 时候 查询 参考 文档 就行 。 \n 在   MySQL   中 ， 有 三种 主要 的 类型 ： 文本 、 数字 、 和 日期 / 时间 类型 。 \n 文本 类型 （ Text ）         数据 类型 数据类型   描述           CHAR ( size )   保存 固定 长度 的 字符 字符串 （ 可 包含 字母 、 数字 以及 特殊 字符 特殊字符 ） 。 在 括号 中 指定 字符 字符串 的 长度 。 最 多   255   字符 个字符 。       VARCHAR ( size )   保存 可变 长度 的 字符 字符串 （ 可 包含 字母 、 数字 以及 特殊 字符 特殊字符 ） 。 在 括号 中 指定 字符 字符串 的 最大 长度 。 最 多   255   字符 个字符 。 注释 ： 如果 值 的 长度 大于   255 ， 则 被 转换 为   TEXT   类型 。       TINYTEXT   存放 最大 长度 为   255   字符 个字符 的 字符 字符串 。       TEXT   存放 最大 长度 为   65 , 535   字符 个字符 的 字符 字符串 。       BLOB   用于   BLOBs   ( Binary   Large   OBjects ) 。 存放 最 多   65 , 535   字节 的 数据 。       MEDIUMTEXT   存放 最大 长度 为   16 , 777 , 215   字符 个字符 的 字符 字符串 。       MEDIUMBLOB   用于   BLOBs   ( Binary   Large   OBjects ) 。 存放 最 多   16 , 777 , 215   字节 的 数据 。       LONGTEXT   存放 最大 长度 为   4 , 294 , 967 , 295   字符 个字符 的 字符 字符串 。       LONGBLOB   用于   BLOBs   ( Binary   Large   OBjects ) 。 存放 最 多   4 , 294 , 967 , 295   字节 的 数据 。       ENUM ( x , y , z , etc . )   允许 你 输入 可能 值 的 列表 。 可以 在   ENUM   列表 中 列出 最大   65535   个值 。 如果 列表 中 不 存在 插入 的 值 ， 则 插入 空值 。 注释 ： 这些 值 是 按照 你 输入 的 顺序 存储 顺序存储 的 。 可以 按照 此 格式 输入 可能 的 值 ： ENUM ( & lsquo ; X & rsquo ; , & lsquo ; Y & rsquo ; , & lsquo ; Z & rsquo ; )       SET   与   ENUM   类似 ， SET   最 多 只能 包含   64   个 列表 项 ， 不过   SET   可 存储 一个 以上 的 值 。         数字 类型 （ Number ）         数据 类型 数据类型   描述           TINYINT ( size )   - 128   到   127   常规 。 0   到   255   无 符号 * 。 在 括号 中 规定 最大 位数 。       SMALLINT ( size )   - 32768   到   32767   常规 。 0   到   65535   无 符号 * 。 在 括号 中 规定 最大 位数 。       MEDIUMINT ( size )   - 8388608   到   8388607   普通 。 0   到   16777215   无 符号 * 。 在 括号 中 规定 最大 位数 。       INT ( size )   - 2147483648   到   2147483647   常规 。 0   到   4294967295   无 符号 * 。 在 括号 中 规定 最大 位数 。       BIGINT ( size )   - 9223372036854775808   到   9223372036854775807   常规 。 0   到   18446744073709551615   无 符号 * 。 在 括号 中 规定 最大 位数 。       FLOAT ( size , d )   带有 浮动 小数 数点 小数点 的 小 数字 。 在 括号 中 规定 最大 位数 。 在   d   参数 中 规定 小数 数点 小数点 右侧 的 最大 位数 。       DOUBLE ( size , d )   带有 浮动 小数 数点 小数点 的 大 数字 。 在 括号 中 规定 最大 位数 。 在   d   参数 中 规定 小数 数点 小数点 右侧 的 最大 位数 。       DECIMAL ( size , d )   作为 字符 字符串 存储 的   DOUBLE   类型 ， 允许 固定 的 小数 数点 小数点 。           这些 整数 类型 拥有 额外 的 选项   UNSIGNED 。 通常 ， 整数 可以 是 负数 或 正数 。 如果 添加   UNSIGNED   属性 ， 那么 范围 将 从   0   开始 ， 而 不是 某个 负数 。 \n   日期 / 时间 类型 （ Date ）         数据 类型 数据类型   描述           DATE ( )   日期 。 格式 ： YYYY - MM - DD 注释 ： 支持 的 范围 是从   & lsquo ; 1000 - 01 - 01 & rsquo ;   到   & lsquo ; 9999 - 12 - 31 & rsquo ;       DATETIME ( )   * 日期 和 时间 的 组合 。 格式 ： YYYY - MM - DD   HH : MM : SS 注释 ： 支持 的 范围 是从   & lsquo ; 1000 - 01 - 01   00 : 00 : 00 & rsquo ;   到   & lsquo ; 9999 - 12 - 31   23 : 59 : 59 & rsquo ;       TIMESTAMP ( )   * 时间 戳 。 TIMESTAMP   值 使用   Unix   纪元 ( & lsquo ; 1970 - 01 - 01   00 : 00 : 00 & rsquo ;   UTC )   至今 的 描述 来 存储 。 格式 ： YYYY - MM - DD   HH : MM : SS 注释 ： 支持 的 范围 是从   & lsquo ; 1970 - 01 - 01   00 : 00 : 01 & rsquo ;   UTC   到   & lsquo ; 2038 - 01 - 09   03 : 14 : 07 & rsquo ;   UTC       TIME ( )   时间 。 格式 ： HH : MM : SS   注释 ： 支持 的 范围 是从   & lsquo ; - 838 : 59 : 59 & rsquo ;   到   & lsquo ; 838 : 59 : 59 & rsquo ;       YEAR ( )   2   位 或   4   位 格式 的 年 。 注释 ： 4   位 格式 所 允许 的 值 ： 1901   到   2155 。 2   位 格式 所 允许 的 值 ： 70   到   69 ， 表示 从   1970   到   2069 。           即便   DATETIME   和   TIMESTAMP   返回 相同 的 格式 ， 它们 的 工作 方式 很 不同 。 在   INSERT   或   UPDATE   查询 中 ， TIMESTAMP   自动 把 自身 设置 为 当前 的 日期 和 时间 。 TIMESTAMP   也 接受 不同 的 格式 ， 比如   YYYYMMDDHHMMSS 、 YYMMDDHHMMSS 、 YYYYMMDD   或   YYMMDD 。 \n   录入 数据   数据 据库 数据库 插入 数据 使用   insert   语句 ， 我们 使用 到 的 所有 数据 插入   sql   到   这里 下载 。 下载 下来 过后 将 里面 所有   SQL   语句 拷贝 拷贝到   Navicat   客户 客户端 的 查询 窗口 里面 ， 如下 图 ： \n 点击 执行 ， 会 得到 一下 结果 ： \n 这时 打开 左边   Tables   里面   class   表   会 看到 如下 图 数据 已经 进去 了 \n 里面 涉及 到 的   insert   有 一下 如下 两种 格式 \n 语法 格式 一 \n INSERT   INTO   [ 数据 据库 数据库 名 . ] 表 名称 [ ( 列 1 , 列 2 , ... ) ]   VALUES   ( 值 1 ,   值 2 , .... )     实例 ： \n INSERT   INTO   student ( s _ id ,   s _ name ,   s _ sex ,   s _ age ,   s _ birthday ,   s _ addr ,   s _ created ,   s _ status )   VALUES   ( 1 ,   ' 王   1 ' ,   1 ,   16 ,   ' 2007 - 04 - 18 ' ,   ' 重庆 ' ,   ' 2018 - 04 - 18   22 : 29 : 27 ' ,   1 ) ;     语法 格式 二 （ 批量 插入 ） \n INSERT   INTO   table _ name   ( 列 1 ,   列 2 , ... )   VALUES   ( 值 1 ,   值 2 , .... )   [ , ... ]     实例 ： \n INSERT   INTO   ` sql - learn ` . ` student _ join _ class ` ( ` c _ id ` ,   ` s _ id ` ,   ` cs _ created ` )   VALUES   ( 1 ,   2 ,   ' 2018 - 03 - 18   10 : 37 : 00 ' ) ,   ( 1 ,   3 ,   ' 2018 - 02 - 18   09 : 41 : 41 ' ) ,   ( 1 ,   4 ,   ' 2017 - 04 - 03   12 : 10 : 00 ' ) ,   ( 1 ,   5 ,   ' 2018 - 01 - 28   14 : 30 : 00 ' ) ,   ( 1 ,   10 ,   ' 2018 - 04 - 18   22 : 26 : 41 ' ) ;     详细 语法 格式 参考   MySQL   官方 文档 。 \n E - R   图 （ 实体 关系 图 ）   E - R   图是 我 个人 感觉 个人感觉 学习 数据 据库 数据库 必须 掌握 的 一个 技能 ， 它 是 学习 和 分析 数据 据库 数据库 的 一个 有力 工具 ， 能 让 我们 很快 的 对 数据 数据表 之间 关系 形成 一个 全局 观 ， 对 我们 编写 、 分析   SQL   也 是 一个 有力 的 工具 。 今天 先 简单 讲解 一下   E - R   图 的 基本 内容 ， 让 大家 可以 看 懂 后面 出现 的   ER   图 ， 后面 会 有 专门 的 章节 详解 讲解   E - R   图 。 \n ER 图 分为 实体 、 属性 、 关系 三个 核心 部分 。 实体 是 长方 方形 长方形 体现 ， 而 属性 则 是 椭圆 圆形 椭圆形 ， 关系 为 菱形 。 \n ER 图 的 实体 （ entity ） 即 数据 模型 数据模型 中 的 数据 对象 ， 例如 人 、 学生 、 音乐 都 可以 作为 一个 数据 对象 ， 用 长方 长方体 来 表示 ， 每个 实体 都 有 自己 的 实体 成员 （ entity   member ） 或者 或者说 实体 对象 （ entity   instance ） ， 例如 学生 实体 里 包括 张三 、 李四 等 ， 实体 成员 （ entity   member ） / 实体 实例 （ entity   instance ）   不 需要 出现 在 ER 图中 。 \n ER 图 的 属性 （ attribute ） 即 数据 对象 所 具有 的 属性 ， 例如 学生 具有 姓名 、 学 号 、 年级 等 属性 ， 用 椭圆 圆形 椭圆形 表示 ， 属性 分为 唯一 属性 （   unique   attribute ） 和 非 唯一 属性 ， 唯一 属性 指 的 是 唯一 可用 来 标识 该 实体 实例 或者 成员 的 属性 ， 用 下划 划线 下划线 表示 ， 一般 来讲 一般来讲 实体 都 至少 有 一个 唯一 属性 。 \n ER 图 的 关系 （ relationship ） 用来 表现 数据 对象 与 数据 对象 之间 的 联系 ， 例如 学生 的 实体 和 成绩 成绩表 的 实体 之间 有 一定 的 联系 ， 每个 学生 都 有 自己 的 成绩 成绩表 ， 这 就是 一种 关系 ， 关系 用 菱形 来 表示 。 \n ER 图中 关联 关系 有 三种 ： \n   1 对 1 （ 1 : 1 ）   ： 1 对 1 关系 是 指 对于 实体 集 A 与 实体 集 B ， A 中 的 每 一个 实体 至多 与 B 中 一个 实体 有 关系 ； 反之 ， 在 实体 集 B 中 的 每个 实体 至多 与 实体 集 A 中 一个 实体 有 关系 。   1 对 多 （ 1 : N ）   ： 1 对 多 关系 是 指 实体 集 A 与 实体 集 B 中 至少 有 N ( N & gt ; 0 ) 个 实体 有 关系 ； 并且 实体 集 B 中 每 一个 实体 至多 与 实体 集 A 中 一个 实体 有 关系 。   多 对 多 （ M : N ）   ： 多 对 多 关系 是 指 实体 集 A 中 的 每 一个 实体 与 实体 集 B 中 至少 有 M ( M & gt ; 0 ) 个 实体 有 关系 ， 并且 实体 集 B 中 的 每 一个 实体 与 实体 集 A 中 的 至少 N （ N & gt ; 0 ） 个 实体 有 关系 。     实例 讲解 ： 这个 是 上面 创建 的 班级 、 学生   ER   图 （ 注意 ： 此图 的 部分 画法 不是 标准 的 ， 不过 不 影响 大家 理解 ， 也 建议 大家 平时 多多 手画   ER   图 ， 不是 那么 标准 也 没有 关系 ， 只要 不 影响 理解 就行 ）   班级 、 学生   是 实体 。 一个 学生 一个 参加 多个 ( M ) 班级 ， 一个 班级 可以 包含 多个 ( N ) 学生 。   班级 名称 、 学生 性别   是 属性 。 每个 实体 ( 班级 或 学生 ) 都 可以 有 多个 属性 。   参加   是 关系 ， 参见 关系 本身 还 包含 有   参加 时间   属性 。 学生 加入 班级 的 时候 有   参加 时间   。     有 兴趣 的 可以 自己 手 动画 一下 下面 的   ER   图 ： 有 一个   班级   的 实体 ， 包含 属性 ： 课程 名称 课程名称 、 课程 学分 、 授课 老师 。 一个 班级 只授 一门 课程 ， 但是 班级 的 学生 可以 多次 参加 这么 课程 的 考试 。 \n 大家 可能 已经 发现 这里 和 我们 实际 建立 的 数据 据库 数据库 表 有所 区别 有所区别 ， 这里 表示 的 实体 只有   2   个 ， 但是 我们 时间 建立 的 表 却 有   3   个 。 这里 是 我 有意 为 之 的 ， 因为 我 发现 很多 初学 学者 初学者 往往 会 有 一个 误区 ： 误认 认为 误认为 数据 据库 数据库 的 每个 数据 数据表 都 会 对应   ER   图中 的 一个 实体 ， 其实 这个 是 错误 的 。 \n 这是 由于 我们 在 实际 建立 数据 据库 数据库 表 的 时候 ， 会 将   多 对 多 （ M : N ）   关系 拆 分成   1 对 多 （ 1 : N ）   关系 ， 中间 会多 建立 一个   关联 表   （ 关联 表 也 是 物理 数据 数据表 ） 。 所以 这里 大家 记住 ：   ER 图   转换 换成 转换成 物理 数据 数据表 的 时候 ， 可能 会 有所 不同 有所不同 ， 但是 他们 的 关系 结构 一定 是 一致 的 。 我们 有时 还会 把 一个   实体   拆 分成 多个 数据 数据表 进行 存储 ， 只要 到家 记住 这个 误区 就行 ， 具体 什么 为什么 这个 不 属于 这次 内容 范围 ， 有 兴趣 的 可以 自行 查找 相关 文档 。 \n 总结     完成 数据 数据表 创建 和 数据 导入 ， 知道   create   语句 和   insert   语句 基本 结构 和 用户 （ 可以 看 懂 别人 写 的 语句 程度 ）   知道 数据 据库 数据库 基本 类型 ， 并且 类型 是 描述 列 的   E - R   图 基本 知识 基本知识 ： 实体 、 属性 、 关系 。 可以 看 懂 别人 给出 的   E - R   图 ， 可以 自己 手绘 简单   E - R   图 ， 能够 分析 简单 的 数据 数据表   E - R   图  ", "title_s": "小白学   SQL   第二 二天 第二天 ： 数据 数据表 创建"}, {"description": "", "objectID": "https://blog.threeq.me/post/team-communication/agile-practice-record/", "tags": ["Scrum", "看板", "敏捷开发", "团队管理"], "title": "Scrum + 看板 开发实践：记录", "uri": "https://blog.threeq.me/post/team-communication/agile-practice-record/", "content": "目前我们团队正实践 Scrum 框架 和 看板管理，这边文章正是对我们自己的实践的记录。这里的记录并不是按照时间顺序进行的，而是按照我自己的针对实践目标的先后进行的。目前我们团队还没有完全实现以上所有目标，对 Scrum 框架 理解和使用也还在初级阶段，所以有很多不足的地方，并且还有很多地方还在聊胜于无的状态，欢迎大家指正。\n我们现在正在进行的实践有：\n 统一团队对“完成”的定义 看板管理流程 每日晨会 迭代回顾会议 迭代计划会议 code review  我们团队刚开始的时候管理、开发混乱完全没有章法，大家各种打架、各种撕逼、各种甩锅。没有哪一次迭代不通宵，没有哪一次迭代不延期，没有哪一次迭代质量过关，没有哪一次上线不出问题，这种状态持续了很长一段时间。我感觉不行了，再这样下去还能做个啥产品，开始寻找各种解决方案并且不断反思团队遇到问题的本质，后来学习了敏捷，接触到 Scrum 和 看板，里面的方法论和实践操作不正是我们团队需要的吗？于是坚决决定团队开始敏捷实践，当然正所谓：软件开发没有银弹，实践证明 Scrum 和 看板并不能解决我们团队所有问题，但是确实可以让团队慢慢变好。\n\n团队目标一致：完成定义 虽然决定引入 Scrum 和 看板，但是从哪里开始呢？这么多团队问题，应该从哪个或哪几个问题开始引入解决呢？还是团队全面调整引入？这些问题是任何团队在开始引入的时候都会遇到的，但是我相信每个团队最后的答案都是不一样的。Scrum 框架建议团队全面调整和引入，这样团队提升效果最明显，但是这个需要团队和公司整体努力才能达到。通过沟通和分析我们当时的团队内外情况，全面引入条件还不成熟，所以只能逐步引入。通过分析我们团队自身情况，决定优先引入能最大化解决团队 撕逼和甩锅 情况的实践。这里我们选着了：\n 统一团队对“完成”的定义  在某次迭代完成过后，选在了一个下午时间，我们整个团队发起了《针对“完成”定义的讨论会议》，会议分成 5 个阶段：\n 说明会议原则   谦虚、尊重、信任原则\n会议期间尽量不被“打扰”，手机或者其他任何事情\n  收集大家对“完成”的想法：   使用便签箱收集大家的想法，每个参会成员使用便签写下自己的想法，然后读出来，最后将便签投入便签箱中，可以是新想法，也可以是对别人的补充。便签箱不断在成员之间循环传递，就会有越来越多的想法，直到大家所有想法都收集完了，一般在 3 轮后基本就完了。\n  整理大家想法   将搜集到的想法全部贴在版本上，记住是全部并且最好能大家一起做，同时将重复的便签贴在一起。然后移动便签，将意思相近的便签挨在一起，这样就形成了初略的分类。\n  讨论“完成”   对白板上的便签和初步形成的分类进行讨论和提炼，在过程中不断调整分类和精炼完成解释\n  总结得到最新“完成”定义   总结大家对分类和完成的讨论，结果形成 SMART 目标\n 在整个过程中需要保持谦虚、尊重、信任的原则，这样才能保持平等公平，让团队在微小的声音都被听到。最总我们得出了我们对于迭代完成的定义:\n团队信息透明：看板 为了做到团队信息透明，我们引入了看板方法，目标是尽量做到迭代过程中：所有人员对团队的任何信息“信息触手可及”。第一次引入看板我们没有进行全员参与，是由我直接给出了一个初始看板设计。\n 这里如果大家团队有时间建议还是全员参与看板设计，这样大家对流程理解会更清晰。如果做不到全员参与设计关系也不大，因为看板本身是跟着团队不断进化的，在你团队感觉他不合适的时候，再来改进也是可以的。比如我们团队现在看板是这样的（这个是在后来团队所有成员一起改进了 2 次后的）\n 及时有效沟通：每日晨会 每日例会我们称为晨会，因为我们是规定在早上进行。我们会选择一位主持人来主持晨会，晨会上每个人主要回答三个问题：\n 昨天做了什么？ 今天计划做什么？ 有没有遇到问题？  主持人也可以在这个3个主要问题之上加入自己的内容，主持人要引导大家回答出这3个问题。通过这样的方式让团队成员对团队做出承诺，并让团队监督你的承诺是否有被实现和你是否做出了过度承诺，同时也让团队人员思考团队其他人员是否需要帮助，我可以帮助哪些人。\n现在我们晨会形式也有所改变，主持人逐渐改变成一个迭代统一一个主持人，而不是原来的一天换一个主持人。并且主持的形式也可以有第二种选择\n 主持人对看板上每一个 未完成 的任务进行询问一下问题\n 任务现在什么状态？ 任务有无人在跟踪？ 有无阻力导致任务无法进行？ 完成任务还需要什么协助？   在每次晨会的时候，如果团队有发现需要改进的点（比如时间方法、沟通模式等），可以在会后来一个小的及时讨论，针对好的方案可以记录下来，留到回顾会议的时候详细讨论。\n迭代质量提升：迭代计划会议 迭代计划会议我们现在是由迭代学习会议和迭代评估会议 2 个会议组成。\n迭代学习会议 迭代backlog在我们开始一个迭代之前会由产品人员提前提取到迭代规划中（我们现在展现在TAPD中），并且和开发负责人确认好这个个迭代的开发范围。这个工作基本上是在上个迭代中后期完成的，产品人员在做的过程中需要和开发人员进行相关沟通，特别是开发负责人，所以这个时期的开发人员积极支持也是很关键的。在这个backlog里面，每个需求必须写明业务逻辑和验收标准，如果有必要还需要补充使用场景说明和功能的UI设计。\n迭代评估会议 迭代计划主要是围绕迭代backlog进行，我们对迭代计划会议做了不少调整。我们首先在迭代计划中进行业务学习会议，在这个过程中我们要求每个开发人员和测试人员对本次迭代范围内的业务进行宣讲，其他没有参与宣讲的人员需要对宣讲人员的疑问进行解答，特别是产品人员。在这个过程中让我们每个开发人员对业务目标达成共识，识别迭代中的重点和难点。同时这个过程可以对迭代范围提出质疑，如果有质疑，团队则必须在会议中决策出迭代范围。然后我们会在业务学习会议过后，立即召开难点设计会议，这个会议目前主要是开发人员参与，在会议上开发人员要针对迭代中的难点和重点进行详细设计，这个过程中如果有必要会协调产品人员一起参与（如范围调整，实现复杂度导致业务功能的变化等），得出详细设计中需要的必要结果（如：ER图，流程图，时序图等），如果有需要会后形成详细的设计说明书，一般情况下将会议中形成的白板图形成文档即可。最后所有人员对业务目标和重难点的设计达成一致后，开发人员进行估算会议，我们现在才用的形式是卡牌游戏对任务进行评估，目前通过卡牌游戏可以在一定程度上规避个人经验主义和单点故障问题。进过迭代计划会议团队对整个迭代的业务范围和迭代时间做出承诺，当然这个迭代计划会议持续的时间会随着迭代范围和难度有很大变化，目前我们团队最长的一次时间是5个工作日。\n迭代质量提升：code review 每日分享会我们之前叫做每日code review 或 集体代码解释（只有开发人员参与），但是由于近期产品人员和测试人员的参与，发现之前的名字已经不合适了，就改成了每日分享会。每日分享会紧跟在每日例会后进行，也像每日例会一样选定一个分享者（之前是2个）来完成一个30分钟的分享，并且对于开发人员做了特定规定只能做code review，目前规定这个主持人和每日例会主持人为同一人。并且在每日分享会过后，观察者（目前是项目负责人）有义务并且也是必须和当天主持人一起对当天他自己的表现做一个简单的评估和回顾，并做相关记录。这里不只是包括人员的技术，还包括人员的沟通、演讲等能力。\n目前这个会议也在调整，之前一个分享者很多时候不能达到 30 分钟，并且现在团队的情况让产品、开发和测试一起做分享已经不再合适。\n高效学习团队：迭代回顾会议 迭代会议必须准守 2 个基本原则：\n 无论我们发现了什么，考虑到当时的已知情况、个人的技术水平和能力、可用的资源，以及现实情况，我们理解并坚信：每个人对自己的工作都已全力以赴。 我们的目标是发现改进的机会，而不是去责备某个人  迭代回顾会议在整个迭代上线完成过后进行，迭代会议也和我们的晨会一样，选定一位主持人。主持人负责引导团队回顾在本次迭代中：\n 团队实践回顾（这里有很多方法，如：时间轴法，团队情绪表等） 团队做得好的地方； 有哪些地方我们可以做得更好； 我们可以做哪些实践来让我们改善。  在操作过程中我们会让团队所有人员对我们可以做得更好的事情，进行投票选举出团队认为最急迫、最重要的前面3个出来，我们进行讨论得出我们需要的实践。在得出实践的过程中，最重要的是团队可以看到实际可执行的实践，也就是这个实践最好有明确的结果和判断好坏的标准，能形成 SMART 目标最好。主持人在这个会议中，也可以加入自己的元素，但是需要遵守2个原则：\n 不能偏离主题内容； 必须是针对整个团队的内容。  以下是我们一次在迭代会议中进行的团队情绪表实践：\n在这里回顾会议中 Master 角色的人(观察者)员需要记录会议全过程，并且需要把会议记录同步到所有人，一下使我们使用的记录末班\n   记录项 内容     记录 记录这次会议的内容   历史问题跟踪 前一次会议总结内容，需要提醒住持人让团队评估上次的目标是否完成   总结 记录这次会议得出的结论 和 目标   观察 观察这次迭代回顾会议本省的情况，并在会后主持人和团队交流可以改进的地方    迭代回顾会议可以让我们及时发现团队需要改进的地方，也可以让我们发现团队里面需要继续维持的地方，让我们不断调整团队步伐和实践，让团队里面正确的、好的事情不断发生。\n未来 我们目前正在引入的实践\n TDD（测试驱动开发） 迭代演示 CI/CD 迭代跟踪者  同时也在不断调整我们现在的部分实践，如完成的定义、团队卓越（高效绩）的定义和目标。这就意味着团队会是一个持续变化和持续学习的过程，同时团队所在的外界因素也在不断的变化，这就需要团队的每个人都需要做到“学习学习再学习，实践实践再实践”，让团队不断的成长来适应各种变化。\n总结 管理方法论改变和进化的驱动力是项目利益的最大化，但是改变的本质是项目的沟通模式。沟通模式的改变可以是信息的展现形式、信息的载体、信息的传递方式、信息流转和反馈方式。这些改变都会对我们项目管理中其他方面产生直接影响，并且也直接影响到我们的管理模式。在项目进行过程中既需要一对一的精细沟通，也需要针对项目成功目标的宏观沟通。\n我们上面谈到了项目沟通中模式的改变，其实由于沟通模式的改变，会引发项目中其他管理方面的改变。\n在这个过程中团队负责人要保证团队是在正确的道路上，并且要让正确的事情不断的发生。及时识别团队的所处阶段，识别为团队引入变化的时机，及时引入变化；不断通过实践结果总结团队的失败模式和成功模式，促进成功模式不断出现，让团队在不断出现的失败模式中恢复。同时和团队一起不断提高自己，做好对自我掌控，定义好自己的成功，接受团队比自己更好的想法。\n推荐给大家几本团队和管理方法的书：\n 《Scrum 敏捷软件开发》 《Scrum 实战：故事、模型与成功秘诀》 《Scrum 精髓：敏捷转型指南》 《敏捷软件开发实践：估算与计划》 《敏捷教练：如何打造优秀的敏捷团队》 《如何构建敏捷项目管理团队》 《看板方法》 《看板实战》 《架构即未来》 ", "content_s": "目前 我们 团队 正 实践   Scrum   框架   和   看 板 管理 ， 这边 文章 正是 对 我们 自己 的 实践 的 记录 。 这里 的 记录 并 不是 按照 时间 顺序 进行 的 ， 而是 按照 我 自己 的 针对 实践 目标 的 先后 进行 的 。 目前 我们 团队 还 没有 完全 实现 以上 所有 目标 ， 对   Scrum   框架   理解 和 使用 也 还 在 初级 阶段 初级阶段 ， 所以 有 很多 不足 的 地方 ， 并且 还有 很多 地方 还 在 胜于 聊胜于无 的 状态 ， 欢迎 大家 指正 。 \n 我们 现在 正在 进行 的 实践 有 ： \n   统一 团队 对 “ 完成 ” 的 定义   看 板 管理 流程   每日 晨会   迭代 回顾 会议   迭代 计划 会议   code   review     我们 团队 刚 开始 的 时候 管理 、 开发 混乱 完全 没有 章法 ， 大家 各种 打架 、 各种 撕 逼 、 各种 甩锅 。 没有 哪 一次 迭代 不 通宵 ， 没有 哪 一次 迭代 不 延期 ， 没有 哪 一次 迭代 质量 过关 ， 没有 哪 一次 上线 不 出 问题 ， 这种 状态 持续 了 很长 一段 时间 段时间 一段时间 。 我 感觉 不行 了 ， 再 这样 下去 还 能 做 个 啥 产品 ， 开始 寻找 各种 解决 方案 解决方案 并且 不断 反思 团队 遇到 问题 的 本质 ， 后来 学习 了 敏捷 ， 接触 到   Scrum   和   看 板 ， 里面 的 方法 方法论 和 实践 操作 不 正是 我们 团队 需要 的 吗 ？ 于是 坚决 决定 团队 开始 敏捷 实践 ， 当然 正 所谓 ： 软件 开发 软件开发 没有 银弹 ， 实践 证明 实践证明   Scrum   和   看板 并 不能 解决 我们 团队 所有 问题 ， 但是 确实 可以 让 团队 慢慢 变 好 。 \n \n 团队 目标 一致 ： 完成 定义   虽然 决定 引入   Scrum   和   看 板 ， 但是 从 哪里 开始 呢 ？ 这么 多 团队 问题 ， 应该 从 哪个 或 哪几 几个 哪几个 问题 开始 引入 解决 呢 ？ 还是 团队 全面 调整 引入 ？ 这些 问题 是 任何 团队 在 开始 引入 的 时候 都 会 遇到 的 ， 但是 我 相信 每个 团队 最后 的 答案 都 是 不 一样 的 。 Scrum   框架 建议 团队 全面 调整 和 引入 ， 这样 团队 提升 效果 最 明显 ， 但是 这个 需要 团队 和 公司 整体 努力 才能 达到 。 通过 沟通 和 分析 我们 当时 的 团队 内外 情况 ， 全面 引入 条件 还 不 成熟 ， 所以 只能 逐步 引入 。 通过 分析 我们 团队 自身 情况 ， 决定 优先 引入 能 最大 大化 最大化 解决 团队   撕 逼 和 甩 锅   情况 的 实践 。 这里 我们 选着 了 ： \n   统一 团队 对 “ 完成 ” 的 定义     在 某次 迭代 完成 过后 ， 选在 了 一个 下午 时间 ， 我们 整个 团队 发起 了 《 针对 “ 完成 ” 定义 的 讨论 会议 》 ， 会议 分成   5   个 阶段 ： \n   说明 会议 原则       谦虚 、 尊重 、 信任 原则 \n 会议 期间 尽量 不 被 “ 打扰 ” ， 手机 或者 其他 任何 事情 \n     收集 大家 对 “ 完成 ” 的 想法 ：       使用 便签 箱 收集 大家 的 想法 ， 每个 参会 成员 使用 便签 写下 自己 的 想法 ， 然后 读出 出来 读出来 ， 最后 将 便签 投入 便签 箱中 ， 可以 是 新 想法 ， 也 可以 是 对 别人 的 补充 。 便签 箱 不断 在 成员 之间 循环 传递 ， 就 会 有 越来 越来越 多 的 想法 ， 直到 大家 所有 想法 都 收集 完 了 ， 一般 在   3   轮后 基本 就 完 了 。 \n     整理 大家 想法       将 搜集 到 的 想法 全部 贴 在 版本 上 ， 记住 是 全部 并且 最好 能 大家 一起 做 ， 同时 将 重复 的 便签 贴 在 一起 。 然后 移动 便签 ， 将 意思 相近 的 便签 挨 在 一起 ， 这样 就 形成 了 初略 的 分类 。 \n     讨论 “ 完成 ”       对 白板 上 的 便签 和 初步 形成 的 分类 进行 讨论 和 提炼 ， 在 过程 中 不断 调整 分类 和 精炼 完成 解释 \n     总结 得到 最新 “ 完成 ” 定义       总结 大家 对 分类 和 完成 的 讨论 ， 结果 形成   SMART   目标 \n   在 整个 过程 中 需要 保持 谦虚 、 尊重 、 信任 的 原则 ， 这样 才能 保持 平等 公平 ， 让 团队 在 微小 的 声音 都 被 听到 。 最 总 我们 得出 了 我们 对于 迭代 完成 的 定义 : \n 团队 信息 透明 ： 看 板   为了 做到 团队 信息 透明 ， 我们 引入 了 看板 方法 ， 目标 是 尽量 做到 迭代 过程 中 ： 所有 人员 对 团队 的 任何 信息 “ 信息 触手 触手可及 ” 。 第一 一次 第一次 引入 看 板 我们 没有 进行 全员 参与 ， 是 由 我 直接 给出 了 一个 初始 看 板 设计 。 \n   这里 如果 大家 团队 有 时间 建议 还是 全员 参与 看 板 设计 ， 这样 大家 对 流程 理解 会 更 清晰 。 如果 做 不到 全员 参与 设计 关系 也 不大 ， 因为 看 板 本身 是 跟着 团队 不断 进化 的 ， 在 你 团队 感觉 他 不 合适 的 时候 ， 再 来 改进 也 是 可以 的 。 比如 我们 团队 现在 看板 是 这样 的 （ 这个 是 在 后来 团队 所有 成员 一起 改进 了   2   次后 的 ） \n   及时 有效 沟通 ： 每日 晨会   每日 例会 我们 称为 晨会 ， 因为 我们 是 规定 在 早上 进行 。 我们 会 选择 一位 主持 主持人 来 主持 晨会 ， 晨会 上 每个 人 主要 回答 三个 问题 ： \n   昨天 做 了 什么 ？   今天 计划 做 什么 ？   没有 有没有 遇到 问题 ？     主持 主持人 也 可以 在 这个 3 个 主要 问题 之上 加入 自己 的 内容 ， 主持 主持人 要 引导 大家 回答 出 这 3 个 问题 。 通过 这样 的 方式 让 团队 成员 对 团队 做出 承诺 ， 并 让 团队 监督 你 的 承诺 是否 有 被 实现 和 你 是否 做出 了 过度 承诺 ， 同时 也 让 团队 人员 思考 团队 其他 人员 是否 需要 帮助 ， 我 可以 帮助 哪些 人 。 \n 现在 我们 晨会 形式 也 有所 改变 ， 主持 主持人 逐渐 改变 成 一个 迭代 统一 一个 主持 主持人 ， 而 不是 原来 的 一天 换 一个 主持 主持人 。 并且 主持 的 形式 也 可以 有 第二 二种 第二种 选择 \n   主持 主持人 对 看板 上 每 一个   未 完成   的 任务 进行 询问 一下 问题 \n   任务 现在 什么 状态 ？   任务 有 无人 在 跟踪 ？   有无 阻力 导致 任务 无法 进行 ？   完成 任务 还 需要 什么 协助 ？       在 每次 晨会 的 时候 ， 如果 团队 有 发现 需要 改进 的 点 （ 比如 时间 方法 、 沟通 模式 沟通模式 等 ） ， 可以 在 会 后来 一个 小 的 及时 讨论 ， 针对 好 的 方案 可以 记录 录下 下来 录下来 记录下来 ， 留 到 回顾 会议 的 时候 详细 讨论 。 \n 迭代 质量 提升 ： 迭代 计划 会议   迭代 计划 会议 我们 现在 是 由 迭代 学习 会议 和 迭代 评估 会议   2   个 会议 组成 。 \n 迭代 学习 会议   迭代 backlog 在 我们 开始 一个 迭代 之前 会 由 产品 人员 提前 提取 到 迭代 规划 中 （ 我们 现在 展现 在 TAPD 中 ） ， 并且 和 开发 负责 责人 负责人 确认 好 这个 个 迭代 的 开发 范围 。 这个 工作 基本 基本上 是 在 上 个 迭代 后期 中后期 完成 的 ， 产品 人员 在 做 的 过程 中 需要 和 开发 发人 人员 开发人员 进行 相关 沟通 ， 特别 是 开发 负责 责人 负责人 ， 所以 这个 时期 的 开发 发人 人员 开发人员 积极 支持 积极支持 也 是 很 关键 的 。 在 这个 backlog 里面 ， 每个 需求 必须 写明 业务 逻辑 和 验收 标准 ， 如果 有 必要 还 需要 补充 使用 场景 说明 和 功能 的 UI 设计 。 \n 迭代 评估 会议   迭代 计划 主要 是 围绕 迭代 backlog 进行 ， 我们 对 迭代 计划 会议 做 了 不少 调整 。 我们 首先 在 迭代 计划 中 进行 业务 学习 业务学习 会议 ， 在 这个 过程 中 我们 要求 每个 开发 发人 人员 开发人员 和 测试 人员 测试人员 对 本次 迭代 范围 内 的 业务 进行 宣讲 ， 其他 没有 参与 宣讲 的 人员 需要 对 宣讲 人员 的 疑问 进行 解答 ， 特别 是 产品 人员 。 在 这个 过程 中 让 我们 每个 开发 发人 人员 开发人员 对 业务 目标 达成 共识 ， 识别 迭代 中 的 重点 和 难点 。 同时 这个 过程 可以 对 迭代 范围 提出 质疑 ， 如果 有 质疑 ， 团队 则 必须 在 会议 中 决策 出 迭代 范围 。 然后 我们 会 在 业务 学习 业务学习 会议 过后 ， 立即 召开 难点 设计 会议 ， 这个 会议 目前 主要 是 开发 发人 人员 开发人员 参与 ， 在 会议 上 开发 发人 人员 开发人员 要 针对 迭代 中 的 难点 和 重点 进行 详细 设计 ， 这个 过程 中 如果 有 必要 会 协调 产品 人员 一起 参与 （ 如 范围 调整 ， 实现 复杂 复杂度 导致 业务 功能 的 变化 等 ） ， 得出 详细 设计 中 需要 的 必要 结果 （ 如 ： ER 图 ， 流程 流程图 ， 时序 图 等 ） ， 如果 有 需要 会后 形成 详细 的 设计 说明 说明书 ， 一般 情况 下 将 会议 中 形成 的 白板 图 形成 文档 即可 。 最后 所有 人员 对 业务 目标 和 难点 重难点 的 设计 达成 一致 后 ， 开发 发人 人员 开发人员 进行 估算 会议 ， 我们 现在 才 用 的 形式 是 卡牌 游戏 对 任务 进行 评估 ， 目前 通过 卡牌 游戏 可以 在 一定 程度 上 规避 个人 经验 主义 经验主义 和 单点 故障 单点故障 问题 。 进 过 迭代 计划 会议 团队 对 整个 迭代 的 业务 范围 业务范围 和 迭代 时间 做出 承诺 ， 当然 这个 迭代 计划 会议 持续 的 时间 会 随着 迭代 范围 和 难度 有 很大 变化 ， 目前 我们 团队 最长 的 一次 时间 是 5 个 工作 工作日 。 \n 迭代 质量 提升 ： code   review   每日 分享 会 我们 之前 叫做 每日 code   review   或   集体 代码 解释 （ 只有 开发 发人 人员 开发人员 参与 ） ， 但是 由于 近期 产品 人员 和 测试 人员 测试人员 的 参与 ， 发现 之前 的 名字 已经 不 合适 了 ， 就 改成 了 每日 分享 会 。 每日 分享 会 紧跟 在 每日 例会 后 进行 ， 也 像 每日 例会 一样 选定 一个 分享 分享者 （ 之前 是 2 个 ） 来 完成 一个 30 分钟 的 分享 ， 并且 对于 开发 发人 人员 开发人员 做 了 特定 规定 只能 做 code   review ， 目前 规定 这个 主持 主持人 和 每日 例会 主持 主持人 为 同一 人 。 并且 在 每日 分享 会 过后 ， 观察 观察者 （ 目前 是 项目 负责 责人 负责人 ） 有 义务 并且 也 是 必须 和 当天 主持 主持人 一起 对 当天 他 自己 的 表现 做 一个 简单 的 评估 和 回顾 ， 并 做 相关 记录 。 这里 不 只是 包括 人员 的 技术 ， 还 包括 人员 的 沟通 、 演讲 等 能力 。 \n 目前 这个 会议 也 在 调整 ， 之前 一个 分享 分享者 很多 时候 不能 达到   30   分钟 ， 并且 现在 团队 的 情况 让 产品 、 开发 和 测试 一起 做 分享 已经 不再 合适 。 \n 高效 学习 团队 ： 迭代 回顾 会议   迭代 会议 必须 准守   2   个 基本 原则 ： \n   无论 我们 发现 了 什么 ， 考虑 到 当时 的 已知 情况 、 个人 的 技术 水平 技术水平 和 能力 、 可用 的 资源 ， 以及 现实 实情 情况 现实情况 ， 我们 理解 并 坚信 ： 每个 人 对 自己 的 工作 都 已 全力 全力以赴 。   我们 的 目标 是 发现 改进 的 机会 ， 而 不是 去 责备 某个 人     迭代 回顾 会议 在 整个 迭代 上线 完成 过后 进行 ， 迭代 会议 也 和 我们 的 晨会 一样 ， 选定 一位 主持 主持人 。 主持 主持人 负责 引导 团队 回顾 在 本次 迭代 中 ： \n   团队 实践 回顾 （ 这里 有 很多 方法 ， 如 ： 时间 时间轴 法 ， 团队 情绪 表等 ）   团队 做得好 的 地方 ；   有 哪些 地方 哪些地方 我们 可以 做 得 更好 ；   我们 可以 做 哪些 实践 来 让 我们 改善 。     在 操作 作过 过程 操作过程 中 我们 会 让 团队 所有 人员 对 我们 可以 做 得 更好 的 事情 ， 进行 投票 票选 选举 投票选举 出 团队 认为 最 急迫 、 最 重要 的 前面 3 个 出来 ， 我们 进行 讨论 得出 我们 需要 的 实践 。 在 得出 实践 的 过程 中 ， 最 重要 的 是 团队 可以 看到 实际 可 执行 的 实践 ， 也 就是 这个 实践 最好 有 明确 的 结果 和 判断 好坏 的 标准 ， 能 形成   SMART   目标 最好 。 主持 主持人 在 这个 会议 中 ， 也 可以 加入 自己 的 元素 ， 但是 需要 遵守 2 个 原则 ： \n   不能 偏离 主题 内容 ；   必须 是 针对 整个 团队 的 内容 。     以下 是 我们 一次 在 迭代 会议 中 进行 的 团队 情绪 表 实践 ： \n 在 这里 回顾 会议 中   Master   角色 的 人 ( 观察 观察者 ) 员 需要 记录 会议 过程 全过程 ， 并且 需要 把 会议 记录 会议记录 同步 到 所有 有人 所有人 ， 一下 使 我们 使用 的 记录 末班 \n       记录 项   内容           记录   记录 这次 会议 的 内容       历史 问题 跟踪   前 一次 会议 总结 内容 ， 需要 提醒 住持 人 让 团队 评估 上次 的 目标 是否 完成       总结   记录 这次 会议 得出 的 结论   和   目标       观察   观察 这次 迭代 回顾 会议 本省 的 情况 ， 并 在 会后 主持 主持人 和 团队 交流 可以 改进 的 地方         迭代 回顾 会议 可以 让 我们 及时 发现 及时发现 团队 需要 改进 的 地方 ， 也 可以 让 我们 发现 团队 里面 需要 继续 维持 的 地方 ， 让 我们 不断 调整 团队 步伐 和 实践 ， 让 团队 里面 正确 的 、 好 的 事情 不断 发生 。 \n 未来   我们 目前 正在 引入 的 实践 \n   TDD （ 测试 驱动 开发 ）   迭代 演示   CI / CD   迭代 跟踪 者     同时 也 在 不断 调整 我们 现在 的 部分 实践 ， 如 完成 的 定义 、 团队 卓越 （ 高效 绩 ） 的 定义 和 目标 。 这 就 意味 意味着 团队 会 是 一个 持续 变化 和 持续 学习 的 过程 ， 同时 团队 所在 的 外界 因素 也 在 不断 的 变化 ， 这 就 需要 团队 的 每个 人 都 需要 做到 “ 学习 学习 再 学习 ， 实践 实践 再 实践 ” ， 让 团队 不断 的 成长 来 适应 各种 变化 。 \n 总结   管理 方法 方法论 改变 和 进化 的 驱动 动力 驱动力 是 项目 利益 的 最大 大化 最大化 ， 但是 改变 的 本质 是 项目 的 沟通 模式 沟通模式 。 沟通 模式 沟通模式 的 改变 可以 是 信息 的 展现 形式 、 信息 的 载体 、 信息 的 传递 方式 、 信息 流转 和 反馈 方式 。 这些 改变 都 会 对 我们 项目 管理 项目管理 中 其他 方面 产生 直接 影响 ， 并且 也 直接 影响 到 我们 的 管理 模式 管理模式 。 在 项目 进行 过程 中 既 需要 一对 一对一 的 精细 沟通 ， 也 需要 针对 项目 成功 目标 的 宏观 沟通 。 \n 我们 上面 谈到 了 项目 沟通 中 模式 的 改变 ， 其实 由于 沟通 模式 沟通模式 的 改变 ， 会 引发 项目 中 其他 管理 方面 的 改变 。 \n 在 这个 过程 中 团队 负责 责人 负责人 要 保证 团队 是 在 正确 的 道路 上 ， 并且 要 让 正确 的 事情 不断 的 发生 。 及时 识别 团队 的 所处 阶段 ， 识别 为 团队 引入 变化 的 时机 ， 及时 引入 变化 ； 不断 通过 实践 结果 总结 团队 的 失败 模式 和 成功 模式 ， 促进 成功 模式 不断 出现 ， 让 团队 在 不断 出现 的 失败 模式 中 恢复 。 同时 和 团队 一起 不断 提高 自己 ， 做好 对 自我 掌控 ， 定义 好 自己 的 成功 ， 接受 团队 比 自己 更好 的 想法 。 \n 推荐 给 大家 几本 团队 和 管理 方法 的 书 ： \n   《 Scrum   敏捷 软件 开发 软件开发 》   《 Scrum   实战 ： 故事 、 模型 与 成功 秘诀 》   《 Scrum   精髓 ： 敏捷 转型 指南 》   《 敏捷 软件 开发 软件开发 实践 ： 估算 与 计划 》   《 敏捷 教练 ： 如何 打造 优秀 的 敏捷 团队 》   《 如何 构建 敏捷 项目 管理 项目管理 团队 》   《 看 板 方法 》   《 看 板 实战 》   《 架构 即 未来 》  ", "title_s": "Scrum   +   看 板   开发 实践 ： 记录"}, {"description": "本文是总结我自己在使用 Hugo 进行建站的时候给网站增加内容检索功能的结果。做这个功能的一个原因也是由于自己使用的 Even 主题没有带检索功能，所有只有自己上手撸一把。使用的检索方案包括 Lunrjs 和 Algolia，本文的处理方式可以同时支持 2 中方式，可以根据自己的情况自由选择或切换。", "objectID": "https://blog.threeq.me/post/notes/hugo-site-search/", "tags": ["Hugo"], "title": "Hugo 网站增加搜索功能：Lunrjs 和 Algolia", "uri": "https://blog.threeq.me/post/notes/hugo-site-search/", "content": "本文是总结我自己在使用 Hugo 进行建站的时候给网站增加内容检索功能的结果。做这个功能的一个原因也是由于自己使用的 Even 主题没有带检索功能，所有只有自己上手撸一把。使用的检索方案包括 Lunrjs 和 Algolia，本文的处理方式可以同时支持 2 中方式，可以根据自己的情况自由选择或切换。\n\n很多的 Hugo 主题是没有自带搜索功能的，但是们为了方便用户浏览和查找内容是需要在网站上提供搜索功能。大家可以查看 Hugo 官方推荐的搜索方案，我在使用的时候选择的是 Lunr 和 Algolial，以下是我的方案记录。\n生产网站 JSON 数据 由于 Lunr 和 Algolia 都同时对 JSON 数据格式的支持，所以这里我们选用网站的 JSON 数据格式。\n首先需要在 config.toml 里面增加配置\n[outputs] home = [ &quot;HTML&quot;, &quot;RSS&quot;, &quot;JSON&quot;]  其次需要在你的主题目录里面新建 themes/&lt;your themme name&gt;/layouts/index.json 文件，输入一下内容\n[{{ range $index, $page := .Site.Pages }} {{- if ne $page.Type &quot;json&quot; -}} {{- if and $index (gt $index 0) -}},{{- end }} { &quot;uri&quot;: &quot;{{ $page.Permalink }}&quot;, &quot;title&quot;: &quot;{{ htmlEscape $page.Title}}&quot;, &quot;tags&quot;: [{{ range $tindex, $tag := $page.Params.tags }}{{ if $tindex }}, {{ end }}&quot;{{ $tag| htmlEscape }}&quot;{{ end }}], &quot;description&quot;: &quot;{{ htmlEscape .Description}}&quot;, &quot;content&quot;: {{$page.Plain | jsonify}} } {{- end -}} {{- end -}}]  这个时候我们使用 hugo 生成网站的时候会多生成一个 public/index.json 的数据文件，我们的所有操作都围绕这个数据文件进行。\n搜索框添加  这里的搜索框 HTML、CSS 代码添加会根据你自己的主题会有所不同\n 首先为了支持不同的搜索解决方案，我们需要在 config.toml 里面增加如下配置，这样我们在使用的时候就可以自由的开关和切换搜索功能\n[params.Search] enable = true # true or false type = 'algolia' # lunr or algolia index = 'algolia_index' # algolia enabled appID = 'algolia_application_id' # algolia enabled searchKey = 'algolia_search_only_key' # algolia enabled  然后将一下代码加入到你主题的相应位置\n{{- if .Site.Params.Search.Enable }} &lt;link href=&quot;{{&quot;lib/search/auto-complete.css&quot; | relURL}}&quot; rel=&quot;stylesheet&quot;&gt; &lt;div class=&quot;search-wrapper&quot;&gt; &lt;div class=&quot;searchbox&quot;&gt; &lt;div id='inputfield'&gt; &lt;i class='fa fa-search icon-search'&gt;&lt;/i&gt; &lt;input id=&quot;search-by&quot; autocomplete='off' autocorrect='off' name='address' placeholder=&quot;{{T &quot;Search-placeholder&quot;}}&quot; spellcheck='false' type='text'&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; {{- if (eq .Site.Params.Search.type &quot;lunr&quot;) }} &lt;script type=&quot;text/javascript&quot;&gt; {{ if .Site.IsMultiLingual }} var baseurl = &quot;{{.Site.BaseURL}}{{.Site.LanguagePrefix}}&quot;; {{ else }} var baseurl = &quot;{{.Site.BaseURL}}&quot;; {{ end }} &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/lunr/lunr.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/lunr/auto-complete.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/lunr/search.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; {{- else }} &lt;script type=&quot;text/javascript&quot;&gt; var lagoliaIndex = &quot;{{.Site.Params.Search.index}}&quot; var lagoliaAppID = &quot;{{.Site.Params.Search.appID}}&quot; var lagoliaSearchKey = &quot;{{.Site.Params.Search.searchKey}}&quot; &lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/algolia/search-bar.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; {{- end}} {{- end}}  这里用到的一些 JS文件 和 CSS 文件请到此地址下载：https://github.com/threeq/blog.threeq.me/tree/master/themes/even/static/lib/search，放到 static/lib/search 目录下。\n到这里我们为网站所加入的 Lunr 搜索功能就完成了，由于 Lunr 对于中文检索支持很差，我们需要手动处理一下我们的 public/index.josn，进行中文分词。同时这里需要使 Algolia 支持的话，也需要将我们的 JSON 数据提交到 Algolia 数据库中。\n搜索数据预处理 这里为了同时能将 public/index.josn 数据进行中文分词和提交到 Algolia 中，我这里自己写了一个 Python 脚本，方便处理和后续集成自动发布。在网站根目录新建文件 search_process.py，输入一下内容（你也可以到 这里下载）：\n# encoding=utf-8 &quot;&quot;&quot; Hugo 网站使用 Lunr 和 Algolia 搜索方案数据处理 数据处理需要用到 algoliasearch 和 jieba 库，先安装 pip install algoliasearch pip install jieba &quot;&quot;&quot; import sys reload(sys) sys.setdefaultencoding('utf-8') import os from algoliasearch import algoliasearch import jieba import json import argparse parser = argparse.ArgumentParser(description=&quot;site search data process.&quot;) parser.add_argument('--managehKey', '-k', required=False, help='algolia manage key') args = parser.parse_args() def sign_version(data): &quot;&quot;&quot; 计算版本签名 &quot;&quot;&quot; return hash(data['uri'] + '__' + data['title'] + '__' + data['content'])\tdef push_data(items): &quot;&quot;&quot; 提交数据变更 &quot;&quot;&quot; client = algoliasearch.Client(&quot;NIACONWTKJ&quot;, args.managehKey) index = client.init_index('blog.threeq.me') res = index.add_objects(items) print(&quot;push count: %d. items:\\n%s&quot; % (len(res), json.dumps(res, ensure_ascii=False, indent=2))) def delete_data(items): &quot;&quot;&quot; 删除数据 &quot;&quot;&quot; client = algoliasearch.Client(&quot;NIACONWTKJ&quot;, args.managehKey) index = client.init_index('blog.threeq.me') res = index.delete_objects(items) print(&quot;delete count: %d. items:\\n%s&quot; % (len(res), json.dumps(res, ensure_ascii=False, indent=2))) def algolia_push(): &quot;&quot;&quot; algolia 数据提交 &quot;&quot;&quot; # 得到已经 push 的数据 if os.path.isfile('public/index.push_version.json'): with open('public/index.push_version.json', 'r') as f: push_version_data = json.load(f) print(&quot;read version push data&quot;) else: push_version_data = dict() # 计算需要修改的数据 new_items = dict() add_items = [] del_items = [] for index in range(len(data_dict)): data = data_dict[index] data['objectID'] = data['uri'] new_items[(data['objectID'])] = True curr_version = sign_version(data) if push_version_data.has_key(data['objectID']): prev_version = push_version_data[data['objectID']] else: prev_version = None if curr_version != prev_version: add_items.append(data) push_version_data[data['objectID']] = curr_version for old_item in push_version_data.keys(): if not new_items.has_key(old_item): del_items.append(old_item) del push_version_data[old_item] # 需要删除数据 print(&quot;Delete lagolia items count： %d.&quot; % len(del_items)) if len(del_items) &gt; 0: delete_data(del_items) # 处理需要 push 的对象 if len(add_items) &gt; 0: push_data(add_items) else: print(&quot;Don't content Add or Modify. skipped lagolia push.&quot;) # 记录最新提交数据 with open('public/index.push_version.json', 'w') as f: json.dump(push_version_data,f, ensure_ascii=False) print(&quot;write recored push data&quot;) ###### # load public/index.json data ##### with open('public/index.json', 'r') as f: data_dict = json.load(f) print(&quot;load public/index.json complete.&quot;) ###### # algolia search process ###### if len(args.managehKey)&gt;0: algolia_push() else: print(&quot;skipped algolia push.&quot;) ###### # lunr search process # use jieba lib ###### for index in range(len(data_dict)): data = data_dict[index] data['title_s'] = &quot; &quot;.join(jieba.cut_for_search(data['title'])) data['content_s'] = &quot; &quot;.join(jieba.cut_for_search(data['content'])) print(&quot;word segmentation complete.&quot;) with open('public/index.json', 'w') as f: json.dump(data_dict,f, ensure_ascii=False) print(&quot;search process complete.&quot;)  这是可以使用如下命令进行操作\n$ python search_process.py -h # 查看帮助文档 $ python search_process.py -k '' # 只支持 Lunr 处理，中文分词 $ python search_process.py -k &lt;algolia manage key&gt; # 同时进行 Lunr 和 Algolia 处理 $ python search_process.py --managehKey &lt;algolia manage key&gt; # 同时进行 Lunr 和 Algolia 处理  加入发布流程 最后我们还可以很方便和发布流程集成，比如下面的 deploy.sh 脚本\n#!/bin/bash echo -e &quot;\\033[0;32mDeploying updates to GitHub...\\033[0m&quot; fail() { echo &quot;$1&quot; exit 1 } # Build the project. hugo # if using a theme, replace with `hugo -t &lt;YOURTHEME&gt;` echo &quot;search key $2&quot; searchKey=&quot;$2&quot; python2 search_process.py -k &quot;${searchKey}&quot; || fail &quot;site search data process fail. Error Code: [ $? ]&quot; # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=&quot;rebuilding site `date`&quot; if [ $# -ge 1 ] then msg=&quot;$1&quot; fi git commit -m &quot;$msg&quot; # Push source and build repos. git push origin master # Come Back up to the Project Root cd ..  使用时如下：\n$./deploy.sh $./deploy.sh &quot;this is message&quot; &lt;algolia manage key&gt; $./deploy.sh '' &lt;algolia manage key&gt;  参考：\n hugo-lunr-zh ", "content_s": "本文 是 总结 我 自己 在 使用   Hugo   进行 建站 的 时候 给 网站 增加 内容 检索 功能 的 结果 。 做 这个 功能 的 一个 原因 也 是 由于 自己 使用 的   Even   主题 没有 带 检索 功能 ， 所有 只有 自己 上手 撸 一把 。 使用 的 检索 方案 包括   Lunrjs   和   Algolia ， 本文 的 处理 方式 可以 同时 支持   2   中 方式 ， 可以 根据 自己 的 情况 自由 选择 自由选择 或 切换 。 \n \n 很多 的   Hugo   主题 是 没有 自带 搜索 功能 的 ， 但是 们 为了 方便 用户 浏览 和 查找 内容 是 需要 在 网站 上 提供 搜索 功能 。 大家 可以 查看   Hugo   官方 推荐 的 搜索 方案 ， 我 在 使用 的 时候 选择 的 是   Lunr   和   Algolial ， 以下 是 我 的 方案 记录 。 \n 生产 网站   JSON   数据   由于   Lunr   和   Algolia   都 同时 对   JSON   数据 格式 数据格式 的 支持 ， 所以 这里 我们 选用 网站 的   JSON   数据 格式 数据格式 。 \n 首先 需要 在   config . toml   里面 增加 配置 \n [ outputs ]   home   =   [   & quot ; HTML & quot ; ,   & quot ; RSS & quot ; ,   & quot ; JSON & quot ; ]     其次 需要 在 你 的 主题 题目 目录 主题目录 里面 新建   themes / & lt ; your   themme   name & gt ; / layouts / index . json   文件 ， 输入 一下 内容 \n [ { {   range   $ index ,   $ page   : =   . Site . Pages   } }   { { -   if   ne   $ page . Type   & quot ; json & quot ;   - } }   { { -   if   and   $ index   ( gt   $ index   0 )   - } } , { { -   end   } }   {   & quot ; uri & quot ; :   & quot ; { {   $ page . Permalink   } } & quot ; ,   & quot ; title & quot ; :   & quot ; { {   htmlEscape   $ page . Title } } & quot ; ,   & quot ; tags & quot ; :   [ { {   range   $ tindex ,   $ tag   : =   $ page . Params . tags   } } { {   if   $ tindex   } } ,   { {   end   } } & quot ; { {   $ tag |   htmlEscape   } } & quot ; { {   end   } } ] ,   & quot ; description & quot ; :   & quot ; { {   htmlEscape   . Description } } & quot ; ,   & quot ; content & quot ; :   { { $ page . Plain   |   jsonify } }   }   { { -   end   - } }   { { -   end   - } } ]     这个 时候 我们 使用   hugo   生成 网站 的 时候 会多 生成 一个   public / index . json   的 数据 文件 数据文件 ， 我们 的 所有 操作 都 围绕 这个 数据 文件 数据文件 进行 。 \n 搜索 框 添加     这里 的 搜索 框   HTML 、 CSS   代码 添加 会 根据 你 自己 的 主题 会 有所 不同 有所不同 \n   首先 为了 支持 不同 的 搜索 解决 方案 解决方案 ， 我们 需要 在   config . toml   里面 增加 如下 配置 ， 这样 我们 在 使用 的 时候 就 可以 自由 的 开关 和 切换 搜索 功能 \n [ params . Search ]   enable   =   true   #   true   or   false   type   =   ' algolia '   #   lunr   or   algolia   index   =   ' algolia _ index '   #   algolia   enabled   appID   =   ' algolia _ application _ id '   #   algolia   enabled   searchKey   =   ' algolia _ search _ only _ key '   #   algolia   enabled     然后 将 一下 代码 加入 到 你 主题 的 相应 位置 \n { { -   if   . Site . Params . Search . Enable   } }   & lt ; link   href = & quot ; { { & quot ; lib / search / auto - complete . css & quot ;   |   relURL } } & quot ;   rel = & quot ; stylesheet & quot ; & gt ;   & lt ; div   class = & quot ; search - wrapper & quot ; & gt ;   & lt ; div   class = & quot ; searchbox & quot ; & gt ;   & lt ; div   id = ' inputfield ' & gt ;   & lt ; i   class = ' fa   fa - search   icon - search ' & gt ; & lt ; / i & gt ;   & lt ; input   id = & quot ; search - by & quot ;   autocomplete = ' off '   autocorrect = ' off '   name = ' address '   placeholder = & quot ; { { T   & quot ; Search - placeholder & quot ; } } & quot ;   spellcheck = ' false '   type = ' text ' & gt ;   & lt ; / div & gt ;   & lt ; / div & gt ;   & lt ; / div & gt ;   { { -   if   ( eq   . Site . Params . Search . type   & quot ; lunr & quot ; )   } }   & lt ; script   type = & quot ; text / javascript & quot ; & gt ;   { {   if   . Site . IsMultiLingual   } }   var   baseurl   =   & quot ; { { . Site . BaseURL } } { { . Site . LanguagePrefix } } & quot ; ;   { {   else   } }   var   baseurl   =   & quot ; { { . Site . BaseURL } } & quot ; ;   { {   end   } }   & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / lunr / lunr . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / lunr / auto - complete . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / lunr / search . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   { { -   else   } }   & lt ; script   type = & quot ; text / javascript & quot ; & gt ;   var   lagoliaIndex   =   & quot ; { { . Site . Params . Search . index } } & quot ;   var   lagoliaAppID   =   & quot ; { { . Site . Params . Search . appID } } & quot ;   var   lagoliaSearchKey   =   & quot ; { { . Site . Params . Search . searchKey } } & quot ;   & lt ; / script & gt ;   & lt ; script   src = & quot ; / / cdn . jsdelivr . net / autocomplete . js / 0 / autocomplete . jquery . min . js & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   src = & quot ; / / cdn . jsdelivr . net / algoliasearch / 3 / algoliasearch . min . js & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / algolia / search - bar . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   { { -   end } }   { { -   end } }     这里 用到 的 一些   JS 文件   和   CSS   文件 请 到 此 地址 下载 ： https : / / github . com / threeq / blog . threeq . me / tree / master / themes / even / static / lib / search ， 放到   static / lib / search   目录 下 。 \n 到 这里 我们 为 网站 所 加入 的   Lunr   搜索 功能 就 完成 了 ， 由于   Lunr   对于 中文 检索 支持 很差 ， 我们 需要 手动 处理 一下 我们 的   public / index . josn ， 进行 中文 分词 。 同时 这里 需要 使   Algolia   支持 的话 ， 也 需要 将 我们 的   JSON   数据 提交 到   Algolia   数据 据库 数据库 中 。 \n 搜索 数据 处理 预处理   这里 为了 同时 能 将   public / index . josn   数据 进行 中文 分词 和 提交 到   Algolia   中 ， 我 这里 自己 写 了 一个   Python   脚本 ， 方便 处理 和 后续 集成 自动 发布 。 在 网站 目录 根目录 新建 文件   search _ process . py ， 输入 一下 内容 （ 你 也 可以 到   这里 下载 ） ： \n #   encoding = utf - 8   & quot ; & quot ; & quot ;   Hugo   网站 使用   Lunr   和   Algolia   搜索 方案 数据 处理 数据处理   数据 处理 数据处理 需要 用到   algoliasearch   和   jieba   库 ， 先 安装   pip   install   algoliasearch   pip   install   jieba   & quot ; & quot ; & quot ;   import   sys   reload ( sys )   sys . setdefaultencoding ( ' utf - 8 ' )   import   os   from   algoliasearch   import   algoliasearch   import   jieba   import   json   import   argparse   parser   =   argparse . ArgumentParser ( description = & quot ; site   search   data   process .& quot ; )   parser . add _ argument ( ' - - managehKey ' ,   ' - k ' ,   required = False ,   help = ' algolia   manage   key ' )   args   =   parser . parse _ args ( )   def   sign _ version ( data ) :   & quot ; & quot ; & quot ;   计算 版本 签名   & quot ; & quot ; & quot ;   return   hash ( data [ ' uri ' ]   +   ' __ '   +   data [ ' title ' ]   +   ' __ '   +   data [ ' content ' ] ) \t def   push _ data ( items ) :   & quot ; & quot ; & quot ;   提交 数据 变更   & quot ; & quot ; & quot ;   client   =   algoliasearch . Client ( & quot ; NIACONWTKJ & quot ; ,   args . managehKey )   index   =   client . init _ index ( ' blog . threeq . me ' )   res   =   index . add _ objects ( items )   print ( & quot ; push   count :   % d .   items : \\ n% s & quot ;   %   ( len ( res ) ,   json . dumps ( res ,   ensure _ ascii = False ,   indent = 2 ) ) )   def   delete _ data ( items ) :   & quot ; & quot ; & quot ;   删除 数据   & quot ; & quot ; & quot ;   client   =   algoliasearch . Client ( & quot ; NIACONWTKJ & quot ; ,   args . managehKey )   index   =   client . init _ index ( ' blog . threeq . me ' )   res   =   index . delete _ objects ( items )   print ( & quot ; delete   count :   % d .   items : \\ n% s & quot ;   %   ( len ( res ) ,   json . dumps ( res ,   ensure _ ascii = False ,   indent = 2 ) ) )   def   algolia _ push ( ) :   & quot ; & quot ; & quot ;   algolia   数据 提交   & quot ; & quot ; & quot ;   #   得到 已经   push   的 数据   if   os . path . isfile ( ' public / index . push _ version . json ' ) :   with   open ( ' public / index . push _ version . json ' ,   ' r ' )   as   f :   push _ version _ data   =   json . load ( f )   print ( & quot ; read   version   push   data & quot ; )   else :   push _ version _ data   =   dict ( )   #   计算 需要 修改 的 数据   new _ items   =   dict ( )   add _ items   =   [ ]   del _ items   =   [ ]   for   index   in   range ( len ( data _ dict ) ) :   data   =   data _ dict [ index ]   data [ ' objectID ' ]   =   data [ ' uri ' ]   new _ items [ ( data [ ' objectID ' ] ) ]   =   True   curr _ version   =   sign _ version ( data )   if   push _ version _ data . has _ key ( data [ ' objectID ' ] ) :   prev _ version   =   push _ version _ data [ data [ ' objectID ' ] ]   else :   prev _ version   =   None   if   curr _ version   ! =   prev _ version :   add _ items . append ( data )   push _ version _ data [ data [ ' objectID ' ] ]   =   curr _ version   for   old _ item   in   push _ version _ data . keys ( ) :   if   not   new _ items . has _ key ( old _ item ) :   del _ items . append ( old _ item )   del   push _ version _ data [ old _ item ]   #   需要 删除 数据   print ( & quot ; Delete   lagolia   items   count ：   % d .& quot ;   %   len ( del _ items ) )   if   len ( del _ items )   & gt ;   0 :   delete _ data ( del _ items )   #   处理 需要   push   的 对象   if   len ( add _ items )   & gt ;   0 :   push _ data ( add _ items )   else :   print ( & quot ; Don ' t   content   Add   or   Modify .   skipped   lagolia   push .& quot ; )   #   记录 最新 提交 数据   with   open ( ' public / index . push _ version . json ' ,   ' w ' )   as   f :   json . dump ( push _ version _ data , f ,   ensure _ ascii = False )   print ( & quot ; write   recored   push   data & quot ; )   ######   #   load   public / index . json   data   #####   with   open ( ' public / index . json ' ,   ' r ' )   as   f :   data _ dict   =   json . load ( f )   print ( & quot ; load   public / index . json   complete .& quot ; )   ######   #   algolia   search   process   ######   if   len ( args . managehKey ) & gt ; 0 :   algolia _ push ( )   else :   print ( & quot ; skipped   algolia   push .& quot ; )   ######   #   lunr   search   process   #   use   jieba   lib   ######   for   index   in   range ( len ( data _ dict ) ) :   data   =   data _ dict [ index ]   data [ ' title _ s ' ]   =   & quot ;   & quot ; . join ( jieba . cut _ for _ search ( data [ ' title ' ] ) )   data [ ' content _ s ' ]   =   & quot ;   & quot ; . join ( jieba . cut _ for _ search ( data [ ' content ' ] ) )   print ( & quot ; word   segmentation   complete .& quot ; )   with   open ( ' public / index . json ' ,   ' w ' )   as   f :   json . dump ( data _ dict , f ,   ensure _ ascii = False )   print ( & quot ; search   process   complete .& quot ; )     这是 可以 使用 如下 命令 进行 操作 \n $   python   search _ process . py   - h   #   查看 帮助 文档   $   python   search _ process . py   - k   ' '   #   只 支持   Lunr   处理 ， 中文 分词   $   python   search _ process . py   - k   & lt ; algolia   manage   key & gt ;   #   同时 进行   Lunr   和   Algolia   处理   $   python   search _ process . py   - - managehKey   & lt ; algolia   manage   key & gt ;   #   同时 进行   Lunr   和   Algolia   处理     加入 发布 流程   最后 我们 还 可以 很 方便 和 发布 流程 集成 ， 比如 下面 的   deploy . sh   脚本 \n # ! / bin / bash   echo   - e   & quot ; \\ 033 [ 0 ; 32mDeploying   updates   to   GitHub ... \\ 033 [ 0m & quot ;   fail ( )   {   echo   & quot ; $ 1 & quot ;   exit   1   }   #   Build   the   project .   hugo   #   if   using   a   theme ,   replace   with   ` hugo   - t   & lt ; YOURTHEME & gt ; `   echo   & quot ; search   key   $ 2 & quot ;   searchKey = & quot ; $ 2 & quot ;   python2   search _ process . py   - k   & quot ; $ { searchKey } & quot ;   | |   fail   & quot ; site   search   data   process   fail .   Error   Code :   [   $ ?   ] & quot ;   #   Go   To   Public   folder   cd   public   #   Add   changes   to   git .   git   add   .   #   Commit   changes .   msg = & quot ; rebuilding   site   ` date ` & quot ;   if   [   $ #   - ge   1   ]   then   msg = & quot ; $ 1 & quot ;   fi   git   commit   - m   & quot ; $ msg & quot ;   #   Push   source   and   build   repos .   git   push   origin   master   #   Come   Back   up   to   the   Project   Root   cd   ..     使用 时 如下 ： \n $ . / deploy . sh   $ . / deploy . sh   & quot ; this   is   message & quot ;   & lt ; algolia   manage   key & gt ;   $ . / deploy . sh   ' '   & lt ; algolia   manage   key & gt ;     参考 ： \n   hugo - lunr - zh  ", "title_s": "Hugo   网站 增加 搜索 功能 ： Lunrjs   和   Algolia"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/1-install-tools/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第一天：环境搭建", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/1-install-tools/", "content": "《小白学 SQL》第一天\n本篇文章是《小白学 SQL》系列的开篇，也是学习的第一天。这个系列的文章是之前的学习笔记整理，同时再加入我自己在使用使用的一些使用经验，属于比较初级的知识整理，适合小白用户（初学者和刚入门）。\n数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。\n作为学习的第一天我们将从搭建环境开始，今天实践涉及到的工具有：\n MySQL Docker ConEmuSetup（windows 版本命令行工具，Linux 和 Mac 不需要） Navicat  \n工具选择和说明 可能大家有些奇怪，为什么这里会选用 Docker，这个和我们 SQL 完全没有关系。这里 Docker 确实和我们学习的 SQL 完全没有关系，但就我个人使用来说 ：\n一、docker 作为基础环境，在上面安装 MySQL 服务比我们在自己裸机上装 MySQL 方便得多，并且不易且不怕出错；\n二、目前整个 IT 行业容器化正在如火如荼的进行，这个是未来不可逆转的趋势，Dcoker 正式这个大军里面的主力军；\n三、MySQL 安装跨平台化，使用 Docker 过后你在任何一个系统里面（Windows、Linux、Mac OS）安装 MySQL 操作都是完全一样的\n基于以上三点原因，所以这里我选择了 Docker 作为数据库运行基础环境。\n软件作用：\n   软件 作用说明     Docker 提供跨平台的软件运行基础环境   MySQL 最常用的 RDBMS 之一，作为我们学习 SQL 的数据库服务器   Navicat 一个被广泛使用的数据库客户端，作为我们主要的 SQL 编辑器   ConEmuSetup 一个 Window 命令行终端（Linux、Mac 使用自带的足以）    安装 Windows 安装 ConEmuSetup  到 ConEmuSetup 下载页面 现在对应软件版本 然后一路 “Next” 就好  Docker 安装 Docker 这里我们使用 Community Edition 版本，请到这里下载：下载地址。\n 对于 Windows 版和 Mac 版，下载下来后双击文件运行，剩下的几乎就是一路 &ldquo;Next&rdquo; 点下去就完了，最后双击桌面图标启动 Docker 服务，这里就不在说明了 对于 Linux 版本，由于不同发行版的需求不同，安装步骤略有不同，但是基本也和常用软件安装差不多，并且官方文档也和齐全这里就直接放官方的安装连接地址了（是英文的哟，如果有好的中文教程推荐，请留言我尽快放上来）: Ubuntu CentOS Fedora Debian  加速器配置：Windows、Mac 对于 Docker 安装完成过后，国内用户还有一步需要操作：指定 docker 加速器（原因不多说）。Windows 和 Mac 系统具体操作如下：\n 找到 Docker 运行系统托盘图片，右击打开菜单如下    点击 Preferences 菜单，打开设置界面如下   点击 Daemon 标签项，再 Rgistry mirrors 中输入镜像加速器网址 https://docker.mirrors.ustc.edu.cn。如下图  对于 Linux 系统配置需要修改相关配置文件，不同系统版本有所不同。\n加速器配置：Ubuntu 14.04、Debian 7 Wheezy 对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS中配置加速器地址：\nDOCKER_OPTS=&quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&quot;  重启 Docker 服务：\n$ sudo service docker restart  加速器配置：Ubuntu 16.04+、Debian 8+、CentOS 7 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n{ &quot;registry-mirrors&quot;: [ &quot;https://docker.mirrors.ustc.edu.cn&quot; ] }   注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。\n 重启 Docker 服务：\n$ sudo systemctl daemon-reload $ sudo systemctl restart docker  检查加速器是否生效 打开终端（命令行工具）输入 docker info 命令，如果从结果中看到了如下内容，说明配置成功。\nRegistry Mirrors: https://docker.mirrors.ustc.edu.cn/  其他可用的加速服务有很多，这里列举几个方便大家查找：\n Docker 官方提供的中国 registry mirror DaoCloud 加速器 阿里云加速器  MySQL 服务安装 在安装完成 Docker 过后，MySQL 服务的安装就很简单了。在你的终端命令行里面输入如下命令启动 MySQL 服务：\n$ docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql  查看 MySQL 服务运行状态\n$ docker ps  这里不要被命令吓着了，Docker 本身的命令不少，包括以后的所有操作，我们总共用到 docker 命令就4、5个。这里先列出来，大家可以操作一下\n$ docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql # 创建一个名为 sql-learn MySQL 容器 $ docker ps # 查看容器运行状态 $ docker stop sql-learn # 停止 sql-learn 容器 $ docker rm sql-learn # 删除 sql-learn 容器，必须先停止  Navicat 安装 安装和 ConEmuSetup 类似\n 到 Navicat 下载页面 现在对应软件版本。推荐 Navicat Premium 然后一路 “Next” 就好  验证环境安装完成  双击桌面 “Navicat” 应用图标，打开 Navicat 软件  ​  点击 “链接” 增加到 sql-learn 的数据库链接。输入截图里面的内容，这里密码输入 toor ，点击 “Test Connection” 出现绿点没有错误表示成功，如下图   双击 “左边导航列表” 里的 sql-learn 得到如下结果   创建一个用于我们以后学习使用的数据库。点击 “New Query” 新建一个查询窗口  输入一下 SQL 语句\ncreate database `sql-learn` default charset=utf8mb4;  点击执行得到如下结果，表示成功\n支持我们的环境安装和验证全部结束。\n总结 我们学习一下几点：\n 如何安装 Docker 服务\n 如何在 Docker 里面启动 MySQL 服务器\n   docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql # 无 sql-learn 容器时 或 docker start sql-learn # 已有 sql-learn 容器时   我们在使用数据库系统的时候需要一个数据库服务器（这里是 MySQL），还需要一个数据库客户端（这里是 Navicat）\n 在链接 MySQL 服务器之前需要先启动 MySQL 服务器\n 在连接一个 MySQL 服务器是需要提供的基本信息有：服务器 IP、服务器端口、用户名、密码\n ", "content_s": "《 小白学   SQL 》 第一 一天 第一天 \n 本篇 文章 是 《 小白学   SQL 》 系列 的 开篇 ， 也 是 学习 的 第一 一天 第一天 。 这个 系列 的 文章 是 之前 的 学习 笔记 整理 ， 同时 再 加入 我 自己 在 使用 使用 的 一些 使用 经验 ， 属于 比较 初级 的 知识 整理 ， 适合 小白 用户 （ 初学 学者 初学者 和 刚 入门 ） 。 \n 数据 据库 数据库 管理 系统 管理系 管理系统 （ DBMS ） 是   IT   从业 业者 从业者 必备 工具 之一 ， 你 能 在 市面 面上 市面上 看到 的 任何 一个 软件 系统 软件系统 ， 在 后面 支持 的 一定 有 它 的 身影 。   而 这 里面 关系 型 数据 据库 数据库 管理 系统 管理系 管理系统 （ RDBMS ）   目前 暂居 了 绝大 大部 部分 大部分 绝大部分 ， 操作   RDBMS   的 基础 就是 今天 我们 要 开始 学习 的   SQL （ 结构 结构化 查询 语言 查询语言 ） ， 所以 我们 有 必要 针对   SQL   进行 系统 全面 的 学习 。 \n 作为 学习 的 第一 一天 第一天 我们 将 从 搭建 环境 开始 ， 今天 实践 涉及 到 的 工具 有 ： \n   MySQL   Docker   ConEmuSetup （ windows   版本 命令 命令行 工具 ， Linux   和   Mac   不 需要 ）   Navicat     \n 工具 选择 和 说明   可能 大家 有些 奇怪 ， 什么 为什么 这里 会 选用   Docker ， 这个 和 我们   SQL   完全 没有 关系 。 这里   Docker   确实 和 我们 学习 的   SQL   完全 没有 关系 ， 但 就 我 个人 使用 来说   ： \n 一 、 docker   作为 基础 环境 ， 在 上面 安装   MySQL   服务 比 我们 在 自己 裸机 上装   MySQL   方便 得 多 ， 并且 不易 且 不怕 出错 ； \n 二 、 目前 整个   IT   行业 容器 化 正在 如火如荼 的 进行 ， 这个 是 未来 不可 可逆 逆转 不可逆转 的 趋势 ， Dcoker   正式 这个 大军 里面 的 主力 主力军 ； \n 三 、 MySQL   安装 平台 跨平台 化 ， 使用   Docker   过后 你 在 任何 一个 系统 里面 （ Windows 、 Linux 、 Mac   OS ） 安装   MySQL   操作 都 是 完全 一样 的 \n 基于 以上 三点 原因 ， 所以 这里 我 选择 了   Docker   作为 数据 据库 数据库 运行 基础 环境 。 \n 软件 作用 ： \n       软件   作用 说明           Docker   提供 平台 跨平台 的 软件 运行 基础 环境       MySQL   最 常用 的   RDBMS   之一 ， 作为 我们 学习   SQL   的 数据 据库 数据库 服务 务器 服务器       Navicat   一个 被 广泛 使用 的 数据 据库 数据库 客户 客户端 ， 作为 我们 主要 的   SQL   编辑 编辑器       ConEmuSetup   一个   Window   命令 命令行 终端 （ Linux 、 Mac   使用 自带 的 足以 ）         安装   Windows   安装   ConEmuSetup     到   ConEmuSetup   下载 页面   现在 对应 软件 版本   然后 一路   “ Next ”   就 好     Docker   安装   Docker   这里 我们 使用   Community   Edition   版本 ， 请 到 这里 下载 ： 下载 地址 。 \n   对于   Windows   版 和   Mac   版 ， 下载 下来 后 双击 文件 运行 ， 剩下 的 几乎 就是 一路   & ldquo ; Next & rdquo ;   点 下去 就 完 了 ， 最后 双击 桌面 图标 桌面图 桌面图标 启动   Docker   服务 ， 这里 就 不 在 说明 了   对于   Linux   版本 ， 由于 不同 发行 发行版 的 需求 不同 ， 安装 步骤 略有 不同 略有不同 ， 但是 基本 也 和 常用 软件 常用软件 安装 不多 差不多 ， 并且 官方 文档 也 和 齐全 这里 就 直接 放 官方 的 安装 连接 地址 了 （ 是 英文 的 哟 ， 如果 有 好 的 中文 教程 推荐 ， 请 留言 我 尽快 放上 上来 放上来 ） :   Ubuntu   CentOS   Fedora   Debian     加速 加速器 配置 ： Windows 、 Mac   对于   Docker   安装 完成 过后 ， 国内 用户 还有 一步 需要 操作 ： 指定   docker   加速 加速器 （ 原因 不多 说 ） 。 Windows   和   Mac   系统 具体 体操 操作 具体操作 如下 ： \n   找到   Docker   运行 系统 托盘 系统托盘 图片 ， 右击 打开 菜单 如下         点击   Preferences   菜单 ， 打开 设置 界面 如下       点击   Daemon   标签 项 ， 再   Rgistry   mirrors   中 输入 镜像 加速 加速器 网址   https : / / docker . mirrors . ustc . edu . cn 。 如下 图     对于   Linux   系统 统配 配置 系统配 系统配置 需要 修改 相关 配置 文件 配置文件 ， 不同 系统 版本 有所 不同 有所不同 。 \n 加速 加速器 配置 ： Ubuntu   14.04 、 Debian   7   Wheezy   对于 使用   upstart   的 系统 而言 ， 编辑   / etc / default / docker   文件 ， 在 其中 的   DOCKER _ OPTS 中 配置 加速 加速器 地址 ： \n DOCKER _ OPTS = & quot ; - - registry - mirror = https : / / docker . mirrors . ustc . edu . cn & quot ;     重启   Docker   服务 ： \n $   sudo   service   docker   restart     加速 加速器 配置 ： Ubuntu   16.04 + 、 Debian   8 + 、 CentOS   7   对于 使用   systemd   的 系统 ， 请 在   / etc / docker / daemon . json   中 写入 如下 内容 （ 如果 文件 不 存在 请 新建 该 文件 ） \n {   & quot ; registry - mirrors & quot ; :   [   & quot ; https : / / docker . mirrors . ustc . edu . cn & quot ;   ]   }       注意 ， 一定 要 保证 该 文件 符合   json   规范 ， 否则   Docker   将 不能 启动 。 \n   重启   Docker   服务 ： \n $   sudo   systemctl   daemon - reload   $   sudo   systemctl   restart   docker     检查 加速 加速器 是否 生效   打开 终端 （ 命令 命令行 工具 ） 输入   docker   info   命令 ， 如果 从 结果 中 看到 了 如下 内容 ， 说明 配置 成功 。 \n Registry   Mirrors :   https : / / docker . mirrors . ustc . edu . cn /     其他 可用 的 加速 服务 有 很多 ， 这里 列举 几个 方便 大家 查找 ： \n   Docker   官方 提供 的 中国   registry   mirror   DaoCloud   加速 加速器   阿里 云 加速 加速器     MySQL   服务 安装   在 安装 完成   Docker   过后 ， MySQL   服务 的 安装 就 很 简单 了 。 在 你 的 终端 命令 命令行 里面 输入 如下 命令 启动   MySQL   服务 ： \n $   docker   run   - - name   sql - learn   - e   MYSQL _ ROOT _ PASSWORD = toor   - p3306 : 3306   - d   mysql     查看   MySQL   服务 运行 状态 \n $   docker   ps     这里 不要 被 命令 吓 着 了 ， Docker   本身 的 命令 不少 ， 包括 以后 的 所有 操作 ， 我们 总共 用到   docker   命令 就 4 、 5 个 。 这里 先列 出来 ， 大家 可以 操作 一下 \n $   docker   run   - - name   sql - learn   - e   MYSQL _ ROOT _ PASSWORD = toor   - p3306 : 3306   - d   mysql   #   创建 一个 名为   sql - learn   MySQL   容器   $   docker   ps   #   查看 容器 运行 状态   $   docker   stop   sql - learn   #   停止   sql - learn   容器   $   docker   rm   sql - learn   #   删除   sql - learn   容器 ， 必须 先 停止     Navicat   安装   安装 和   ConEmuSetup   类似 \n   到   Navicat   下载 页面   现在 对应 软件 版本 。 推荐   Navicat   Premium   然后 一路   “ Next ”   就 好     验证 环境 安装 完成     双击 桌面   “ Navicat ”   应用 图标 ， 打开   Navicat   软件     ​     点击   “ 链接 ”   增加 到   sql - learn   的 数据 据库 数据库 链接 。 输入 截图 里面 的 内容 ， 这里 密码 输入   toor   ， 点击   “ Test   Connection ”   出现 绿点 没有 错误 表示 成功 ， 如下 图       双击   “ 左边 导航 列表 ”   里 的   sql - learn   得到 如下 结果       创建 一个 用于 我们 以后 学习 使用 的 数据 据库 数据库 。 点击   “ New   Query ”   新建 一个 查询 窗口     输入 一下   SQL   语句 \n create   database   ` sql - learn `   default   charset = utf8mb4 ;     点击 执行 得到 如下 结果 ， 表示 成功 \n 支持 我们 的 环境 安装 和 验证 全部 结束 。 \n 总结   我们 学习 一下 几点 ： \n   如何 安装   Docker   服务 \n   如何 在   Docker   里面 启动   MySQL   服务 务器 服务器 \n       docker   run   - - name   sql - learn   - e   MYSQL _ ROOT _ PASSWORD = toor   - p3306 : 3306   - d   mysql   #   无   sql - learn   容器 时   或   docker   start   sql - learn   #   已有   sql - learn   容器 时       我们 在 使用 数据 据库 系统 数据库 数据库系统 的 时候 需要 一个 数据 据库 数据库 服务 务器 服务器 （ 这里 是   MySQL ） ， 还 需要 一个 数据 据库 数据库 客户 客户端 （ 这里 是   Navicat ） \n   在 链接   MySQL   服务 务器 服务器 之前 需要 先 启动   MySQL   服务 务器 服务器 \n   在 连接 一个   MySQL   服务 务器 服务器 是 需要 提供 的 基本 信息 有 ： 服务 务器 服务器   IP 、 服务 务器 服务器 服务器端 口 、 用户 户名 用户名 、 密码 \n  ", "title_s": "小白学   SQL   第一 一天 第一天 ： 环境 搭建"}, {"description": "", "objectID": "https://blog.threeq.me/post/db/mysql-slow-query-analyse/", "tags": ["Mysql", "数据库", "查询优化", "percona", "pt-query-digest"], "title": "mysql 查询优化：慢查询分析工具 pt-query-digest", "uri": "https://blog.threeq.me/post/db/mysql-slow-query-analyse/", "content": "在系统刚上线的时候，经常会出现慢 SQL 的情况，并且有时候系统会在特定的时间点变慢。这个时候的慢 SQL 查询语句往往是大量出现，MySQL 的慢查询日志文件也会比较大。这个时候我们往往需要从哪些查询最多、耗时最长的 sql 开始优化，以提升我们的处理效益。这个时候就需要我们能对慢日志进行统计分析，在上 M ，甚至 几十 M 的日志文件里面使用手工的方式明显是不可能的，这个时候就需要有专门的统计分析工具来帮我们做统计、分析哪些慢查询日志。percona-toolkit 就是一个提供统计和分析的工具集，这里重点介绍里面的 pt-query-digest 工具。\n\npercona-toolkit 安装 percona-toolkit 首页 文档 下载地址\nmac 安装 可以使用 brew 直接安装\nbrew install percona-toolkit  Linux 安装 详细信息参考 官方安装文档\n源码安装 # 下载源码 wget https://www.percona.com/downloads/percona-toolkit/3.0.8/source/tarball/percona-toolkit-3.0.8.tar.gz # 解压 tar xf percona-toolkit-3.0.8.tar.gz #进入目录安装 cd percona-toolkit-3.0.8 #开始编译安装 perl Makefile.PL make make install #安装完了就有命令了 ll /usr/local/bin/pt-*  pt-query-digest 基本使用 在使用 pt-query-digest 前需要有 MySQL 慢查询日志文件，这里为了大家方便实验提供了一份 MySQL 慢查询日实验数据 供大家下载测试（slow-sql-test.sql.zip 点击我下载，里面包含2018.04.01～2018.04.04 和 2018.04.06 的日志数据）。\n 查看使用帮助  &gt; pt-query-digest --help   默认分析参数  &gt; pt-query-digest slow-sql-test.sql   总体概要信息：\n   信息字段 说明     Exec Time 执行时间   Lock Time 锁时间   Row sent 发送行大小   Row examine 检查行大小   Query size 查询大小   Rank SQL 编号   Query ID 查询 id   Response time sql 总共执行时间 和 时间比例   Calls sql 执行次数   R/Call sql 平均每次执行时间   V/M    Item sql 类型和涉及到的表    单个 SQL 信息：\n ​ 分析结果说明：\n 分析最近一段时间内的慢查询  &gt; pt-query-digest --since=12h slow-sql-test.sql # 最近 12 小时的慢查询   分析指定时间段内的慢查询  &gt; pt-query-digest slow-sql-test.sql --since '2018-04-01 09:30:00' --until '2018-04-02 10:00:00'   分析还有指定特征的慢查询 SQL  &gt; pt-query-digest --filter '$event-&gt;{fingerprint} =~ m/^select/i' slow-sql-test.sql   分析针对某个用户的慢查询  &gt; pt-query-digest --filter '($event-&gt;{member} || &quot;&quot;) =~ m/^root/i' slow-sql-test.sql   ​  pt-query-digest进阶使用 有时候我们会遇到针对慢 SQL 进行长期的跟踪分析，这个时候我们就需要将我们的每次的分析结果进行汇总、对比分析。同时对于部分环境我们是不能直接得到慢 SQL 日志的，这个时候我们可以通过抓取 TCP 协议数据或 binlog 进行分析\n 将分析结果保存到数据库  &gt; pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_review--create-review-table slow-sql-test.sql   通过抓取 TCP 协议数据分析  &gt; tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txt &gt; pt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log   通过 binlog 日志分析  &gt; mysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sql &gt; pt-query-digest --type=binlog mysql-bin000093.sql &gt; slow_report10.log  单条 SQL 优化基本分析 通过上面的方法就可以找出系统里面所有的慢 SQL 语句了，并且在分析报告里面会排好序，剩下的就是我们针对每条 SQL 语句的分析调优工作了。针对 SQL 的具体优化方式内容很多，建议大家系统的学习，后面我也会写一些我常用的方法。这里说一下单条 SQL 的基础分析方法，好让大家有个开头。\n 查看 SQL 执行计划  EXPLAIN select ep_name as '企业名称', count(*) as '企业人数', FROM_UNIXTIME(ep_created/1000, GET_FORMAT(DATE,'ISO')) as '注册时间' from uc_member u left join uc_enterprise e on u.ep_id=e.ep_id where ep_domain='yq.vchangyi.com' and mem_status&lt;3 group by u.ep_id order by 企业人数 desc;\t 对于上面每一列的的意义这里不再详细介绍，有兴趣的同学可以查看 MySQL 文档，或者关注我后续的文章，会有专门介绍。\n 查询 SQL 执行信息  查看 MySQL 语句执行信息需要首先开启 profiling 选线\nset profiling = 1;  然后执行完 SQL 过后使用 show profiles; 语句查看执行 SQL 的记录id\nselect ep_name as '企业名称', count(*) as '企业人数', FROM_UNIXTIME(ep_created/1000, GET_FORMAT(DATE,'ISO')) as '注册时间' from uc_member u left join uc_enterprise e on u.ep_id=e.ep_id where ep_domain='yq.vchangyi.com' and mem_status&lt;3 group by u.ep_id order by 企业人数 desc; show profiles;  使用 show profile 查看 SQL 的执行信息\nshow profile ALL for query 3;  语法格式：\nshow profile [type] for query &lt;query_id&gt;;  如果没有指定 FOR QUERY 则显示最近一条查询的详细信息。type 是可选的，有以下几个选项：\n ALL 显示所有性能信息 BLOCK IO 显示块IO操作的次数 CONTEXT SWITCHES 显示上下文切换次数，不管是主动还是被动 CPU 显示用户CPU时间、系统CPU时间 IPC 显示发送和接收的消息数量 MEMORY [暂未实现] PAGE FAULTS 显示页错误数量 SOURCE 显示源码中的函数名称与位置 SWAPS 显示SWAP的次数 ", "content_s": "在 系统 刚 上线 的 时候 ， 经常 会 出现 慢   SQL   的 情况 ， 并且 有时 时候 有时候 系统 会 在 特定 的 时间 点 变慢 。 这个 时候 的 慢   SQL   查询 语句 往往 是 大量 出现 ， MySQL   的 慢 查询 日志 文件 也 会 比较 大 。 这个 时候 我们 往往 需要 从 哪些 查询 最 多 、 耗时 最长 的   sql   开始 优化 ， 以 提升 我们 的 处理 效益 。 这个 时候 就 需要 我们 能 对 慢 日志 进行 统计 计分 分析 统计分析 ， 在 上   M   ， 甚至   几十   M   的 日志 文件 里面 使用 手工 的 方式 明显 是 不 可能 的 ， 这个 时候 就 需要 有 专门 的 统计 计分 分析 统计分析 工具 来 帮 我们 做 统计 、 分析 哪些 慢 查询 日志 。 percona - toolkit   就是 一个 提供 统计 和 分析 的 工具 工具集 ， 这里 重点 介绍 里面 的   pt - query - digest   工具 。 \n \n percona - toolkit   安装   percona - toolkit   首页   文档   下载 地址 \n mac   安装   可以 使用   brew   直接 安装 \n brew   install   percona - toolkit     Linux   安装   详细 信息 详细信息 参考   官方 安装 文档 \n 源码 安装   #   下载 源码   wget   https : / / www . percona . com / downloads / percona - toolkit / 3.0 . 8 / source / tarball / percona - toolkit - 3.0 . 8 . tar . gz   #   解压   tar   xf   percona - toolkit - 3.0 . 8 . tar . gz   # 进入 目录 安装   cd   percona - toolkit - 3.0 . 8   # 开始 编译 安装   perl   Makefile . PL   make   make   install   # 安装 完 了 就 有 命令 了   ll   / usr / local / bin / pt - *     pt - query - digest   基本 使用   在 使用   pt - query - digest   前 需要 有   MySQL   慢 查询 日志 文件 ， 这里 为了 大家 方便 实验 提供 了 一份   MySQL   慢 查询 日 实验 数据   供 大家 下载 测试 （ slow - sql - test . sql . zip   点击 我 下载 ， 里面 包含 2018.04 . 01 ～ 2018.04 . 04   和   2018.04 . 06   的 日志 数据 ） 。 \n   查看 使用 帮助     & gt ;   pt - query - digest   - - help       默认 分析 参数     & gt ;   pt - query - digest   slow - sql - test . sql       总体 概要 信息 ： \n       信息 字 段   说明           Exec   Time   执行 时间       Lock   Time   锁 时间       Row   sent   发送 行 大小       Row   examine   检查 行 大小       Query   size   查询 大小       Rank   SQL   编号       Query   ID   查询   id       Response   time   sql   总共 执行 时间   和   时间 比例       Calls   sql   执行 次数       R / Call   sql   平均 每次 执行 时间       V / M         Item   sql   类型 和 涉及 到 的 表         单个   SQL   信息 ： \n   ​   分析 结果 说明 ： \n   分析 最近 一段 时间 段时间 一段时间 内 的 慢 查询     & gt ;   pt - query - digest   - - since = 12h   slow - sql - test . sql   #   最近   12   小时 的 慢 查询       分析 指定 时间 时间段 内 的 慢 查询     & gt ;   pt - query - digest   slow - sql - test . sql   - - since   ' 2018 - 04 - 01   09 : 30 : 00 '   - - until   ' 2018 - 04 - 02   10 : 00 : 00 '       分析 还有 指定 特征 的 慢 查询   SQL     & gt ;   pt - query - digest   - - filter   ' $ event - & gt ; { fingerprint }   = ~   m / ^ select / i '   slow - sql - test . sql       分析 针对 某个 用户 的 慢 查询     & gt ;   pt - query - digest   - - filter   ' ( $ event - & gt ; { member }   | |   & quot ; & quot ; )   = ~   m / ^ root / i '   slow - sql - test . sql       ​     pt - query - digest 进阶 使用   有时 时候 有时候 我们 会 遇到 针对 慢   SQL   进行 长期 的 跟踪 分析 ， 这个 时候 我们 就 需要 将 我们 的 每次 的 分析 结果 进行 汇总 、 对比 分析 。 同时 对于 部分 环境 我们 是 不能 直接 得到 慢   SQL   日志 的 ， 这个 时候 我们 可以 通过 抓取   TCP   协议 数据 或   binlog   进行 分析 \n   将 分析 结果 保存 到 数据 据库 数据库     & gt ;   pt - query - digest   - - user = root   – password = abc123   - - review   h = localhost , D = test , t = query _ review - - create - review - table   slow - sql - test . sql       通过 抓取   TCP   协议 数据 分析 数据分析     & gt ;   tcpdump   - s   65535   - x   - nn   - q   - tttt   - i   any   - c   1000   port   3306   & gt ;   mysql . tcp . txt   & gt ;   pt - query - digest   - - type   tcpdump   mysql . tcp . txt & gt ;   slow _ report9 . log       通过   binlog   日志 分析     & gt ;   mysqlbinlog   mysql - bin.000093   & gt ;   mysql - bin000093 . sql   & gt ;   pt - query - digest   - - type = binlog   mysql - bin000093 . sql   & gt ;   slow _ report10 . log     单条   SQL   优化 基本 分析   通过 上面 的 方法 就 可以 找出 系统 里面 所有 的 慢   SQL   语句 了 ， 并且 在 分析 报告 里面 会排 好序 ， 剩下 的 就是 我们 针对 每条   SQL   语句 的 分析 调优 工作 了 。 针对   SQL   的 具体 优化 方式 内容 很多 ， 建议 大家 系统 的 学习 ， 后面 我 也 会 写 一些 我 常用 的 方法 。 这里 说 一下 单条   SQL   的 基础 分析 方法 分析方法 ， 好 让 大家 有个 开头 。 \n   查看   SQL   执行 计划     EXPLAIN   select   ep _ name   as   ' 企业 名称 ' ,   count ( * )   as   ' 企业 人数 ' ,   FROM _ UNIXTIME ( ep _ created / 1000 ,   GET _ FORMAT ( DATE , ' ISO ' ) )   as   ' 注册 时间 '   from   uc _ member   u   left   join   uc _ enterprise   e   on   u . ep _ id = e . ep _ id   where   ep _ domain = ' yq . vchangyi . com '   and   mem _ status & lt ; 3   group   by   u . ep _ id   order   by   企业 人数   desc ; \t   对于 上面 每 一列 的 的 意义 这里 不再 详细 介绍 ， 有 兴趣 的 同学 可以 查看   MySQL   文档 ， 或者 关注 我 后续 的 文章 ， 会 有 专门 介绍 。 \n   查询   SQL   执行 信息     查看   MySQL   语句 执行 信息 需要 首先 开启   profiling   选线 \n set   profiling   =   1 ;     然后 执行 完   SQL   过后 使用   show   profiles ;   语句 查看 执行   SQL   的 记录 id \n select   ep _ name   as   ' 企业 名称 ' ,   count ( * )   as   ' 企业 人数 ' ,   FROM _ UNIXTIME ( ep _ created / 1000 ,   GET _ FORMAT ( DATE , ' ISO ' ) )   as   ' 注册 时间 '   from   uc _ member   u   left   join   uc _ enterprise   e   on   u . ep _ id = e . ep _ id   where   ep _ domain = ' yq . vchangyi . com '   and   mem _ status & lt ; 3   group   by   u . ep _ id   order   by   企业 人数   desc ;   show   profiles ;     使用   show   profile   查看   SQL   的 执行 信息 \n show   profile   ALL   for   query   3 ;     语法 格式 ： \n show   profile   [ type ]   for   query   & lt ; query _ id & gt ; ;     如果 没有 指定   FOR   QUERY   则 显示 最近 一条 查询 的 详细 信息 详细信息 。 type   是 可选 的 ， 有 以下 几个 选项 ： \n   ALL   显示 所有 性能 信息   BLOCK   IO   显示 块 IO 操作 的 次数   CONTEXT   SWITCHES   显示 上下 下文 上下文 切换 次数 ， 不管 是 主动 还是 被动   CPU   显示 用户 CPU 时间 、 系统 CPU 时间   IPC   显示 发送 和 接收 的 消息 数量   MEMORY   [ 暂未 实现 ]   PAGE   FAULTS   显示 页 错误 数量   SOURCE   显示 源码 中 的 函数 名称 与 位置   SWAPS   显示 SWAP 的 次数  ", "title_s": "mysql   查询 优化 ： 慢 查询 分析 工具   pt - query - digest"}, {"description": "", "objectID": "https://blog.threeq.me/post/db/mysql-sql-index-analyse-tool/", "tags": ["Mysql", "数据库", "查询优化"], "title": "mysql 查询优化：索引优化", "uri": "https://blog.threeq.me/post/db/mysql-sql-index-analyse-tool/", "content": "我们在产品中使用 MySQL 数据库的时候，肯定会用到索引的，或是在前期建立一些初始索引，或是在后期 SQL 优化的时候根据系统运行状态逐渐增加索引。不论是以什么方式建立的索引，他们都会影响我们对数据库做的操作，并且是对我们所有的数据操作都有影响，包括 增加、删除、修改、查询、统计 操作。这时如果线上有部分索引在系统升级已经失效了，我们怎么知道，怎么及时的排查和删除，需要我们持续的跟踪和分析。今天我就介绍几款针对线上数据库索引的分析工具。\n pt-index-usage userstat check-unused-keys  \n1. pt-index-usage pt-index-usage 从日志里面读取查询，并且分析它们是如何使用索引的。它需要 MySQL 的慢查询日志，在实际分析中我们可以讲 MySQL 的慢查询参数设置为 0 ，这样就可以得到所有的执行 SQL。\npt-index-uage 的安装请参考 [mysql 查询优化：慢查询分析工具 pt-query-digest]\n使用：\n&gt; pt-index-usage [OPTIONS] [FILES]  分析 slow.log 的所有查询语句，并打印报告\n&gt; pt-index-usage /path/to/slow.log --host localhost  不打印报告，同时把分析后的结果存入 percona 数据库\n&gt; pt-index-usage slow.log --no-report --save-results-database percona  详情参考 pt-index-uage 官方文档 和 使用手册 [pt-index-uage --help]\n2. userstat MySQL 设置：\nmysql&gt; SET GLOBAL userstat=ON; mysql&gt; SET GLOBAL `thread_statistics`=1; mysql&gt; SHOW GLOBAL VARIABLES LIKE &quot;userstat&quot;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | userstat | ON | +---------------+-------+ 1 row in set (0.00 sec)  查询客户端连接信息\nmysql&gt; SELECT * FROM INFORMATION_SCHEMA.CLIENT_STATISTICS\\G *************************** 1. row *************************** CLIENT: 10.1.12.30 TOTAL_CONNECTIONS: 20 CONCURRENT_CONNECTIONS: 0 CONNECTED_TIME: 0 BUSY_TIME: 93 CPU_TIME: 48 BYTES_RECEIVED: 5031 BYTES_SENT: 276926 BINLOG_BYTES_WRITTEN: 217 ROWS_FETCHED: 81 ROWS_UPDATED: 0 TABLE_ROWS_READ: 52836023 SELECT_COMMANDS: 26 UPDATE_COMMANDS: 1 OTHER_COMMANDS: 145 COMMIT_TRANSACTIONS: 1 ROLLBACK_TRANSACTIONS: 0 DENIED_CONNECTIONS: 0 LOST_CONNECTIONS: 0 ACCESS_DENIED: 0 EMPTY_QUERIES: 0 TOTAL_SSL_CONNECTIONS: 0  查询索引使用信息：\nmysql&gt; SELECT * FROM INFORMATION_SCHEMA.INDEX_STATISTICS WHERE TABLE_NAME='tables_priv'; +--------------+-----------------------+--------------------+-----------+ | TABLE_SCHEMA | TABLE_NAME | INDEX_NAME | ROWS_READ | +--------------+-----------------------+--------------------+-----------+ | mysql | tables_priv | PRIMARY | 2 | +--------------+-----------------------+--------------------+-----------+  查询表的使用信息：\nmysql&gt; SELECT * FROM INFORMATION_SCHEMA.TABLE_STATISTICS WHERE TABLE_NAME=``tables_priv``; +--------------+-------------------------------+-----------+--------------+------------------------+ | TABLE_SCHEMA | TABLE_NAME | ROWS_READ | ROWS_CHANGED | ROWS_CHANGED_X_INDEXES | +--------------+-------------------------------+-----------+--------------+------------------------+ | mysql | tables_priv | 2 | 0 | 0 | +--------------+-------------------------------+-----------+--------------+------------------------+  具体详情请参考文档：https://www.percona.com/doc/percona-server/5.7/diagnostics/user_stats.html\n3. check-unused-keys check-unused-keys 是 Ryan Lowe 编写的基于 userstat 的一个 perl 脚本。能够比较方便输出需要删除的索引。\n下载地址：https://code.google.com/archive/p/check-unused-keys/downloads / 备份地址\nMySQL 设置：\nmysql&gt; SET GLOBAL userstat=ON; mysql&gt; SET GLOBAL `thread_statistics`=1; mysql&gt; SHOW GLOBAL VARIABLES LIKE &quot;userstat&quot;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | userstat | ON | +---------------+-------+ 1 row in set (0.00 sec)  语法：\n&gt; ./check-unused-keys --help  使用：\n./check-unused-keys --host=127.0.0.1 --username=root --password=toor --port=3306 --create-alter  参考：\nhttps://www.percona.com/blog/2009/06/26/check-unused-keys-a-tool-to-interact-with-index_statistics/\nhttps://www.percona.com/blog/2008/09/12/googles-user_statistics-v2-port-and-changes/\nhttps://code.google.com/archive/p/check-unused-keys/\nhttps://www.percona.com/blog/2012/12/05/quickly-finding-unused-indexes-and-estimating-their-size/\nhttps://yq.aliyun.com/articles/308518\n", "content_s": "我们 在 产品 中 使用   MySQL   数据 据库 数据库 的 时候 ， 肯定 会 用到 索引 的 ， 或是 在 前期 建立 一些 初始 索引 ， 或是 在 后期   SQL   优化 的 时候 根据 系统 运行 状态 逐渐 增加 索引 。 不论 不论是 以 什么 方式 建立 的 索引 ， 他们 都 会 影响 我们 对 数据 据库 数据库 做 的 操作 ， 并且 是 对 我们 所有 的 数据 操作 都 有 影响 ， 包括   增加 、 删除 、 修改 、 查询 、 统计   操作 。 这时 如果 线上 有 部分 索引 在 系统 升级 系统升级 已经 失效 了 ， 我们 怎么 知道 ， 怎么 及时 的 排查 和 删除 ， 需要 我们 持续 的 跟踪 和 分析 。 今天 我 就 介绍 几款 针对 线上 数据 据库 数据库 索引 的 分析 工具 。 \n   pt - index - usage   userstat   check - unused - keys     \n 1 .   pt - index - usage   pt - index - usage   从 日志 里面 读取 查询 ， 并且 分析 它们 是 如何 使用 索引 的 。 它 需要   MySQL   的 慢 查询 日志 ， 在 实际 分析 中 我们 可以 讲   MySQL   的 慢 查询 参数 设置 参数设置 为   0   ， 这样 就 可以 得到 所有 的 执行   SQL 。 \n pt - index - uage   的 安装 请 参考   [ mysql   查询 优化 ： 慢 查询 分析 工具   pt - query - digest ] \n 使用 ： \n & gt ;   pt - index - usage   [ OPTIONS ]   [ FILES ]     分析   slow . log   的 所有 查询 语句 ， 打印 并打印 报告 \n & gt ;   pt - index - usage   / path / to / slow . log   - - host   localhost     不 打印 报告 ， 同时 把 分析 后 的 结果 存入   percona   数据 据库 数据库 \n & gt ;   pt - index - usage   slow . log   - - no - report   - - save - results - database   percona     详情 参考   pt - index - uage   官方 文档   和   使用 手册 使用手册   [ pt - index - uage   - - help ] \n 2 .   userstat   MySQL   设置 ： \n mysql & gt ;   SET   GLOBAL   userstat = ON ;   mysql & gt ;   SET   GLOBAL   ` thread _ statistics ` = 1 ;   mysql & gt ;   SHOW   GLOBAL   VARIABLES   LIKE   & quot ; userstat & quot ; ;   + - - - - - - - - - - - - - - - + - - - - - - - +   |   Variable _ name   |   Value   |   + - - - - - - - - - - - - - - - + - - - - - - - +   |   userstat   |   ON   |   + - - - - - - - - - - - - - - - + - - - - - - - +   1   row   in   set   ( 0.00   sec )     查询 客户 客户端 连接 信息 \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . CLIENT _ STATISTICS \\ G   * * * * * * * * * * * * * * * * * * * * * * * * * * *   1 .   row   * * * * * * * * * * * * * * * * * * * * * * * * * * *   CLIENT :   10.1 . 12.30   TOTAL _ CONNECTIONS :   20   CONCURRENT _ CONNECTIONS :   0   CONNECTED _ TIME :   0   BUSY _ TIME :   93   CPU _ TIME :   48   BYTES _ RECEIVED :   5031   BYTES _ SENT :   276926   BINLOG _ BYTES _ WRITTEN :   217   ROWS _ FETCHED :   81   ROWS _ UPDATED :   0   TABLE _ ROWS _ READ :   52836023   SELECT _ COMMANDS :   26   UPDATE _ COMMANDS :   1   OTHER _ COMMANDS :   145   COMMIT _ TRANSACTIONS :   1   ROLLBACK _ TRANSACTIONS :   0   DENIED _ CONNECTIONS :   0   LOST _ CONNECTIONS :   0   ACCESS _ DENIED :   0   EMPTY _ QUERIES :   0   TOTAL _ SSL _ CONNECTIONS :   0     查询 索引 使用 信息 ： \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . INDEX _ STATISTICS   WHERE   TABLE _ NAME = ' tables _ priv ' ;   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +   |   TABLE _ SCHEMA   |   TABLE _ NAME   |   INDEX _ NAME   |   ROWS _ READ   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +   |   mysql   |   tables _ priv   |   PRIMARY   |   2   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +     查询 表 的 使用 信息 ： \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . TABLE _ STATISTICS   WHERE   TABLE _ NAME = ` ` tables _ priv ` ` ;   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +   |   TABLE _ SCHEMA   |   TABLE _ NAME   |   ROWS _ READ   |   ROWS _ CHANGED   |   ROWS _ CHANGED _ X _ INDEXES   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +   |   mysql   |   tables _ priv   |   2   |   0   |   0   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +     具体 详情 详情请 参考 文档 ： https : / / www . percona . com / doc / percona - server / 5.7 / diagnostics / user _ stats . html \n 3 .   check - unused - keys   check - unused - keys   是   Ryan   Lowe   编写 的 基于   userstat   的 一个   perl   脚本 。 能够 比较 方便 输出 需要 删除 的 索引 。 \n 下载 地址 ： https : / / code . google . com / archive / p / check - unused - keys / downloads   /   备份 地址 \n MySQL   设置 ： \n mysql & gt ;   SET   GLOBAL   userstat = ON ;   mysql & gt ;   SET   GLOBAL   ` thread _ statistics ` = 1 ;   mysql & gt ;   SHOW   GLOBAL   VARIABLES   LIKE   & quot ; userstat & quot ; ;   + - - - - - - - - - - - - - - - + - - - - - - - +   |   Variable _ name   |   Value   |   + - - - - - - - - - - - - - - - + - - - - - - - +   |   userstat   |   ON   |   + - - - - - - - - - - - - - - - + - - - - - - - +   1   row   in   set   ( 0.00   sec )     语法 ： \n & gt ;   . / check - unused - keys   - - help     使用 ： \n . / check - unused - keys   - - host = 127.0 . 0.1   - - username = root   - - password = toor   - - port = 3306   - - create - alter     参考 ： \n https : / / www . percona . com / blog / 2009 / 06 / 26 / check - unused - keys - a - tool - to - interact - with - index _ statistics / \n https : / / www . percona . com / blog / 2008 / 09 / 12 / googles - user _ statistics - v2 - port - and - changes / \n https : / / code . google . com / archive / p / check - unused - keys / \n https : / / www . percona . com / blog / 2012 / 12 / 05 / quickly - finding - unused - indexes - and - estimating - their - size / \n https : / / yq . aliyun . com / articles / 308518 \n", "title_s": "mysql   查询 优化 ： 索引 优化"}, {"description": "", "objectID": "https://blog.threeq.me/post/git-branch-flow/", "tags": ["git"], "title": "Git 代码库分之管理", "uri": "https://blog.threeq.me/post/git-branch-flow/", "content": "代码版本库使用git管理，以下是git版本使用规范\n流程图说明 \n分支使用说明    分支名称 名字 说明 实例     master 线上分支 不用于开发，使用tag功能标记版本。只能由beta和hotfix合并，合并同时打上发布版本tag v1.0.2   beta 灰度分支组 灰度分之只能由test合并master产生，在测试通过后进入灰度阶段产生；灰度通过后合并进入master beta/sign   test(release) 测试分支组 只能用于测试和修改bug，只能由由master合并进feature产生。对于测试通过的test，使用merge合并方式合并master产生beta分之；合并后的release需要删除 test/sign; release/active   feature 功能分支组 从最新master检出用于开发一个新功能，一旦完成开发，合并master进入下一个test，删除本次feature分支；负责开发中多开发者代码同步使用 feature/news; feature/vote   topic 本地开发分支组 开发人员基于feature/release/hotfix检出自己本地开发(或修改bug)分支，在开发(或修改bug)中使用rebase合并方式和feature/release/hotfix进行同步。原则上一个feature/release/hotfix分支对应一个topic分支，开发完成的feature/release/hotfix删除对应的topic分支 topic/feature-news-wlp; topic/release-new-wlp; topic/hotfix-news-wlp   hotfix 修补分支组 对于线上紧急bug修改，产生一个hotfix分支，只能由master上的tag标签签出。修改完成的hotfix合并回master，并且必须删除 hotfix/v1.0.2     注意： 1. 个人开发分支除特殊情况，不允许提交到远程服务器中。\n 代码提交/合并说明 这个是开发人在日常开发中使用最多的操作。\n获取代码库 $ git clone &lt;版本库地址&gt; $ cd &lt;代码目录&gt; $ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt;  建立自己的本地开发分支 $ git checkout feature/&lt;功能分支&gt; $ git checkout -b topic/&lt;功能分支&gt;-&lt;你的标识&gt;  提交修改 $ git status $ git add . $ git commit -am '修改描述'  发布你的修改 $ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt; $ git rebase feature/&lt;功能分支&gt; # 这里可能会产生合并操作 $ git push origin topic/&lt;功能分支&gt;-&lt;你的标识&gt;:feature/&lt;功能分支&gt;  代码发布说明 发布代码是针对功能发布而定的，发布又分为测试发布和上线发布。对于发布操作，必须是先到测试环境(test)，再从测试环境(test)到灰度环境(beta)，最后从灰度环境(beta)到生产环境(master)，对于线上每次发布都必须有标签记录，可以回退。 原则上从beta到master只会产生 fast-forward 类型操作。以下所有操作都在自己的开发分支中完成。\n发布到测试环境 # 合并feature分支 $ git fetch origin master:master $ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt; $ git checkout feature/&lt;功能分支&gt; $ git merge master ~~解决冲突~~ # 生产test分支 $ git checkout -b test/&lt;功能分支&gt; $ git push origin test/&lt;功能分支&gt;: test/&lt;功能分支&gt; # 清理feature分支 $ git push origin :feature/&lt;功能分支&gt; $ git branch -D feature/&lt;功能分支&gt;  发布到灰度环境 # 合并master到测试 $ git fetch origin test/&lt;功能分支&gt;:test/&lt;功能分支&gt; $ git fetch origin master:master $ git checkout test/&lt;功能分支&gt; $ git merge master ~~解决冲突~~ # 生成beta分支 $ git checkout -b beta/&lt;功能分支&gt; $ git push origin beta/&lt;功能分支&gt;:beta/&lt;功能名称&gt; # 清理 test $ git push origin :test/&lt;版本&gt; $ git branch -D test/&lt;版本&gt;  发布到生产环境 # 合并到master $ git fetch origin beta/&lt;版本&gt;:beta/&lt;版本&gt; $ git fetch origin master:master $ git checkout master $ git merge beta/&lt;版本&gt; $ git tag -a &lt;发布版本号&gt; -m &quot;发布功能描述&quot; $ git push origin --tags $ git push origin master:master # 清理 beta $ git push origin :beta/&lt;版本&gt; $ git branch -D beta/&lt;版本&gt;  修改生产环境bug # 创建补丁版本，进行修改 $ git fetch origin --tag $ git checkout -b hotfix/&lt;版本号&gt; &lt;版本号&gt; # 修改完成发布 # 1. 合并到master $ git fetch origin master:master $ git checkout master $ git merge hotfix/&lt;版本号&gt; $ git tag -a &lt;发布版本号&gt; -m &quot;发布功能描述&quot; $ git push origin --tag $ git push origin master:master # 清理 hotfix $ git push origin :hotfix/&lt;版本号&gt; $ git branch -D hotfix/&lt;版本号&gt; ", "content_s": "代码 版本 库 使用 git 管理 ， 以下 是 git 版本 使用 规范 \n 流程 流程图 说明   \n 分支 使用 说明         分支 名称   名字   说明   实例           master   线上 分支   不 用于 开发 ， 使用 tag 功能 标记 版本 。 只能 由 beta 和 hotfix 合并 ， 合并 同时 打 上 发布 版本 tag   v1.0 . 2       beta   灰度 分支 组   灰度 分 之 只能 由 test 合并 master 产生 ， 在 测试 通过 测试通过 后 进入 灰度 阶段 产生 ； 灰度 通过 后 合并 进入 master   beta / sign       test ( release )   测试 分支 组   只能 用于 测试 和 修改 bug ， 只能 由 由 master 合并 进 feature 产生 。 对于 测试 通过 测试通过 的 test ， 使用 merge 合并 方式 合并 master 产生 beta 分 之 ； 合并 后 的 release 需要 删除   test / sign ;   release / active       feature   功能 分支 组   从 最新 master 检出 用于 开发 一个 新 功能 ， 一旦 完成 开发 ， 合并 master 进入 下 一个 test ， 删除 本次 feature 分支 ； 负责 开发 中多 开发 开发者 代码 同步 使用   feature / news ;   feature / vote       topic   本地 开发 分支 组   开发 发人 人员 开发人员 基于 feature / release / hotfix 检出 自己 本地 开发 ( 或 修改 bug ) 分支 ， 在 开发 ( 或 修改 bug ) 中 使用 rebase 合并 方式 和 feature / release / hotfix 进行 同步 。 原则 原则上 一个 feature / release / hotfix 分支 对应 一个 topic 分支 ， 开发 完成 的 feature / release / hotfix 删除 对应 的 topic 分支   topic / feature - news - wlp ;   topic / release - new - wlp ;   topic / hotfix - news - wlp       hotfix   修补 分支 组   对于 线上 紧急 bug 修改 ， 产生 一个 hotfix 分支 ， 只能 由 master 上 的 tag 标签 签出 。 修改 完成 的 hotfix 合并 回 master ， 并且 必须 删除   hotfix / v1.0 . 2           注意 ：   1 .   个人 开发 分支 除 特殊 情况 ， 不 允许 提交 到 远程 服务 务器 服务器 中 。 \n   代码 提交 / 合并 说明   这个 是 开发 人 在 日常 开发 中 使用 最多 的 操作 。 \n 获取 代码 库   $   git   clone   & lt ; 版本 库 地址 & gt ;   $   cd   & lt ; 代码 目录 & gt ;   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;     建立 自己 的 本地 开发 分支   $   git   checkout   feature / & lt ; 功能 分支 & gt ;   $   git   checkout   - b   topic / & lt ; 功能 分支 & gt ; - & lt ; 你 的 标识 & gt ;     提交 修改   $   git   status   $   git   add   .   $   git   commit   - am   ' 修改 描述 '     发布 你 的 修改   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;   $   git   rebase   feature / & lt ; 功能 分支 & gt ;   #   这里 可能 会 产生 合并 操作   $   git   push   origin   topic / & lt ; 功能 分支 & gt ; - & lt ; 你 的 标识 & gt ; : feature / & lt ; 功能 分支 & gt ;     代码 发布 说明   发布 代码 是 针对 功能 发布 而定 的 ， 发布 又 分为 测试 发布 和 上线 发布 。 对于 发布 操作 ， 必须 是 先到 测试 环境 测试环境 ( test ) ， 再 从 测试 环境 测试环境 ( test ) 到 灰度 环境 ( beta ) ， 最后 从 灰度 环境 ( beta ) 到 生产 环境 ( master ) ， 对于 线上 每次 发布 都 必须 有 标签 记录 ， 可以 回退 。   原则 原则上 从 beta 到 master 只会 产生   fast - forward   类型 操作 。 以下 所有 操作 都 在 自己 的 开发 分支 中 完成 。 \n 发布 到 测试 环境 测试环境   #   合并 feature 分支   $   git   fetch   origin   master : master   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;   $   git   checkout   feature / & lt ; 功能 分支 & gt ;   $   git   merge   master   ~ ~ 解决 冲突 ~ ~   #   生产 test 分支   $   git   checkout   - b   test / & lt ; 功能 分支 & gt ;   $   git   push   origin   test / & lt ; 功能 分支 & gt ; :   test / & lt ; 功能 分支 & gt ;   #   清理 feature 分支   $   git   push   origin   : feature / & lt ; 功能 分支 & gt ;   $   git   branch   - D   feature / & lt ; 功能 分支 & gt ;     发布 到 灰度 环境   #   合并 master 到 测试   $   git   fetch   origin   test / & lt ; 功能 分支 & gt ; : test / & lt ; 功能 分支 & gt ;   $   git   fetch   origin   master : master   $   git   checkout   test / & lt ; 功能 分支 & gt ;   $   git   merge   master   ~ ~ 解决 冲突 ~ ~   #   生成 beta 分支   $   git   checkout   - b   beta / & lt ; 功能 分支 & gt ;   $   git   push   origin   beta / & lt ; 功能 分支 & gt ; : beta / & lt ; 功能 名称 & gt ;   #   清理   test   $   git   push   origin   : test / & lt ; 版本 & gt ;   $   git   branch   - D   test / & lt ; 版本 & gt ;     发布 到 生产 环境   #   合并 到 master   $   git   fetch   origin   beta / & lt ; 版本 & gt ; : beta / & lt ; 版本 & gt ;   $   git   fetch   origin   master : master   $   git   checkout   master   $   git   merge   beta / & lt ; 版本 & gt ;   $   git   tag   - a   & lt ; 发布 版本 版本号 & gt ;   - m   & quot ; 发布 功能 描述 & quot ;   $   git   push   origin   - - tags   $   git   push   origin   master : master   #   清理   beta   $   git   push   origin   : beta / & lt ; 版本 & gt ;   $   git   branch   - D   beta / & lt ; 版本 & gt ;     修改 生产 环境 bug   #   创建 补丁 版本 ， 进行 修改   $   git   fetch   origin   - - tag   $   git   checkout   - b   hotfix / & lt ; 版本 版本号 & gt ;   & lt ; 版本 版本号 & gt ;   #   修改 完成 发布   #   1 .   合并 到 master   $   git   fetch   origin   master : master   $   git   checkout   master   $   git   merge   hotfix / & lt ; 版本 版本号 & gt ;   $   git   tag   - a   & lt ; 发布 版本 版本号 & gt ;   - m   & quot ; 发布 功能 描述 & quot ;   $   git   push   origin   - - tag   $   git   push   origin   master : master   #   清理   hotfix   $   git   push   origin   : hotfix / & lt ; 版本 版本号 & gt ;   $   git   branch   - D   hotfix / & lt ; 版本 版本号 & gt ;  ", "title_s": "Git   代码 库分 之 管理"}, {"description": "", "objectID": "https://blog.threeq.me/post/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/gtd-flow/", "tags": ["GTD", "时间管理"], "title": "让网络更好为我们服务", "uri": "https://blog.threeq.me/post/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/gtd-flow/", "content": "你每天早上一醒来有没有立即想拿起手机赶紧看一下（facebook、twitter、微信），无论里面有没有信息都要打开一下才安心？并且在上班之前还要想办法挤出时间看一下各大新闻网站，查收邮件在各种邮件信息中找出今天需要处理的事情。并且在工作的时候，一出现一个消息弹框马上点击进去看，害怕自己遗漏哪怕一次消息。\n这些在一个信息爆炸的时代是正常的，被称为信息饥渴。其实出现这个情况是由于我们没有很好获取信息方式和管理信息方法。这篇文章就介绍如何更好的利用网络工具来为我们管理信息。 这里我先把这些网络工具分为：\n 信息产生工具\ngithub、facebook、twitter、rss博客、linkedin、微信服务号  信息收集转换器\nzapier、ifttt、smooch、feedly、pocket、buffer  时间/任务/信息管理工具（GTD）\nEvernote、todoist、kanbanflow、自己博客、bearychat、slack    作为一个有态度的程序员肯定是从我最爱的github开始了，我们在github上面肯定少不了有自己的开源代码，当有人给我们提交一个issue、发起一个pull request等信息时我们\ngithub --&gt; kanbanflow  我把看书作为一项任务来对待，在我看完一本书的时候自动在 Evernote 里面创建一个书评的待完成的笔记，并在 todolist 中建立一个任务放入到待计划中\nkanbanflow --&gt; Evernote --&gt; kanbanflow  对于facebook、twitter等社交工具中有新信息的时候，全部集中到 slack\nfacebook/twitter --&gt; slack  对于各种新闻信息进行快速过滤，对于感兴趣的放入到pocket,同时建立阅读任务；后面在整理pocket的时候需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。\npocket --&gt; todoist pocket --&gt; Evernote --&gt; kanbanflow  对于自己关注的新闻、博客、论坛等信息，订阅rss信息到feedly，如果有信息时自在todolist建立阅读任务；在阅读过程中需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。\nrss/feedly --&gt; kanbanflow rss/feedly --&gt; Evernote --&gt; kanbanflow  对于自己博客更新，会自动同步到twitter、facebook等账户中，并且保存到 Evernote\n自己博客 --&gt; facebook --&gt; twitter --&gt; Evernote  在工作中我们会用到 gitlab、jenkins 等工具，我把这些信息全都收集到 bearychat 中\ngitlab/jenkins --&gt; bearychat  ", "content_s": "你 每天 早上 一 醒来 没有 有没有 立即 想 拿 起 手机 赶紧 看 一下 （ facebook 、 twitter 、 微信 ） ， 无论 里面 没有 有没有 信息 都 要 打开 一下 才 安心 ？ 并且 在 上班 之前 还要 想 办法 挤出 时间 看 一下 各大 新闻 网站 ， 查收 邮件 在 各种 邮件 信息 中 找出 今天 需要 处理 的 事情 。 并且 在 工作 的 时候 ， 一 出现 一个 消息 弹框 马上 点击 进去 看 ， 害怕 自己 遗漏 哪怕 一次 消息 。 \n 这些 在 一个 信息 爆炸 的 时代 是 正常 的 ， 被 称为 信息 饥渴 。 其实 出现 这个 情况 是 由于 我们 没有 很 好 获取 取信 信息 获取信息 方式 和 管理 信息 方法 。 这 文章 篇文章 就 介绍 如何 更好 的 利用 网络 工具 网络工具 来 为 我们 管理 信息 。   这里 我 先 把 这些 网络 工具 网络工具 分为 ： \n   信息 产生 工具 \n github 、 facebook 、 twitter 、 rss 博客 、 linkedin 、 微信 服务 号     信息 收集 转换 转换器 \n zapier 、 ifttt 、 smooch 、 feedly 、 pocket 、 buffer     时间 / 任务 / 信息 管理 信息管理 工具 （ GTD ） \n Evernote 、 todoist 、 kanbanflow 、 自己 博客 、 bearychat 、 slack         作为 一个 有 态度 的 程序 程序员 肯定 是从 我 最 爱 的 github 开始 了 ， 我们 在 github 上面 肯定 不了 少不了 有 自己 的 开 代码 源代码 ， 当 有人 给 我们 提交 一个 issue 、 发起 一个 pull   request 等 信息 时 我们 \n github   - - & gt ;   kanbanflow     我 把 看书 作为 一项 任务 来 对待 ， 在 我 看 完一 本书 的 时候 自动 在   Evernote   里面 创建 一个 书评 的 待 完成 的 笔记 ， 并 在   todolist   中 建立 一个 任务 放入 到 待 计划 中 \n kanbanflow   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 facebook 、 twitter 等 社交 工具 中有 新 信息 的 时候 ， 全部 集中 到   slack \n facebook / twitter   - - & gt ;   slack     对于 各种 新闻 信息 进行 快速 过滤 ， 对于 感兴 兴趣 感兴趣 的 放入 到 pocket , 同时 建立 阅读 任务 ； 后面 在 整理 pocket 的 时候 需要 整理 笔记 的 时候 自动 在 Evernote 中 建立 需要 完善 的 整理 笔记 和 相关 todolit 任务 。 \n pocket   - - & gt ;   todoist   pocket   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 自己 关注 的 新闻 、 博客 、 论坛 等 信息 ， 订阅 rss 信息 到 feedly ， 如果 有 信息 时自 在 todolist 建立 阅读 任务 ； 在 阅读 过程 中 需要 整理 笔记 的 时候 自动 在 Evernote 中 建立 需要 完善 的 整理 笔记 和 相关 todolit 任务 。 \n rss / feedly   - - & gt ;   kanbanflow   rss / feedly   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 自己 博客 更新 ， 会 自动 同步 到 twitter 、 facebook 等 账户 中 ， 并且 保存 到   Evernote \n 自己 博客   - - & gt ;   facebook   - - & gt ;   twitter   - - & gt ;   Evernote     在 工作 中 我们 会 用到   gitlab 、 jenkins   等 工具 ， 我 把 这些 信息 全都 收集 到   bearychat   中 \n gitlab / jenkins   - - & gt ;   bearychat    ", "title_s": "让 网络 更好 为 我们 服务"}, {"description": "", "objectID": "https://blog.threeq.me/post/ci-cd-tool/", "tags": ["jenkins", "gerrit", "gitlab", "redmine", "CI/CD"], "title": "项目持续集成工具", "uri": "https://blog.threeq.me/post/ci-cd-tool/", "content": " 每个项目管理中都有自己的管理工具集合，这里分享一下我用过的工具集合，这里面有些工具的实践时间可能并不是很长时间，列在这里意味这下一个阶段的实践计划。同时也分享一下我自己在选择工具集合的时候考虑的点(关于每类工具如何比较它们最后做出选择我后面会慢慢补上)。在这里不会详细介绍每种工具的安装、连接和使用过程，如果后面有时间我会专门写这些工具的安装、配置和配合使用。 O 首先列出我认为在项目管理中比较重要的工具，同时这些也是我在实践中用得比较多的一套工具集：\n   工具 职责 描述     git  网上有个在线教程很好《pro git》中文版   gerrit 代码库服务器工具/代码审核工具 基于git的在线代码审查工具，围绕它建立代码审核平台和流程   gitlab 版本库展示平台 gitlab这里只作为代码展示平台和最终的发布代码库   jenkins 自动化持续集成平台 jenkins自动测试/集成/发布，围绕它建立可持续集成平台   redmine 任务管理平台/缺陷跟踪平台    sonar 代码质量报告聚合工具 围绕它搭建一个代码质量监控平台    关于上面工具的安装过程不做描述，不过个人建议可以把每个服务都做成docker容器，这样如果需要再次搭建环境就方便了。\n下面对这套工具集合的流程介绍 工具流程 整理流程 {% plantuml %} ACTOR 开发人员 control gerrit control jenkins ACTOR 审核人员 database sonar database gitlab control redmine\n开发人员-&gt;gerrit: 提交代码审核 gerrit-&gt;jenkins: 触发持续集成测试 jenkins-&gt;jenkins: 执行集成测试 jenkins-&gt;sonar: 收集代码质量报告 gerrit&lt;--jenkins: 返回测试结果 gerrit-&gt;审核人员: 通知人工审核 gerrit&lt;--审核人员: 人工审核反馈 gerrit-&gt;gerrit: 验证代码审核结果/代码合并 gerrit-&gt;gitlab: 合并的代码提交到gitlab gitlab-&gt;redmine: 自动更新redmine的缺陷 开发人员&lt;--gerrit: 通知开发人员审核结果  {% endplantuml %}\ngerrit代码审查流程 选择工具的思考 首先要明确一点：不论多么智能的工具，都是为我们程序员服务的，只是为我们提供一个更好工作的环境，让我们可以更愉快的coding。所以在选择一个项目的基础平台环境时，一定要考虑到项目团队的人员情况。\n* 平台工具集可以引导团队成员不断提高自己 * 方便团队任务分配、跟踪 * 团队成员可以随时随地，在自己想看代码的时候方便得到 * 代码质量可视化、可跟踪 * 一切和编码不相关的内容，尽量自动化 * 可持续集成 * 方便文档的编写  同时在项目中哪些方面是需要引入工具的呢？这个答案在每一个团队都会不一样，这里写一些我自己的想法：\n* 代码管理环境 * 任务/缺陷管理环境 * 自动化测试/持续集成环境 * 代码质量监控环境 * 文档编辑环境 * 协作/沟通环境 * 集成开发环境  下面我会对这几方面的工具进行一个简单的考量，说明我自己在这方面的考虑点，但是不会做非常细致的比较，原因有2个： 1. 有很多工具我自己也没有亲身使用过； 2. 每个人或团队对工具的思考都会不同，同时网上有很多的关于它们比拼的文章，最重要的是自己的使用感受和思考\n代码管理环境 代码版本库的管理我相信这个大家都会用工具来管理（如果你还没有使用版本库管理或者还在自己手动管理，我只能呵呵。。。了）。对于不同的版本控制需求，我们需要不同的管理策略，当然这个和团队的协作方式有很大的关系。同时现在的代码版本管理工具也很多：VSS、SVN、GIT、CVS(完全可以用SVN代替)、ClearCase等。那对于代码管理环境需要考虑那些因素： * 安全性(如果你是开源的忠诚粉丝，可以完全忽略这个) * 易用性 * 总体成本 * 技术支持 * 周边产品（衍生工具/其他产品集成工具） * 是否离线操作（这个这里作为考虑条件是因为网络有时确实是一个坑,不解释） * 支持代码审查\n这里我主要比较了git和svn。VSS支持平台有限（感觉只有win）果断干掉（我不好意思让兄弟们把mac换成win吧，呵呵。。。）；ClearCase看到网上介绍感觉功能很强大的，但是看了一下价格果断干掉（原因不要深究。。。）。\nGIT git这个现在很火，用的人很多，包括我自己现在也是完全使用这个。\n 安全性\n 使用这个可以说你的代码都没有什么安全性了(一些专业的git服务器除外)，他对安全性的控制你完全可以忽略。这个也没有办法，谁让他的作者就是开源狂热份子呢 由于他们分布式管理方式，任何一个开发人员本地都有一份完整的代码库克隆，所以任何一个人员或服务器损坏了，也不会对开发有任何影响，同时找回来也是非常方便的，基本不用成本  易用性\n 这个可能就要因人而已了，如果之前对命令行的模式比较熟悉，那这个基本上就没有任何学习曲线了，只是自己的命令集合里面多了一个叫git的命令而已；但是对于之前比较习惯图形界面的童鞋就有学习成本了(实际上从我和兄弟们的使用情况来看，其实不是学习git命令花费时间，而是要让自己习惯命令行工作方式)，不过成本其实是很低的，比如我们团队的兄弟们在一周之内都实用的很溜了(这里给兄弟们赞一个)。 后面就是关于分支的管理、合并、冲突的解决等协作方面的问题，这个从我个人的使用来看问题基本不大，只要把网上的那本《pro git》跟着操作完成，你能需要遇到的问题基本OK了。 最后就是规划团队的代码管理流程了，让代码版本管理在团队不断扩大、项目越来越多的过程中不至于失控 还有一个不经常会用到的操作，就是迁移代码库。这个对于git来说就太容易了，就是2、3个命令的事  总体成本\n 因为是开源的，所以从软件费用来说是0成本 剩下的就是我们自己搭建服务器的成本了，如果感觉自己服务器也不想出，那就找网上的云服务就好了，所以这个成本也是相对叫低的了。这里列举几个我用过的：github、coding.net、Git@OSC具体谁更适合你，都去用一边就好了 最后就是团队的学习成本了，从我在易用性里面介绍，我感觉一个团队学习的成本不会超过1周 同时git的周边产品大多都是免费的或者提供免费版本，所以他的配套产品成本其实很低  技术支持\n 开源的东西就只有社区，这个不要想太多，任何东西都需要你自己去发现，当然如果你选择三方平台，他们会有服务器平台部分支持的  周边产品\n 现在基于git的衍生产品太多了，上面所列举的都是，随便baidu和google都是一大把 其他平台对于git的支持我个人感觉很不错，不论是IDE、持续集成环境、bug跟踪系统都有响应的插件支持git版本库  离线操作\n 这个离线操作也是我之前考虑使用它的一个重要原因，每个人只需要在本地编写好、提交好你的代码，然后找一个网络环境的地方，把代码同步一下就好了   SVN(有这个没有必要CVS了) svn现在用的团队很多，是一种集中式版本管理工具，我之前也是用这个很长一段时间。\n 安全性\n svn的目标就管理团队代码，所以可以很精确的控制每个人远能访问的权限，目录分支等 由于是集中式管理，所以svn服务器千万不能挂掉，如果挂了大家都不能工作了，同时找回代码也是一件费劲的事情  易用性\n svn提供图形化客户端(非linux系统)，所以大家看一下就可以使用了 svn分支、合并、冲突解决都是图形化操作，大家用起来问题不大 大家都习惯了图形操作的方式，所以学习很快 但是在团队不断变大、项目越来越多的时候，对svn的管理就需要有点技巧了  总体成本\n svn软件本身是免费的，所以软件本身费用是0成本 如果自己搭建服务器，那就需要服务器成本了，不过你可以选择网上云服务，如google代码库（国内的就别想了）、svn china、RiouxSVN等。因为我自己以前只使用过google，所以对这些云服务需要自己去体验了 团队学习我们忽略吧 svn的目标毕竟是代替老牌的cvs，周边产品的支持那是杠杠的，其他和软件开发相关的环境和平台，肯定都是支持svn的，如果你选择的基础环境工具中还有不支持svn的，那肯定是你出问题了。但是很多优秀svn的周边产品都是需要收费的  技术支持\n 社区绝对是一个神奇的存在，你遇到的问题，肯定有人解决了，至少我当时是这样的 同时可以买专业的svn产品，这样可以得到专业团队的技术支持，当然这个成本肯定是有的  周边产品\n 刚刚就说了它的目标是代替老牌的cvs，所以周边产品自然不用说，只是成本的问题  离线操作\n 这个是我当时最郁闷的一点，如果你没有网络，你就不能提交了。很不好做历史记录管理   git服务器 这里只介绍git版本库管理中其他的思考。只介绍git是因为我现在使用的git，其实是之前在使用svn的时候没有考虑那么多，自己也没有好好去研究svn的一套体系。\n要使用git作为团队代码管理，就需要git服务器（当然对那些单兵作战的兄弟们，最好也有一个git服务器，这样至少可以做到你在哪里都可以作战）。这里git服务器的选择就有两种方式了：1、使用三方托管平台；2、自己搭建git服务器。这里主要讨论第2种方式，自家搭建服务器。\ngit是基于ssh的，所以如果不要复杂功能只需要一个git-shell就可以是服务器了，不过我们可不想重复找轮子，别人已经弄好的工具，我们为什么不直接用呢！！！Gitosis、 Gitolite（这个东西的权限管理很不错）等。如果要高级功能的(如：web访问)，那gitlab和gerrit（下载需要翻墙）将是不二之选。这里我同时选用了2者，它们的不同在于gerrit是一个更偏向代码审查工具和权限控制。虽然gitlab也可以做代码审查，但是gerrit是做提交前审查，同时对代码权限的控制更细力度；而gitlab是代码提交后审查，同时必须有开发人员手动发起审查，不能自动发起审查操作。这导致他们两个的操作流程有很大区别。我个人更倾向于gerrit的方式，这样可以强迫大家把自己的代码质量提上去，所以我这里选择了两者结合，gerrit这里做权限和质量把控，gitlab做为集成测试和发布版本库。\n任务/缺陷管理环境 缺陷跟踪系统redmine、Bugzilla、BugZero、Trac、jira、trello、bugfree、禅道、coding.net等，现在不论是收费的还是免费的都有很多，我相信任何一个都能解决bug跟踪问题。从我的使用过程中发现这些系统都有各自的有点，同时也有很多不足的地方，最终一个工具是不是符合你们团队，只有试用过才知道。以下是我在使用过程中发现的一些特点，感觉如果从这些点出发去试用和思考一个系统或工具，可以很快判断这个系统或工具是否适合团队，里面有些特性是我使用过的工具里面都没有的，但是这些特点我感觉确实很有用：\n 跨平台客户端（现在大多是web，这个大部分都满足） 可以和其他种类系统集成（如：代码库，测试平台、持续集成环境等） 界面易操作性 多项目管理 自定义流程 当然成本决定算一个 系统更新速度 支持多种开发模式 分级统计功能 移动端支持  持续集成环境 持续集成环境对团队和项目的自动化有一定要求，同时可以也是对团队自动化的一种推进；同时对团队的开发流程和编码风格都会有推动作用。当然至于用什么工具那是其次的，总点是要让团队养成持续集成的习惯和节奏。\n持续集成至应该做到一下几点：\n 自动构建：要求无人值守，如果人工来操作，那就没有持续集成的必要了 发现版本库的变更：通过轮询或者定时，或者程序员使用命令，处罚持续集成发现版本库的变更 反馈机制：在出现问题时，能及时的把问题反馈给正确的人（提交者、测试者、管理者） 回滚：在出现问题后，拥有回滚到可交付的能力 纯净的构建环境：每一次都应该把之前的环境删除干净，让每一次构建都是一个新的构建 完善的集成功能：代码的测试，审查都应该做到完善。如果单纯的利用它做持续的编译，那就是大材小用了 为了避免每次过多出现问题的构建，开发者在提交代码的时候，最好在本地独立的构建一次。可以自行运行构建脚本，模拟构建 由于数据库与编码的分离，最好把数据库相关的DDL\\DML等脚本一起放入版本库中，这样CI进行构建的时候，可以连同数据库一起重新构建 能和我们的代码管理库、任务/缺陷跟踪等其他平台交互  推荐书籍《持续集成：软件质量改进和风险降低之道》\n集成工具：jenkins（前身是Hudson）、gitlab-ci、Apache Continuum、CruiseControl、Luntbuild、drone、shippable\n集成的配置是必不可少的，就是让你定义如何集成构建的构建脚本啦，如果没有一个可配置的构建过程，那持续集成从何说起呢。ant、maven、gradle、make、shell\n由于集成是基于测试之上的，所以一个好的测试工具比不可少，但是这个和团队使用的语言息息相关，每中语言都有自己的测试工具。简单举例已达到抛砖引玉的效果：各种Unit（Junit，HtmlUnit，cppUnit，SQLUnit等）、karma、mocha。。。（手软&gt;_&lt;）\n自动代码审查是提高代码质量，养成代码习惯比可少的，同时这些事情可以自动的做掉，可以让我们更加关注于我们的代码 checkstyle、javaNcss、PMD、siminan、jsHint、jsLint、Emma。。。\n集成反馈和报告这个可以让我们可以实时得到集成结果，失败快速找原因，成功我们就可以安心睡觉了。邮件通知、Jabber、JSCoverage、GCOV、python coverage、JCoverage、Cobertura。。。\n代码质量监控环境 代码质量监控平台其实就是让我们的代码质量可视化、可管理，让我们的代码质量形成历史记录。同时可以非常方便的工全部人员查看。\n 质量可视化 跟踪质量走向（需要历史记录） 可以自动从持续集成环境、代码审查中搜集质量信息 可以和代码管理环境打通，这个的目的是最好能看到每个人代码质量 可以和其他工程管理工具打通  SonarQube、前面介绍的自动代码审查工具\n文档编辑环境 我们的程序员往往都不喜欢写文档，你让他写文档，还不如让他写2倍的代码。但是文档确是我们项目中不可缺少的部分，那怎么让我们的程序员可以高效的写文档呢！其实我们程序员在写文档的时候，往往是被文档的格式所折磨，不能专心的写内容，从而出发对写文档的抵触情绪。所以结合以上我任务文档编写环境应该有一下几点：\n 不用关心格式，重点在内容，格式自动 能从代码中自动生成文档 文档能实时共享、自动共享，像现在用的邮件、QQ之类的其实很影响心情 文档格式足够简单，在写的时候要做到双手不脱离键盘最好  markdown、各种语言doc工具了（jsdoc、javadoc等）、wiki、shpinx\n沟通环境 上面所说的说有东西的最终目的其实都是为了解决我们协作的问题，至少是或多或少都会涉及到协作沟通问题。像现在大家用的最多的沟通工具应该变成QQ、微信之类的了吧，加上邮件、电话、各种协作平台或者其他通讯工具，但是这些工具都有一个特点：在使用的时候都会有一个长时间打断我们思维，或者需要我们专门准备一个时间去做；这些其实都会造成浪费。其实最有效的沟通就是面对面交流，所以构建一个良好的沟通环境，对我们的项目进度起着至关重要的作用：\n 沟通资源随手可得（易于获得），可以在30秒内获得 兄弟们可以采取自己认为高效的方式沟通，同时沟通方式的资源易于获得 沟通历史和结果易于记录，最好能在不察觉的情况下记录起来  项目开发环境 项目开发环境可以分为：工程管理工具和工程开发工具。项目开发环境每个团队都有差别，同时团队内部每个人肯定都有差异，因为它受到的影响因数最多，比如：使用语言，工作内容，个人习惯，操作系统，可能还和心情有关等。因此团队在选择项目开发环境的时候，既要根据团队的定位选定基础开发环境（工程管理工具），同时出一些选择辅助开发环境的选择指导规则；也要考虑每个成员的习惯，开放出来辅助开发环境，让每个成员可以根据自己的习惯，选择一套他自己最高效的项目开发环境集合。下面我列举我认为在选择工程管理工具和工程开发工具应该具备的几点特征：\n工程管理工具  可以和工程开发工具高效集成 可以测试 可以做质量检查 可以和质量管理系统集成  ant，maven，gradle，gulp，grunt，make，cmake。。。\n项目开发工具 项目开发工具也叫做集成开发环境，很多集成开发环境都带有自己的工程管理工具\n 可以和代码管理工具集成 测试必须 可以做本地质量检查 可以方便实现重构手法，关于重构推荐《重构：改变既有代码设计》 最好能和缺陷跟踪系统集成 可以和工程管理工具集成  eclipse、webstorm、vs、idea等\n需求/产品管理环境 对于需求/产品管理环境我自己现在还没有在具体项目中实践过，所以这里就不在阐述了，如果你有好的想法可以给我留言，或者给我连接地址，我连接过去\n测试管理环境 测试管理环境其实应该在持续集成环境里面，但是由于上面写持续集成环境的时候过于偏向开发人员的使用角度介绍了，并且这两套系统确实也是独立存在的。这个测试管理环境更多面向于测试人员，而我认为测试工具本身也是分为测试管理工具和测试执行工具两类别，所以我会从测试管理和测试执行两个方面来说我观点（这里的划分是按照工具的分类划分，并不是按照软件方法的方式划分），同时对于测试我想后面会有专门的一篇文章来介绍，所以这里就这样了，大家见谅我的不专业\n测试管理工具 测试管理我认为比较重要的是：测试计划，测试用例，测试跟踪，缺陷管理(这个和任务/缺陷管理环境一样)\n 可以管理测试计划 可以管理测试用例 可以跟踪每个测试用例的状态 可以和缺陷系统集成 可以和持续集成系统集成  QC(Quality Center)，TestLink，oKit，TD（TestDirector）上面提到的缺陷管理系统\n测试执行工具 测试执行的方式都很多了，并且测试执行种类也很多，比如：自动化测试，性能测试，安全测试，白盒测试等。这里面不同的测试方式所使用的工具都是不一样的：\nselenium，jmeter，jprofile，Wireshark，AppCan，Metasploit，Nmap，Acunetix，Burp Suite，apache ab，Gatling\n还是那句话工具只能给我们提供一个更专心、更快速做事的环境，但是最终这个事情能不能做成、能不能做好完全是取决我们自己。所以不论使用任何工具都行，前提是我们有自己提高的意识和习惯，比如：编码风格、编程习惯、测试习惯、重构习惯、沟通能力、协作能力等，这些才是真真决定项目成败的关键。\n", "content_s": "  每个 项目 管理 项目管理 中 都 有 自己 的 管理 理工 工具 管理工具 集合 ， 这里 分享 一下 我用 过 的 工具 集合 ， 这 里面 有些 工具 的 实践 时间 可能 并 不是 很 时间 长时间 ， 列 在 这里 意味 这下 一个 阶段 的 实践 计划 。 同时 也 分享 一下 我 自己 在 选择 工具 集合 的 时候 考虑 的 点 ( 关于 每 类 工具 如何 比较 它们 最后 做出 选择 我 后面 会 慢慢 补 上 ) 。 在 这里 不会 详细 介绍 每种 工具 的 安装 、 连接 和 使用 过程 ， 如果 后面 有 时间 我会 专门 写 这些 工具 的 安装 、 配置 和 配合 使用 。   O   首先 列出 我 认为 在 项目 管理 项目管理 中 比较 重要 的 工具 ， 同时 这些 也 是 我 实践 在实践中 用 得 比较 多 的 一套 工具 工具集 ： \n       工具   职责   描述           git     网上 有个 在线 教程 在线教程 很 好 《 pro   git 》 中文 文版 中文版       gerrit   代码 库 服务 务器 服务器 工具 / 代码 审核 工具   基于 git 的 在线 代码 审查 工具 ， 围绕 它 建立 代码 审核 平台 和 流程       gitlab   版本 库 展示 平台   gitlab 这里 只 作为 代码 展示 平台 和 最终 的 发布 代码 库       jenkins   自动 自动化 持续 集成 平台   jenkins 自动 测试 自动测试 / 集成 / 发布 ， 围绕 它 建立 可 持续 集成 平台       redmine   任务 管理 平台 / 缺陷 跟踪 平台         sonar   代码 质量 报告 聚合 工具   围绕 它 搭建 一个 代码 质量 监控 平台         关于 上面 工具 的 安装 过程 不 做 描述 ， 不过 个人 建议 可以 把 每个 服务 都 做成 docker 容器 ， 这样 如果 需要 再次 搭建 环境 就 方便 了 。 \n 下面 对 这套 工具 集合 的 流程 介绍   工具 流程   整理 流程   { %   plantuml   % }   ACTOR   开发 发人 人员 开发人员   control   gerrit   control   jenkins   ACTOR   审核 人员   database   sonar   database   gitlab   control   redmine \n 开发 发人 人员 开发人员 - & gt ; gerrit :   提交 代码 审核   gerrit - & gt ; jenkins :   触发 持续 集成 测试   jenkins - & gt ; jenkins :   执行 集成 测试   jenkins - & gt ; sonar :   收集 代码 质量 报告   gerrit & lt ; - - jenkins :   返回 测试 结果   gerrit - & gt ; 审核 人员 :   通知 人工 审核   gerrit & lt ; - - 审核 人员 :   人工 审核 反馈   gerrit - & gt ; gerrit :   验证 代码 审核 结果 / 代码 合并   gerrit - & gt ; gitlab :   合并 的 代码 提交 到 gitlab   gitlab - & gt ; redmine :   自动 更新 自动更新 redmine 的 缺陷   开发 发人 人员 开发人员 & lt ; - - gerrit :   通知 开发 发人 人员 开发人员 审核 结果     { %   endplantuml   % } \n gerrit 代码 审查 流程   选择 工具 的 思考   首先 要 明确 一点 ： 不论 多么 智能 的 工具 ， 都 是 为 我们 程序 程序员 服务 的 ， 只是 为 我们 提供 一个 更好 工作 的 环境 ， 让 我们 可以 更 愉快 的 coding 。 所以 在 选择 一个 项目 的 基础 平台 环境 时 ， 一定 要 考虑 到 项目 团队 的 人员 情况 。 \n *   平台 工具 工具集 可以 引导 团队 成员 不断 提高 自己   *   方便 团队 任务 分配 任务分配 、 跟踪   *   团队 成员 可以 随时 随地 随时随地 ， 在 自己 想 看 代码 的 时候 方便 得到   *   代码 质量 可视 可视化 、 可 跟踪   *   一切 和 编码 不 相关 的 内容 ， 尽量 自动 自动化   *   可 持续 集成   *   方便 文档 的 编写     同时 在 项目 中 哪些 方面 哪些方面 是 需要 引入 工具 的 呢 ？ 这个 答案 在 每 一个 团队 都 会 不 一样 ， 这里 写 一些 我 自己 的 想法 ： \n *   代码 管理 环境   *   任务 / 缺陷 管理 环境   *   自动 自动化 测试 / 持续 集成 环境   *   代码 质量 监控 环境   *   文档 编辑 环境   *   协作 / 沟通 环境   *   集成 开发 环境     下面 我会 对 这 几 方面 的 工具 进行 一个 简单 的 考量 ， 说明 我 自己 在 这方 方面 这方面 的 考虑 点 ， 但是 不会 做 非常 细致 的 比较 ， 原因 有 2 个 ：   1 .   有 很多 工具 我 自己 也 没有 亲身 使用 过 ；   2 .   每个 人 或 团队 对 工具 的 思考 都 会 不同 ， 同时 网上 有 很多 的 关于 它们 比拼 的 文章 ， 最 重要 的 是 自己 的 使用 感受 和 思考 \n 代码 管理 环境   代码 版本 库 的 管理 我 相信 这个 大家 都 会 用 工具 来 管理 （ 如果 你 还 没有 使用 版本 库 管理 或者 还 在 自己 手动 管理 ， 我 只能 呵呵 。 。 。 了 ） 。 对于 不同 的 版本 控制 版本控制 需求 ， 我们 需要 不同 的 管理 策略 管理策略 ， 当然 这个 和 团队 的 协作 方式 有 很大 的 关系 。 同时 现在 的 代码 版本 管理 理工 工具 管理工具 也 很多 ： VSS 、 SVN 、 GIT 、 CVS ( 完全 可以 用 SVN 代替 ) 、 ClearCase 等 。 那 对于 代码 管理 环境 需要 考虑 那些 因素 ：   *   安全 安全性 ( 如果 你 是 开源 的 忠诚 粉丝 ， 可以 完全 忽略 这个 )   *   易用 易用性   *   总体 成本   *   技术 支持 技术支持   *   周边 产品 周边产品 （ 衍生 工具 / 其他 产品 集成 工具 ）   *   是否 离线 操作 （ 这个 这里 作为 考虑 条件 因为 是因为 网络 有时 确实 是 一个 坑 , 不 解释 ）   *   支持 代码 审查 \n 这里 我 主要 比较 了 git 和 svn 。 VSS 支持 平台 有限 （ 感觉 只有 win ） 果断 干掉 （ 我 不好 好意 意思 好意思 不好意思 让 兄弟 们 把 mac 换成 win 吧 ， 呵呵 。 。 。 ） ； ClearCase 看到 网上 介绍 感觉 功能 很 强大 的 ， 但是 看 了 一下 价格 果断 干掉 （ 原因 不要 深究 。 。 。 ） 。 \n GIT   git 这个 现在 很火 ， 用 的 人 很多 ， 包括 我 自己 现在 也 是 完全 使用 这个 。 \n   安全 安全性 \n   使用 这个 可以 说 你 的 代码 都 没有 什么 安全 安全性 了 ( 一些 专业 的 git 服务 务器 服务器 除外 ) ， 他 对 安全 安全性 的 控制 你 完全 可以 忽略 。 这个 也 没有 办法 ， 谁 让 他 的 作者 就是 开源 狂热 份子 呢   由于 他们 分布 布式 分布式 管理 方式 ， 任何 一个 开发 发人 人员 开发人员 本地 都 有 一份 完整 的 代码 库 克隆 ， 所以 任何 一个 人员 或 服务 务器 服务器 损坏 了 ， 也 不会 对 开发 有 任何 影响 ， 同时 找 回来 也 是 非常 方便 的 ， 基本 不用 成本     易用 易用性 \n   这个 可能 就要 因 人 而已 了 ， 如果 之前 对 命令 命令行 的 模式 比较 熟悉 ， 那 这个 基本 基本上 就 没有 任何 学习 曲线 学习曲线 了 ， 只是 自己 的 命令 集合 里面 多 了 一个 叫 git 的 命令 而已 ； 但是 对于 之前 比较 习惯 图形 界面 图形界面 的 童鞋 就 有 学习 成本 了 ( 实际 实际上 从 我 和 兄弟 们 的 使用 情况 来看 ， 其实 不是 学习 git 命令 花费 时间 ， 而是 要 让 自己 习惯 命令 命令行 工作 方式 ) ， 不过 成本 其实 是 很 低 的 ， 比如 我们 团队 的 兄弟 们 在 一周 之内 都 实用 的 很 溜 了 ( 这里 给 兄弟 们 赞 一个 ) 。   后面 就是 关于 分支 的 管理 、 合并 、 冲突 的 解决 等 协作 方面 的 问题 ， 这个 从 我 个人 的 使用 来看 问题 基本 不 大 ， 只要 把 网上 的 那本 《 pro   git 》 跟着 操作 完成 ， 你 能 需要 遇到 的 问题 基本 OK 了 。   最后 就是 规划 团队 的 代码 管理 流程 了 ， 让 代码 版本 管理 在 团队 不断 扩大 不断扩大 、 项目 越来 越来越 多 的 过程 中 至于 不至于 失控   还有 一个 不 经常 会 用到 的 操作 ， 就是 迁移 代码 库 。 这个 对于 git 来说 就 太 容易 了 ， 就是 2 、 3 个 命令 的 事     总体 成本 \n   因为 是 开源 的 ， 所以 从 软件 费用 来说 是 0 成本   剩下 的 就是 我们 自己 搭建 服务 务器 服务器 的 成本 了 ， 如果 感觉 自己 服务 务器 服务器 也 不想 出 ， 那 就 找 网上 的 云 服务 就 好 了 ， 所以 这个 成本 也 是 相对 叫 低 的 了 。 这里 列举 几个 我用 过 的 ： github 、 coding . net 、 Git @ OSC 具体 谁 更 适合 你 ， 都 去 用 一边 就 好 了   最后 就是 团队 的 学习 成本 了 ， 从 我 在 易用 易用性 里面 介绍 ， 我 感觉 一个 团队 学习 的 成本 不会 超过 1 周   同时 git 的 周边 产品 周边产品 大多 都 是 免费 的 或者 提供 免费 版本 ， 所以 他 的 配套 产品 成本 产品成本 其实 很 低     技术 支持 技术支持 \n   开源 的 东西 就 只有 社区 ， 这个 不要 太多 想太多 ， 任何 东西 都 需要 你 自己 去 发现 ， 当然 如果 你 选择 三方 平台 ， 他们 会 有 服务 务器 服务器 平台 部分 支持 的     周边 产品 周边产品 \n   现在 基于 git 的 衍生 产品 太多 了 ， 上面 所 列举 的 都 是 ， 随便 baidu 和 google 都 是 一大 把   其他 平台 对于 git 的 支持 我 个人 感觉 个人感觉 很 不错 ， 不论 不论是 IDE 、 持续 集成 环境 、 bug 跟踪 系统 都 有 响应 的 插件 支持 git 版本 库     离线 操作 \n   这个 离线 操作 也 是 我 之前 考虑 使用 它 的 一个 重要 原因 ， 每个 人 只 需要 在 本地 编写 好 、 提交 好 你 的 代码 ， 然后 找 一个 网络 环境 的 地方 ， 把 代码 同步 一下 就 好 了       SVN ( 有 这个 没有 必要 CVS 了 )   svn 现在 用 的 团队 很多 ， 是 一种 集中 中式 集中式 版本 管理 理工 工具 管理工具 ， 我 之前 也 是 用 这个 很长 一段 时间 段时间 一段时间 。 \n   安全 安全性 \n   svn 的 目标 就 管理 团队 代码 ， 所以 可以 很 精确 的 控制 每个 人远能 访问 的 权限 ， 目录 分支 等   由于 是 集中 中式 集中式 管理 ， 所以 svn 服务 务器 服务器 千万 不能 挂掉 ， 如果 挂 了 大家 都 不能 工作 了 ， 同时 找回 代码 也 是 一件 费劲 的 事情     易用 易用性 \n   svn 提供 图形 图形化 客户 客户端 ( 非 linux 系统 ) ， 所以 大家 看 一下 就 可以 使用 了   svn 分支 、 合并 、 冲突 解决 都 是 图形 图形化 操作 ， 大家 用 起来 问题 不 大   大家 都 习惯 了 图形 操作 图形操作 的 方式 ， 所以 学习 很快   但是 在 团队 不断 变 大 、 项目 越来 越来越 多 的 时候 ， 对 svn 的 管理 就 需要 有点 技巧 了     总体 成本 \n   svn 软件 本身 是 免费 的 ， 所以 软件 本身 费用 是 0 成本   如果 自己 搭建 服务 务器 服务器 ， 那 就 需要 服务 务器 服务器 成本 了 ， 不过 你 可以 选择 网上 云 服务 ， 如 google 代码 库 （ 国内 的 就 别 想 了 ） 、 svn   china 、 RiouxSVN 等 。 因为 我 自己 以前 只 使用 过 google ， 所以 对 这些 云 服务 需要 自己 去 体验 了   团队 学习 我们 忽略 吧   svn 的 目标 毕竟 是 代替 老牌 的 cvs ， 周边 产品 周边产品 的 支持 那 是 杠杠 的 ， 其他 和 软件 开发 软件开发 相关 的 环境 和 平台 ， 肯定 都 是 支持 svn 的 ， 如果 你 选择 的 基础 环境 工具 中 还有 不 支持 svn 的 ， 那 肯定 是 你 出 问题 了 。 但是 很多 优秀 svn 的 周边 产品 周边产品 都 是 需要 收费 的     技术 支持 技术支持 \n   社区 绝对 是 一个 神奇 的 存在 ， 你 遇到 的 问题 ， 肯定 有人 解决 了 ， 至少 我 当时 是 这样 的   同时 可以 买 专业 的 svn 产品 ， 这样 可以 得到 专业 团队 的 技术 支持 技术支持 ， 当然 这个 成本 肯定 是 有 的     周边 产品 周边产品 \n   刚刚 就 说 了 它 的 目标 是 代替 老牌 的 cvs ， 所以 周边 产品 周边产品 自然 不用 不用说 ， 只是 成本 的 问题     离线 操作 \n   这个 是 我 当时 最 郁闷 的 一点 ， 如果 你 没有 网络 ， 你 就 不能 提交 了 。 很 不好 做 历史 史记 记录 历史记录 管理       git 服务 务器 服务器   这里 只 介绍 git 版本 库 管理 中 其他 的 思考 。 只 介绍 git 因为 是因为 我 现在 使用 的 git ， 其实 是 之前 在 使用 svn 的 时候 没有 考虑 那么 多 ， 自己 也 没有 好好 去 研究 svn 的 一套 体系 。 \n 要 使用 git 作为 团队 代码 管理 ， 就 需要 git 服务 务器 服务器 （ 当然 对 那些 单兵 作战 单兵作战 的 兄弟 们 ， 最好 也 有 一个 git 服务 务器 服务器 ， 这样 至少 可以 做到 你 在 哪里 都 可以 作战 ） 。 这里 git 服务 务器 服务器 的 选择 就 有 两种 方式 了 ： 1 、 使用 三方 托管 平台 ； 2 、 自己 搭建 git 服务 务器 服务器 。 这里 主要 讨论 第 2 种 方式 ， 自家 搭建 服务 务器 服务器 。 \n git 是 基于 ssh 的 ， 所以 如果 不要 复杂 功能 只 需要 一个 git - shell 就 可以 是 服务 务器 服务器 了 ， 不过 我们 可 不想 重复 找 轮子 ， 别人 已经 弄 好 的 工具 ， 我们 什么 为什么 不 直接 用 呢 ！ ！ ！ Gitosis 、   Gitolite （ 这个 东西 的 权限 管理 很 不错 ） 等 。 如果 要 高级 功能 的 ( 如 ： web 访问 ) ， 那 gitlab 和 gerrit （ 下载 需要 翻墙 ） 将 是 不二 之选 。 这里 我 同时 选用 了 2 者 ， 它们 的 不同 在于 gerrit 是 一个 更 偏向 代码 审查 工具 和 权限 控制 。 虽然 gitlab 也 可以 做 代码 审查 ， 但是 gerrit 是 做 提交 前 审查 ， 同时 对 代码 权限 的 控制 更细 力度 ； 而 gitlab 是 代码 提交 后 审查 ， 同时 必须 有 开发 发人 人员 开发人员 手动 发起 审查 ， 不能 自动 发起 审查 操作 。 这 导致 他们 两个 的 操作 流程 有 很大 区别 。 我 个人 更 倾向 于 gerrit 的 方式 ， 这样 可以 强迫 大家 把 自己 的 代码 质量 提上 上去 提上去 ， 所以 我 这里 选择 了 两者 结合 ， gerrit 这里 做 权限 和 质量 把 控 ， gitlab 做 为 集成 测试 和 发布 版本 库 。 \n 任务 / 缺陷 管理 环境   缺陷 跟踪 系统 redmine 、 Bugzilla 、 BugZero 、 Trac 、 jira 、 trello 、 bugfree 、 禅道 、 coding . net 等 ， 现在 不论 不论是 收费 的 还是 免费 的 都 有 很多 ， 我 相信 任何 一个 都 能 解决 bug 跟踪 问题 。 从 我 的 使用 过程 中 发现 这些 系统 都 有 各自 的 有点 ， 同时 也 有 很多 不足 的 地方 ， 最终 一个 工具 不是 是不是 符合 你们 团队 ， 只有 试用 过才 知道 。 以下 是 我 在 使用 过程 中 发现 的 一些 特点 ， 感觉 如果 从 这些 点 出发 去 试用 和 思考 一个 系统 或 工具 ， 可以 很快 判断 这个 系统 或 工具 是否 适合 团队 ， 里面 有些 特性 是 我 使用 过 的 工具 里面 都 没有 的 ， 但是 这些 特点 我 感觉 确实 很 有用 ： \n   平台 跨平台 客户 客户端 （ 现在 大多 是 web ， 这个 大部 部分 大部分 都 满足 ）   可以 和 其他 种类 系统 集成 系统集成 （ 如 ： 代码 库 ， 测试 平台 、 持续 集成 环境 等 ）   界面 易 操作 操作性   多 项目 管理 项目管理   自定 定义 自定义 流程   当然 成本 决定 算 一个   系统 更新 速度   支持 多种 开发 模式   分级 统计 功能   移动 端 支持     持续 集成 环境   持续 集成 环境 对 团队 和 项目 的 自动 自动化 有 一定 要求 ， 同时 可以 也 是 对 团队 自动 自动化 的 一种 推进 ； 同时 对 团队 的 开发 流程 和 编码 风格 都 会 有 推动 作用 。 当然 至于 用 什么 工具 那 是 其次 的 ， 总点 是 要 让 团队 养成 持续 集成 的 习惯 和 节奏 。 \n 持续 集成 至 应该 做到 一下 几点 ： \n   自动 构建 ： 要求 无人 值守 ， 如果 人工 来 操作 ， 那 就 没有 持续 集成 的 必要 了   发现 版本 库 的 变更 ： 通过 轮询 或者 定时 ， 或者 程序 程序员 使用 命令 ， 处罚 持续 集成 发现 版本 库 的 变更   反馈 机制 ： 在 出现 问题 时 ， 能 及时 的 把 问题 反馈 给 正确 的 人 （ 提交 提交者 、 测试 测试者 、 管理 管理者 ）   回滚 ： 在 出现 问题 后 ， 拥有 回滚 到 可 交付 的 能力   纯净 的 构建 环境 ： 每 一次 都 应该 把 之前 的 环境 删除 干净 ， 让 每 一次 构建 都 是 一个 新 的 构建   完善 的 集成 功能 ： 代码 的 测试 ， 审查 都 应该 做到 完善 。 如果 单纯 的 利用 它 做 持续 的 编译 ， 那 就是 大材小用 了   为了 避免 每次 过多 出现 问题 的 构建 ， 开发 开发者 在 提交 代码 的 时候 ， 最好 在 本地 独立 的 构建 一次 。 可以 自行 运行 构建 脚本 ， 模拟 构建   由于 数据 据库 数据库 与 编码 的 分离 ， 最好 把 数据 据库 数据库 相关 的 DDL \\ DML 等 脚本 一起 放入 版本 库中 ， 这样 CI 进行 构建 的 时候 ， 可以 连同 数据 据库 数据库 一起 重新 构建   能 和 我们 的 代码 管理 库 、 任务 / 缺陷 跟踪 等 其他 平台 交互     推荐 书籍 《 持续 集成 ： 软件 质量 改进 和 风险 降低 之道 》 \n 集成 工具 ： jenkins （ 前身 是 Hudson ） 、 gitlab - ci 、 Apache   Continuum 、 CruiseControl 、 Luntbuild 、 drone 、 shippable \n 集成 的 配置 是 不可 必不可少 的 ， 就是 让 你 定义 如何 集成 构建 的 构建 脚本 啦 ， 如果 没有 一个 可 配置 的 构建 过程 ， 那 持续 集成 说起 从何说起 呢 。 ant 、 maven 、 gradle 、 make 、 shell \n 由于 集成 是 基于 测试 之上 的 ， 所以 一个 好 的 测试 试工 工具 测试工具 比 不可 少 ， 但是 这个 和 团队 使用 的 语言 相关 息息相关 ， 每中 语言 都 有 自己 的 测试 试工 工具 测试工具 。 简单 举例 已 达到 抛砖 抛砖引玉 的 效果 ： 各种 Unit （ Junit ， HtmlUnit ， cppUnit ， SQLUnit 等 ） 、 karma 、 mocha 。 。 。 （ 手软 & gt ; _& lt ; ） \n 自动 代码 审查 是 提高 代码 质量 ， 养成 代码 习惯 比可少 的 ， 同时 这些 事情 可以 自动 的 做 掉 ， 可以 让 我们 更加 关注 于 我们 的 代码   checkstyle 、 javaNcss 、 PMD 、 siminan 、 jsHint 、 jsLint 、 Emma 。 。 。 \n 集成 反馈 和 报告 这个 可以 让 我们 可以 实时 得到 集成 结果 ， 失败 快速 找 原因 ， 成功 我们 就 可以 安心 睡觉 了 。 邮件 通知 、 Jabber 、 JSCoverage 、 GCOV 、 python   coverage 、 JCoverage 、 Cobertura 。 。 。 \n 代码 质量 监控 环境   代码 质量 监控 平台 其实 就是 让 我们 的 代码 质量 可视 可视化 、 可 管理 ， 让 我们 的 代码 质量 形成 历史 史记 记录 历史记录 。 同时 可以 非常 方便 的 工 全部 人员 查看 。 \n   质量 可视 可视化   跟踪 质量 走向 （ 需要 历史 史记 记录 历史记录 ）   可以 自动 从 持续 集成 环境 、 代码 审查 中 搜集 质量 信息   可以 和 代码 管理 环境 打通 ， 这个 的 目的 是 最好 能 看到 每个 人 代码 质量   可以 和 其他 工程 管理 理工 工具 管理工具 打通     SonarQube 、 前面 介绍 的 自动 代码 审查 工具 \n 文档 编辑 环境   我们 的 程序 程序员 往往 都 不 喜欢 写 文档 ， 你 让 他 写 文档 ， 还 不如 让 他 写 2 倍 的 代码 。 但是 文档 确是 我们 项目 中 不可 缺少 的 部分 ， 那 怎么 让 我们 的 程序 程序员 可以 高效 的 写 文档 呢 ！ 其实 我们 程序 程序员 在 写 文档 的 时候 ， 往往 是 被 文档 的 格式 所 折磨 ， 不能 专心 的 写 内容 ， 从而 出发 对 写 文档 的 抵触 情绪 抵触情绪 。 所以 结合 以上 我 任务 文档 编写 环境 应该 有 一下 几点 ： \n   不用 关心 格式 ， 重点 在 内容 ， 格式 自动   能 从 代码 中 自动 生成 文档   文档 能 实时 共享 、 自动 共享 ， 像 现在 用 的 邮件 、 QQ 之类 的 其实 很 影响 心情   文档 格式 足够 简单 ， 在 写 的 时候 要 做到 双手 不 脱离 键盘 最好     markdown 、 各种 语言 doc 工具 了 （ jsdoc 、 javadoc 等 ） 、 wiki 、 shpinx \n 沟通 环境   上面 所说 的 说 有 东西 的 最终 目的 其实 都 是 为了 解决 我们 协作 的 问题 ， 至少 是 或多或少 都 会 涉及 到 协作 沟通 问题 。 像 现在 大家 用 的 最 多 的 沟通 工具 应该 变成 QQ 、 微信 之类 的 了 吧 ， 加上 邮件 、 电话 、 各种 协作 平台 或者 其他 通讯 工具 ， 但是 这些 工具 都 有 一个 特点 ： 在 使用 的 时候 都 会 有 一个 时间 长时间 打断 我们 思维 ， 或者 需要 我们 专门 准备 一个 时间 去 做 ； 这些 其实 都 会 造成 浪费 。 其实 最 有效 的 沟通 就是 面对 对面 面对面 交流 ， 所以 构建 一个 良好 的 沟通 环境 ， 对 我们 的 项目 进度 起着 至关 重要 至关重要 的 作用 ： \n   沟通 资源 随手 可 得 （ 易于 获得 ） ， 可以 在 30 秒 内 获得   兄弟 们 可以 采取 自己 认为 高效 的 方式 沟通 ， 同时 沟通 方式 的 资源 易于 获得   沟通 历史 和 结果 易于 记录 ， 最好 能 在 不 察觉 的 情况 下 记录 起来     项目 开发 环境   项目 开发 环境 可以 分为 ： 工程 管理 理工 工具 管理工具 和 工程 开发 工具 开发工具 。 项目 开发 环境 每个 团队 都 有 差别 ， 同时 团队 内部 每个 人 肯定 都 有 差异 ， 因为 它 受到 的 影响 因 最多 数最多 ， 比如 ： 使用 语言 ， 工作 内容 ， 个人 习惯 ， 操作 系统 操作系统 ， 可能 还 和 心情 有关 等 。 因此 团队 在 选择 项目 开发 环境 的 时候 ， 既 要 根据 团队 的 定位 选定 基础 开发 环境 （ 工程 管理 理工 工具 管理工具 ） ， 同时 出 一些 选择 辅助 开发 环境 的 选择 指导 规则 ； 也 要 考虑 每个 成员 的 习惯 ， 开放 出来 辅助 开发 环境 ， 让 每个 成员 可以 根据 自己 的 习惯 ， 选择 一套 他 自己 最 高效 的 项目 开发 环境 集合 。 下面 我 列举 我 认为 在 选择 工程 管理 理工 工具 管理工具 和 工程 开发 工具 开发工具 应该 具备 的 几点 特征 ： \n 工程 管理 理工 工具 管理工具     可以 和 工程 开发 工具 开发工具 高效 集成   可以 测试   可以 做 质量 检查 质量检查   可以 和 质量 管理 系统 管理系 管理系统 集成     ant ， maven ， gradle ， gulp ， grunt ， make ， cmake 。 。 。 \n 项目 开发 工具 开发工具   项目 开发 工具 开发工具 也 叫做 集成 开发 环境 ， 很多 集成 开发 环境 都 带有 自己 的 工程 管理 理工 工具 管理工具 \n   可以 和 代码 管理 理工 工具 管理工具 集成   测试 必须   可以 做 本地 质量 检查 质量检查   可以 方便 实现 重构 手法 ， 关于 重构 推荐 《 重构 ： 改变 既有 代码 设计 》   最好 能 和 缺陷 跟踪 系统 集成 系统集成   可以 和 工程 管理 理工 工具 管理工具 集成     eclipse 、 webstorm 、 vs 、 idea 等 \n 需求 / 产品 管理 环境   对于 需求 / 产品 管理 环境 我 自己 现在 还 没有 在 具体 项目 中 实践 过 ， 所以 这里 就 不 在 阐述 了 ， 如果 你 有 好 的 想法 可以 给 我 留言 ， 或者 给 我 连接 地址 ， 我 连接 过去 \n 测试 管理 环境   测试 管理 环境 其实 应该 在 持续 集成 环境 里面 ， 但是 由于 上面 写 持续 集成 环境 的 时候 过于 偏向 开发 发人 人员 开发人员 的 使用 角度 介绍 了 ， 并且 这 两套 系统 确实 也 是 独立 存在 的 。 这个 测试 管理 环境 更 多 面向 于 测试 人员 测试人员 ， 而 我 认为 测试 试工 工具 测试工具 本身 也 是 分为 测试 管理 理工 工具 管理工具 和 测试 执行 工具 两 类别 ， 所以 我会 从 测试 管理 和 测试 执行 两个 方面 来说 我 观点 （ 这里 的 划分 是 按照 工具 的 分类 划分 ， 并 不是 按照 软件 方法 的 方式 划分 ） ， 同时 对于 测试 我 想 后面 会 有 专门 的 一篇 文章 来 介绍 ， 所以 这里 就 这样 了 ， 大家 见谅 我 的 不 专业 \n 测试 管理 理工 工具 管理工具   测试 管理 我 认为 比较 重要 的 是 ： 测试 计划 测试计划 ， 测试 试用 测试用例 ， 测试 跟踪 ， 缺陷 管理 ( 这个 和 任务 / 缺陷 管理 环境 一样 ) \n   可以 管理 测试 计划 测试计划   可以 管理 测试 试用 测试用例   可以 跟踪 每个 测试 试用 测试用例 的 状态   可以 和 缺陷 系统 集成 系统集成   可以 和 持续 集成 系统 集成 系统集成     QC ( Quality   Center ) ， TestLink ， oKit ， TD （ TestDirector ） 上面 提到 的 缺陷 管理 系统 管理系 管理系统 \n 测试 执行 工具   测试 执行 的 方式 都 很多 了 ， 并且 测试 执行 种类 也 很多 ， 比如 ： 自动 自动化 测试 ， 性能 测试 ， 安全 测试 ， 白盒 测试 等 。 这 里面 不同 的 测试 方式 所 使用 的 工具 都 是 不 一样 的 ： \n selenium ， jmeter ， jprofile ， Wireshark ， AppCan ， Metasploit ， Nmap ， Acunetix ， Burp   Suite ， apache   ab ， Gatling \n 还是 那句话 工具 只能 给 我们 提供 一个 更 专心 、 更 快速 做事 的 环境 ， 但是 最终 这个 事情 能 不能 做成 、 能 不能 做好 完全 是 取决 我们 自己 。 所以 不论 使用 任何 工具 都行 ， 前提 是 我们 有 自己 提高 的 意识 和 习惯 ， 比如 ： 编码 风格 、 编程 习惯 、 测试 习惯 、 重构 习惯 、 沟通 能力 、 协作 能力 等 ， 这些 才 是 真真 决定 项目 成败 的 关键 。 \n", "title_s": "项目 持续 集成 工具"}, {"description": "", "objectID": "https://blog.threeq.me/post/web/css3-added-selector/", "tags": ["css3"], "title": "CSS3 新增选择器", "uri": "https://blog.threeq.me/post/web/css3-added-selector/", "content": "现代前端开发中css3已经是不可其他的一部分，早已成为每个web开发人员必备技能之一。 而选择器又是css中最基础、最重要的知识点，对于我们页面结构和代码接口都有着举足轻重的作用。 今天我们就来看看css3所支持的和新增的选择器。\n\n1. CSS1定义的选择器    选择器 类型 说明     E 类型选择器 选择指定类型的元素   E#id ID选择器 选择匹配E的元素，且匹配元素的id为“id”，E选择符可以省略。   E.class 类选择器 选择匹配E的元素，且匹配元素的class属性值为“class”，E选择符可以省略。   E F 包含选择器 选择匹配F的元素，且该元素被包含在匹配E的元素内。   E:link 链接伪类选择器 选择匹配E的元素，且匹配元素被定义了超链接并未被访问。例：a:link、#a_id:link   E:visited 链接伪类选择器 选择匹配E的元素，且匹配元素被定义了超链接并已被访问。例：a:visited   E:active 用户操作伪类选择器 选择匹配E的元素，且匹配元素被激活   E:hover 用户操作伪类选择器 选择匹配E的元素，且匹配元素正被鼠标经过   E:focus 用户操作伪类选择器 选择匹配E的元素，且匹配元素获取了焦点   E:first-line 伪元素选择器 选择匹配E元素内的第一行文本   E:first-letter 伪元素选择器 选择匹配E元素内的第一个字符    2. CSS2定义的选择器    选择器 类型 说明     * 通配选择器 选择文档中所有元素   E[foo] 属性选择器 选择匹配E的元素，且该元素定义了foo属性。E选择符可以省略，表示选择定义了foo属性的任意类型的元素。   E[foo=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素foo属性值为“bar”   E[foo~=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个以空格符分隔的列表，其中一个列表的值为“bar”，E选择符可以省略。   E[foo!=&ldquo;en&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个用连字符（-）分隔的列表，值以“en”开头。   E:first-child 结构伪类选择器 选择匹配E的元素，且该元素为父元素的第一个子元素   E:before 伪元素选择器 在匹配E的元素前面插入内容   E:after 伪元素选择器 在匹配E的元素后面插入内容   E &gt; F 子包含选择器 选择匹配F的元素，且该元素为所匹配E元素的子元素。   E + F 相邻兄弟选择器 选择匹配F的元素，且该元素为所匹配E元素后面相邻的位置。   E:lang(language) 语言选择器 例如：p:lang(it) 选择带有以 &ldquo;it&rdquo; 开头的 lang 属性值的每个  元素。    3. CSS3新增属性选择器    选择器 类型 说明     E[foo^=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”开始。E选择符可以省略，表示可匹配任意类型的元素。   E[foo$=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”结束。E选择符可以省略，表示可匹配任意类型的元素。   E[foo*=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值包含“bar”。E选择符可以省略，表示可匹配任意类型的元素。   E:root 结构伪类选择器 选择匹配E所在文档的根元素。在（X）HTML文档中，根元素就是html元素，此时该选择器与html类型选择器匹配的内容相同。   E:nth-child(n) 结构伪类选择器 选择所有在其父元素中第n个位置的匹配E的子元素。\n注意，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始。\ntr:nth-child(3)匹配所有表格中第3排的tr；\ntr:nth-child(2n+1)匹配所有表格的奇数行；\ntr:nth-child(2n)匹配所有表格的偶数行；\ntr:nth-child(odd)匹配所有表格的奇数行；\ntr:nth-child(even)匹配所有表格的偶数行；   E:nth-last-child(n) 结构伪类选择器 选择所有在其父元素中倒数第n个位置的匹配E的子元素   E:nth-of-type(n) 结构伪类选择器 选择父元素中第n个位置，且匹配E的子元素。\n注意，所有匹配E的子元素被分离出来单独排序。非E的子元素不参与排序。参数n可以是数字，关键字、公式。\n例：p:nth-of-type(1)   E:nth-last-of-type(n) 结构伪类选择器 选择父元素中倒数第n个位置，且匹配E的子元素。   E:last-child 结构伪类选择器 选择位于其父元素中最后一个位置，且匹配E的子元素。   E:first-of-type 结构伪类选择器 选择位于其父元素中且匹配E的第一个同类型的子元素。\n该选择器的功能类似于 E:nth-of-type(1)   E:last-of-type 结构伪类选择器 选择位于其父元素中且匹配E的最后第一个同类型的子元素。\n该选择器的功能类似于 E:nth-last-of-type(1)   E:only-child 结构伪类选择器 选择其父元素只包含一个子元素，且该子元素匹配E。   E:only-of-type 结构伪类选择器 选择其父元素只包含一个同类型的子元素，且该子元素匹配E。   E:empty 结构伪类选择器 选择匹配E的元素，且该元素不包含子节点   E:enabled UI状态伪类选择器 选择匹配E的所有可用UI元素。   E:disabled UI状态伪类选择器 选择匹配E的所有不可用UI元素。   E:checked UI状态伪类选择器 选择匹配E的所有可用UI元素。\n例：input:checked匹配input type为radio及checkbox元素   ::selection UI状态伪类选择器 选择被用户选取的元素部分。   E ~ F 相邻兄弟选择器 选择匹配F的所有元素，且匹配元素位于匹配E的元素后面。在DOM结构树中，E和F所匹配的元素应该在同一级结构上。   E:not(s) 否定伪类选择器 选择匹配E的所有元素，且过滤掉匹配s选择符的任意元素。s是一个简单结构的选择器，不能使用符合选择器，   E:target 目标伪类选择器 选择匹配E的所有元素，且匹配元素被相关URL指向。\n注意：该选择器是动态选择器，只有存在URL指向该匹配元素时，样式才起效果。\n例：demo.html#id    参考：http://www.w3school.com.cn/cssref/css_selectors.asp\n", "content_s": "现代 前端 开发 前端开发 中 css3 已经 是 不可 其他 的 一部 部分 一部分 ， 早已 成为 每个 web 开发 发人 人员 开发人员 必备 技能 之一 。   而 选择 选择器 又 是 css 中 最 基础 、 最 重要 的 知识 知识点 ， 对于 我们 页面 结构 和 代码 接口 都 有着 举足 足轻 轻重 举足轻重 的 作用 。   今天 我们 就 来 看看 css3 所 支持 的 和 新增 的 选择 选择器 。 \n \n 1 .   CSS1 定义 的 选择 选择器         选择 选择器   类型   说明           E   类型 选择 选择器   选择 指定 类型 的 元素       E # id   ID 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 的 id 为 “ id ” ， E 选择 选择符 可以 省略 。       E . class   类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 的 class 属性 值为 “ class ” ， E 选择 选择符 可以 省略 。       E   F   包含 选择 选择器   选择 匹配 F 的 元素 ， 且 该 元素 被 包含 在 匹配 E 的 元素 内 。       E : link   链接 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 定义 了 链接 超链接 并未 被 访问 。 例 ： a : link 、 # a _ id : link       E : visited   链接 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 定义 了 链接 超链接 并 已 被 访问 。 例 ： a : visited       E : active   用户 操作 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 激活       E : hover   用户 操作 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 正 被 鼠标 经过       E : focus   用户 操作 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 获取 了 焦点       E : first - line   伪 元素 选择 选择器   选择 匹配 E 元素 内 的 第一 一行 第一行 文本       E : first - letter   伪 元素 选择 选择器   选择 匹配 E 元素 内 的 第一 一个 第一个 字符         2 .   CSS2 定义 的 选择 选择器         选择 选择器   类型   说明           *   通配 选择 选择器   选择 文档 中 所有 元素       E [ foo ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 。 E 选择 选择符 可以 省略 ， 表示 选择 定义 了 foo 属性 的 任意 类型 的 元素 。       E [ foo = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 foo 属性 值为 “ bar ”       E [ foo ~ = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 是 一个 以 空格 空格符 分隔 的 列表 ， 其中 一个 列表 的 值 为 “ bar ” ， E 选择 选择符 可以 省略 。       E [ foo ! = & ldquo ; en & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 是 一个 用 连 字符 （ - ） 分隔 的 列表 ， 值以 “ en ” 开头 。       E : first - child   结构 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 为父 元素 的 第一 一个 第一个 子 元素       E : before   伪 元素 选择 选择器   在 匹配 E 的 元素 前面 插入 内容       E : after   伪 元素 选择 选择器   在 匹配 E 的 元素 后面 插入 内容       E   & gt ;   F   子 包含 选择 选择器   选择 匹配 F 的 元素 ， 且 该 元素 为 所 匹配 E 元素 的 子 元素 。       E   +   F   相邻 兄弟 选择 选择器   选择 匹配 F 的 元素 ， 且 该 元素 为 所 匹配 E 元素 后面 相邻 的 位置 。       E : lang ( language )   语言 选择 选择器   例如 ： p : lang ( it )   选择 带有 以   & ldquo ; it & rdquo ;   开头 的   lang   属性 值 的 每个     元素 。         3 .   CSS3 新增 属性 选择 选择器         选择 选择器   类型   说明           E [ foo ^ = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值以 “ bar ” 开始 。 E 选择 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E [ foo $ = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值以 “ bar ” 结束 。 E 选择 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E [ foo * = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 包含 “ bar ” 。 E 选择 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E : root   结构 伪类 选择 选择器   选择 匹配 E 所在 文档 的 根 元素 。 在 （ X ） HTML 文档 中 ， 根 元素 就是 html 元素 ， 此时 该 选择 选择器 与 html 类型 选择 选择器 匹配 的 内容 相同 。       E : nth - child ( n )   结构 伪类 选择 选择器   选择 所有 在 其父 元素 中 第 n 个 位置 的 匹配 E 的 子 元素 。 \n 注意 ， 参数 n 可以 是 数字 （ 1 、 2 、 3 ） 、 关键 关键字 （ odd 、 even ） 、 公式 （ 2n 、 2n + 3 ） 参数 的 索引 从 1 开始 。 \n tr : nth - child ( 3 ) 匹配 所有 表格 中 第 3 排 的 tr ； \n tr : nth - child ( 2n + 1 ) 匹配 所有 表格 的 奇数 行 ； \n tr : nth - child ( 2n ) 匹配 所有 表格 的 偶数 行 ； \n tr : nth - child ( odd ) 匹配 所有 表格 的 奇数 行 ； \n tr : nth - child ( even ) 匹配 所有 表格 的 偶数 行 ；       E : nth - last - child ( n )   结构 伪类 选择 选择器   选择 所有 在 其父 元素 中 倒数 倒数第 n 个 位置 的 匹配 E 的 子 元素       E : nth - of - type ( n )   结构 伪类 选择 选择器   选择 父 元素 中 第 n 个 位置 ， 且 匹配 E 的 子 元素 。 \n 注意 ， 所有 匹配 E 的 子 元素 被 分离 出来 分离出来 单独 排序 。 非 E 的 子 元素 不 参与 排序 。 参数 n 可以 是 数字 ， 关键 关键字 、 公式 。 \n 例 ： p : nth - of - type ( 1 )       E : nth - last - of - type ( n )   结构 伪类 选择 选择器   选择 父 元素 中 倒数 倒数第 n 个 位置 ， 且 匹配 E 的 子 元素 。       E : last - child   结构 伪类 选择 选择器   选择 位于 其父 元素 中 最后 一个 位置 ， 且 匹配 E 的 子 元素 。       E : first - of - type   结构 伪类 选择 选择器   选择 位于 其父 元素 中且 匹配 E 的 第一 一个 第一个 同 类型 的 子 元素 。 \n 该 选择 选择器 的 功能 类似 于   E : nth - of - type ( 1 )       E : last - of - type   结构 伪类 选择 选择器   选择 位于 其父 元素 中且 匹配 E 的 最后 第一 一个 第一个 同 类型 的 子 元素 。 \n 该 选择 选择器 的 功能 类似 于   E : nth - last - of - type ( 1 )       E : only - child   结构 伪类 选择 选择器   选择 其父 元素 只 包含 一个 子 元素 ， 且 该子 元素 匹配 E 。       E : only - of - type   结构 伪类 选择 选择器   选择 其父 元素 只 包含 一个 同 类型 的 子 元素 ， 且 该子 元素 匹配 E 。       E : empty   结构 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 不 包含 子 节点       E : enabled   UI 状态 伪类 选择 选择器   选择 匹配 E 的 所有 可用 UI 元素 。       E : disabled   UI 状态 伪类 选择 选择器   选择 匹配 E 的 所有 不可 用 UI 元素 。       E : checked   UI 状态 伪类 选择 选择器   选择 匹配 E 的 所有 可用 UI 元素 。 \n 例 ： input : checked 匹配 input   type 为 radio 及 checkbox 元素       : : selection   UI 状态 伪类 选择 选择器   选择 被 用户 选取 的 元素 部分 。       E   ~   F   相邻 兄弟 选择 选择器   选择 匹配 F 的 所有 元素 ， 且 匹配 元素 位于 匹配 E 的 元素 后面 。 在 DOM 结构 树中 ， E 和 F 所 匹配 的 元素 应该 在 同 一级 结构 上 。       E : not ( s )   否定 伪类 选择 选择器   选择 匹配 E 的 所有 元素 ， 且 过滤 掉 匹配 s 选择 选择符 的 任意 元素 。 s 是 一个 简单 结构 的 选择 选择器 ， 不能 使用 符合 选择 选择器 ，       E : target   目标 伪类 选择 选择器   选择 匹配 E 的 所有 元素 ， 且 匹配 元素 被 相关 URL 指向 。 \n 注意 ： 该 选择 选择器 是 动态 选择 选择器 ， 只有 存在 URL 指向 该 匹配 元素 时 ， 样式 才 起 效果 。 \n 例 ： demo . html # id         参考 ： http : / / www . w3school . com . cn / cssref / css _ selectors . asp \n", "title_s": "CSS3   新增 选择 选择器"}, {"description": "Threeq - 出井的青蛙介绍", "objectID": "https://blog.threeq.me/about/", "tags": [], "title": "关于 Threeq - 出井的青蛙", "uri": "https://blog.threeq.me/about/", "content": " Threeq - 出井的青蛙  快乐的程序员、老司机。\n喜欢专研、思考和专研遇到的难题，不论是技术上还是团队管理上。\n对新技术保持好奇、热爱和谨慎的态度。坚信技术能让明天更美好。\n喜欢分享，开源追随者，崇尚敏捷开发实践。\n常用语言 Java、Python、Golang、Javascript\n目前正在实践 Scrum + 看板 + 领域驱动设计（DDD） + 微服务\n目前正在学 习机器学习（ML）、分布式系统架构设计、k8s 技术栈\n欢迎一起交流学习（非诚勿扰）    扫码关注订阅号    联系我    ", "content_s": "  Threeq   -   出井 的 青蛙     快乐 的 程序 程序员 、 老 司机 。 \n 喜欢 专研 、 思考 和 专研 遇到 的 难题 ， 不论 不论是 技术 上 还是 团队 管理 上 。 \n 对 新 技术 保持 好奇 、 热爱 和 谨慎 的 态度 。 坚信 技术 能 让 明天 更 美好 。 \n 喜欢 分享 ， 开源 追随 追随者 ， 崇尚 敏捷 开发 实践 。 \n 常用 语言   Java 、 Python 、 Golang 、 Javascript \n 目前 正在 实践   Scrum   +   看 板   +   领域 驱动 设计 （ DDD ）   +   微 服务 \n 目前 正在 学   习 机器 学习 （ ML ） 、 分布 布式 系统 分布式 分布式系统 架构 构设 设计 架构设计 、 k8s   技术 栈 \n 欢迎 一起 交流 学习 交流学习 （ 非诚 勿扰 ）         扫码 关注 订阅 号         联系 我        ", "title_s": "关于   Threeq   -   出井 的 青蛙"}, {"description": "", "objectID": "https://blog.threeq.me/categories/", "tags": [], "title": "Categories", "uri": "https://blog.threeq.me/categories/", "content": "", "content_s": "", "title_s": "Categories"}, {"description": "", "objectID": "https://blog.threeq.me/tags/ci/cd/", "tags": [], "title": "Ci/Cd", "uri": "https://blog.threeq.me/tags/ci/cd/", "content": "", "content_s": "", "title_s": "Ci / Cd"}, {"description": "", "objectID": "https://blog.threeq.me/tags/css3/", "tags": [], "title": "Css3", "uri": "https://blog.threeq.me/tags/css3/", "content": "", "content_s": "", "title_s": "Css3"}, {"description": "", "objectID": "https://blog.threeq.me/tags/gerrit/", "tags": [], "title": "Gerrit", "uri": "https://blog.threeq.me/tags/gerrit/", "content": "", "content_s": "", "title_s": "Gerrit"}, {"description": "", "objectID": "https://blog.threeq.me/tags/git/", "tags": [], "title": "Git", "uri": "https://blog.threeq.me/tags/git/", "content": "", "content_s": "", "title_s": "Git"}, {"description": "", "objectID": "https://blog.threeq.me/tags/gitlab/", "tags": [], "title": "Gitlab", "uri": "https://blog.threeq.me/tags/gitlab/", "content": "", "content_s": "", "title_s": "Gitlab"}, {"description": "", "objectID": "https://blog.threeq.me/tags/gtd/", "tags": [], "title": "Gtd", "uri": "https://blog.threeq.me/tags/gtd/", "content": "", "content_s": "", "title_s": "Gtd"}, {"description": "", "objectID": "https://blog.threeq.me/tags/hugo/", "tags": [], "title": "Hugo", "uri": "https://blog.threeq.me/tags/hugo/", "content": "", "content_s": "", "title_s": "Hugo"}, {"description": "", "objectID": "https://blog.threeq.me/tags/jenkins/", "tags": [], "title": "Jenkins", "uri": "https://blog.threeq.me/tags/jenkins/", "content": "", "content_s": "", "title_s": "Jenkins"}, {"description": "", "objectID": "https://blog.threeq.me/tags/mysql/", "tags": [], "title": "Mysql", "uri": "https://blog.threeq.me/tags/mysql/", "content": "", "content_s": "", "title_s": "Mysql"}, {"description": "", "objectID": "https://blog.threeq.me/tags/percona/", "tags": [], "title": "Percona", "uri": "https://blog.threeq.me/tags/percona/", "content": "", "content_s": "", "title_s": "Percona"}, {"description": "", "objectID": "https://blog.threeq.me/post/", "tags": [], "title": "Posts", "uri": "https://blog.threeq.me/post/", "content": "", "content_s": "", "title_s": "Posts"}, {"description": "", "objectID": "https://blog.threeq.me/tags/pt-query-digest/", "tags": [], "title": "Pt Query Digest", "uri": "https://blog.threeq.me/tags/pt-query-digest/", "content": "", "content_s": "", "title_s": "Pt   Query   Digest"}, {"description": "", "objectID": "https://blog.threeq.me/tags/redmine/", "tags": [], "title": "Redmine", "uri": "https://blog.threeq.me/tags/redmine/", "content": "", "content_s": "", "title_s": "Redmine"}, {"description": "", "objectID": "https://blog.threeq.me/tags/scrum/", "tags": [], "title": "Scrum", "uri": "https://blog.threeq.me/tags/scrum/", "content": "", "content_s": "", "title_s": "Scrum"}, {"description": "", "objectID": "https://blog.threeq.me/tags/sql/", "tags": [], "title": "Sql", "uri": "https://blog.threeq.me/tags/sql/", "content": "", "content_s": "", "title_s": "Sql"}, {"description": "", "objectID": "https://blog.threeq.me/tags/", "tags": [], "title": "Tags", "uri": "https://blog.threeq.me/tags/", "content": "", "content_s": "", "title_s": "Tags"}, {"description": "", "objectID": "https://blog.threeq.me/", "tags": [], "title": "Threeq - 出井的青蛙", "uri": "https://blog.threeq.me/", "content": "", "content_s": "", "title_s": "Threeq   -   出井 的 青蛙"}, {"description": "", "objectID": "https://blog.threeq.me/categories/web/", "tags": [], "title": "Web", "uri": "https://blog.threeq.me/categories/web/", "content": "", "content_s": "", "title_s": "Web"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/", "tags": [], "title": "个人管理", "uri": "https://blog.threeq.me/categories/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/", "content": "", "content_s": "", "title_s": "个人 管理"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E5%89%8D%E7%AB%AF/", "tags": [], "title": "前端", "uri": "https://blog.threeq.me/tags/%E5%89%8D%E7%AB%AF/", "content": "", "content_s": "", "title_s": "前端"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/", "tags": [], "title": "团队管理", "uri": "https://blog.threeq.me/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/", "content": "", "content_s": "", "title_s": "团队 管理"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E5%B7%A5%E5%85%B7/", "tags": [], "title": "工具", "uri": "https://blog.threeq.me/categories/%E5%B7%A5%E5%85%B7/", "content": "", "content_s": "", "title_s": "工具"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "tags": [], "title": "敏捷开发", "uri": "https://blog.threeq.me/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "content": "", "content_s": "", "title_s": "敏捷 开发"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "tags": [], "title": "敏捷开发", "uri": "https://blog.threeq.me/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "content": "", "content_s": "", "title_s": "敏捷 开发"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/", "tags": [], "title": "数据库", "uri": "https://blog.threeq.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/", "content": "", "content_s": "", "title_s": "数据 据库 数据库"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/", "tags": [], "title": "数据库", "uri": "https://blog.threeq.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/", "content": "", "content_s": "", "title_s": "数据 据库 数据库"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/", "tags": [], "title": "时间管理", "uri": "https://blog.threeq.me/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/", "content": "", "content_s": "", "title_s": "时间 管理"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%9E%B6%E6%9E%84/", "tags": [], "title": "架构", "uri": "https://blog.threeq.me/tags/%E6%9E%B6%E6%9E%84/", "content": "", "content_s": "", "title_s": "架构"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/", "tags": [], "title": "查询优化", "uri": "https://blog.threeq.me/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/", "content": "", "content_s": "", "title_s": "查询 优化"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E7%9C%8B%E6%9D%BF/", "tags": [], "title": "看板", "uri": "https://blog.threeq.me/tags/%E7%9C%8B%E6%9D%BF/", "content": "", "content_s": "", "title_s": "看 板"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E7%AC%94%E8%AE%B0/", "tags": [], "title": "笔记", "uri": "https://blog.threeq.me/categories/%E7%AC%94%E8%AE%B0/", "content": "", "content_s": "", "title_s": "笔记"}]