[{"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/5-query-function/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第五天：数据操作函数", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/5-query-function/", "content": "我们之前已经学习很多的 SQL 查询支持，但是这些查询只能原样返回数据库里存储的数据，那如果我们需要对这些数据做一个处理怎么办呢？比如：合并2个字段、返回的学生年龄2倍等。这就是今天要一起学习的内容：数据操作函数。每个 RDBMS 提供提供的函数操作都不一样，这里还是以 MySQL 为例子讲解，其他的 RDBMS 请查阅相关文档。由于数据处理函数比较多，这里没有办法全部覆盖，只会列举我们常用的一些操作函数，我把他们分成 5 类：字符串函数、数值函数、时间函数、统计函数、流程控制函数。想知道更多函数详情请参考 MySQL 官方文档。\n知识要点：\n 计算字段、计算列、虚拟列 常用字符串函数 常用数值计算、数值函数 常用日期时间函数 流程控制函数  这里列举的使平时常用的 4 中类型函数分类，另外的统计函数将在下次单独说明。\n\n在查询里面使用计算表达式或函数表达式的列称为计算列或计算字段。它是一个虚拟列，数据库并不实际存储在表中，计算列的表达式可以使用其他列中的数据来计算其所属列的值。\n字符串函数 下面是常用的一些字符处理函数\n   函数 描述 实例     concat() 拼接字符串 SELECT concat(&lsquo;Hello&rsquo;, &lsquo;, &lsquo;, &lsquo;World&rsquo;,&lsquo;!&rsquo;);   format() 格式化数字到字符串 SELECT format(12332.1,4);   length() 返回字符串长度 SELECT length(&lsquo;xxx&rsquo;);   lcase()/lower() 转换小写 SELECT lower(&lsquo;ABcDef&rsquo;);   ltrim() 去掉左边空白字符 SELECT ltrim(&rsquo; AB cD f &lsquo;);   repeat() 重复输出字符串 SELECT repeat(&lsquo;A&rsquo;, 3);   replace() 替换字符串 SELECT replace(&lsquo;ABBCD&rsquo;, &lsquo;BB&rsquo;, &lsquo;W&rsquo;);   reverse() 翻转输出字符串 SELECT reverse(&lsquo;abcd&rsquo;);   left() 返回左边字符串 SELECT left(&lsquo;abcdf&rsquo;, 2);   right() 返回右边字符串 SELECT right(&lsquo;abcdf&rsquo;, 2);   rtrim() 去掉右边空白字符 SELECT rtrim(&rsquo; AB cD f &lsquo;);   substr()/substring() 截取子字符串 SELECT substr(&lsquo;Quadratically&rsquo;,5);\nSELECT substr(&lsquo;Quadratically&rsquo;,5,6);   trim() 去掉空白字符 SELECT trim(&rsquo; AB cD f &lsquo;);   ucase()/upper() 转换大写 SELECT upper(&lsquo;ABcDef&rsquo;);    还是通过实例分析他们的使用\n查询班主任信息，输出3遍老师信息  分析：查询老师信息，输出3遍老师信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：3 遍班主任信息 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 班主任 * 3\nfrom 班级;\n  班主任 * 3 由于班主任存储的是字符串类型，重复3次表示为 repeat(c_head_teacher, 3)   得到如下 SQL\nselect repeat(c_head_teacher, 3) from class;  执行得到如下结果\n试试\n查询班级名称长度并将班级名称翻转输出  数值计算、数值函数 数值计算操作符\n   操作符 描述 实例     + 加 select 2+3;   - 减 或 取反 select 2-1, -2;   * 乘 select 2*3;   / 或 div 除 select 2&frasl;4, 2 div 4;   % 或 mod 取余 或 取模 select 2%4, 2 mod 4;    数值计算函数\n   函数 描述 实例     abs() 绝对值 SELECT abs(-10), abs(9);   ceil()/ceilling() 上取整 SELECT ceiling(3.4), ceil(3.5), ceil(3.6);   conv() 进制转换 SELECT conv(10,10 ,2), conv(10,2 ,10);   exp() 自然数数 e 的 n 次方 SELECT exp(1), exp(0), exp(-1);   floor() 下取整 SELECT floor(3.4), floor(3.5), floor(3.6);   pow()/power() 指数函数 SELECT POW(1,3), pow(2,3), pow(4,2);   round() 四舍五入取整 SELECT round(3.4), round(3.5), round(3.6);   rand() 随机数 SELECT rand(), rand()*10;   mod() 取余/取模 SELECT mod(25, 7), 25 % 7, mod(25.4, 7), 25.4 % 7;   pi() PI 值 SELECT pi(), pi()+0.0000000000;    查询所有学生姓名和年龄，将所有学生的年龄翻倍，且年龄大的在后面  分析：查询所有学生信息，将所有学生的年龄翻倍，且年龄大的在后面\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：姓名、年龄翻倍 过滤条件：无 排序字段：龄大的在后面 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 姓名, 年龄翻倍\nfrom 学生\norder by 龄大的在后面;\n  得到如下 SQL\nselect s_name, s_age * 2 from student order by s_age * 2 asc;  执行得到如下结果\n查询学生年龄和姓名，并按照年龄的 1&frasl;3 下取整输出  分析：查询学生年龄和姓名，并按照年龄的的 1&frasl;3 下取整输出\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：姓名、年龄的 1&frasl;3 下取整 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 姓名, 年龄的 1&frasl;3 下取整\nfrom 学生\norder by 龄大的在后面;\n 年龄的 1&frasl;3 下取整 先求出年龄的 1/3，再用 下取整函数处理\n 得到如下 SQL\nselect s_name, floor(s_age/3) from student;  执行得到如下结果\n试试\n查询所有10岁的学生姓名和年龄，要求输出2遍姓名和5年后的年龄  日期时间函数    函数 描述 实例     now() 当前日期时间 select now(), CURRENT_TIMESTAMP();   curtime() 当前时间 select curtime();   curdate() 当前日期 select curdate();   from_unixtime() 从时间戳到日期 select from_unixtime(1);   unix_timestamp() 返回日期时间戳 select unix_timestamp(now());   time() 从时间里面获取时间部分 select time(now())   date() 从时间里面获取日期部分 select now(), date(now());   date_format() 格式化日期/时间数据\ndate_format(date, format) select date_format(now(),&lsquo;%b %d %Y %h:%i %p&rsquo;),\ndate_format(now(),&lsquo;%m-%d-%Y&rsquo;);   adddate()/date_add() 向日期添加指定的时间间隔\nadddate(date, interval num unit) select date_add(now() ,interval 45 DAY), adddate(now() ,interval 45 DAY);   subdate()/date_sub() 向日期减去指定的时间间隔\nsubdate(date, interval num Type) select date_sub(now() ,interval 45 DAY), subdate(now() ,interval 45 DAY);   datediff() 返回两个日期之间的天数 SELECT datediff(&lsquo;2018-01-30&rsquo;,&lsquo;2018-04-27&rsquo;);    还有很多的时间获取函数，这里不再列举，在用到的时候查下文件就行 《MySQL 日期时间函数》\n时间 ADD 和 SUB 的 unit 可取值有    Type 值     MICROSECOND   SECOND   MINUTE   HOUR   DAY   WEEK   MONTH   QUARTER   YEAR   SECOND_MICROSECOND   MINUTE_MICROSECOND   MINUTE_SECOND   HOUR_MICROSECOND   HOUR_SECOND   HOUR_MINUTE   DAY_MICROSECOND   DAY_SECOND   DAY_MINUTE   DAY_HOUR   YEAR_MONTH    时间 format 可使用的格式有：    格式 描述     %a 缩写星期名   %b 缩写月名   %c 月，数值   %D 带有英文前缀的月中的天   %d 月的天，数值（00-31）   %e 月的天，数值（0-31）   %f 微秒   %H 小时（00-23）   %h 小时（01-12）   %I 小时（01-12）   %i 分钟，数值（00-59）   %j 年的天（001-366）   %k 小时（0-23）   %l 小时（1-12）   %M 月名   %m 月，数值（00-12）   %p AM 或 PM   %r 时间，12-小时（hh:mm:ss AM 或 PM）   %S 秒（00-59）   %s 秒（00-59）   %T 时间, 24-小时（hh:mm:ss）   %U 周（00-53）星期日是一周的第一天   %u 周（00-53）星期一是一周的第一天   %V 周（01-53）星期日是一周的第一天，与 %X 使用   %v 周（01-53）星期一是一周的第一天，与 %x 使用   %W 星期名   %w 周的天（0=星期日, 6=星期六）   %X 年，其中的星期日是周的第一天，4 位，与 %V 使用   %x 年，其中的星期一是周的第一天，4 位，与 %v 使用   %Y 年，4 位   %y 年，2 位    查询学生在哪一年出生，年份早的排在前面  分析：查询学生在哪一年出生，年份早的排在前面\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：在哪一年出生 过滤条件：无 排序字段：年份早的排在前面 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 在哪一年出生\nfrom 学生\norder by 年份早的排在前面;\n 在哪一年出生 这个信息是在生日字段里面，生日字段是包含了年月日信息，只需要使用 year 函数处理就能得到年了：year(s_birthday)\n 得到 SQL 语句\nselect year(s_birthday) from student order by year(s_birthday) asc;  执行得到如下结果\n试试\n大家发现学生表里面有年龄字段和生日字段，上面我们使用了生日计算出生年，现在使用年龄计算出生年，看看会是什么结果，应该是和生日不一样的（这里是故意的，后面在修改数据时候会改过来） 计算班级从开班时间到结束时间持续了多少天  流程控制函数 MySQL 流程控制函数有 4 个：CASE、IF()、IFNULL 、NULLIF ，我自己平时用的最多的是 CASE ，这里只演示 CASE 的使用，其他几个在一个特定的场景下使用，到时候遇到了查下文档吧。\nCASE 语法 CASE 语句有2中语法，一种是值判断，一种是条件判断。\n值判断语法 CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END  条件判断语法 CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END  查询学生性别和姓名，性别输出文中文男和女（0：女，1：男） select s_name, case c_sex when 0 then '女' when 1 then '男' end as '性别' from student  查询学习性别和年龄段，年龄段输出为：1~10的为小，11~15的中，16~20的大 select s_name, case when s_age&gt;=1 and s_age&lt;=10 then '小' when s_age&gt;=11 and s_age&lt;=15 then '中' when s_age&gt;=16 and s_age&lt;=20 then '大' end as '年龄段' from student;  试试\n查询学生生日的月份，要求中文数值输出月份(比如：一月、二月、三月)   上面最后两个 SQL 没有给出详细的分析过程，对于这个分析过程可以自行按照之前的模式进行，这种分析模式掌握过后，不论多复杂的需求和 SQL 都可以做到游刃有余，所以大家一定要掌握。对于后面简单的 SQL 不再给出详细分析过程，分析过程只针对复杂 SQL 和关键部分，如果大家对于哪个问题和SQL 需要分析过程的，可以在后面留言或联系我。\n 总结  计算字段、计算列、虚拟列 常用字符串函数 常用数值计算、数值函数 常用日期时间函数 流程控制函数：case 语句的 2 种格式 ", "content_s": "我们 之前 已经 学习 很多 的   SQL   查询 支持 ， 但是 这些 查询 只能 原样 返回 数据 据库 数据库 里 存储 的 数据 ， 那 如果 我们 需要 对 这些 数据 做 一个 处理 怎么 怎么办 呢 ？ 比如 ： 合并 2 个 字 段 、 返回 的 学生 年龄 2 倍 等 。 这 就是 今天 要 一起 学习 的 内容 ： 数据 操作 函数 。 每个   RDBMS   提供 提供 的 函数 操作 都 不 一样 ， 这里 还是 以   MySQL   为 例子 讲解 ， 其他 的   RDBMS   请 查阅 相关 文档 。 由于 数据 处理 数据处理 函数 比较 多 ， 这里 没有 办法 全部 覆盖 ， 只会 列举 我们 常用 的 一些 操作 函数 ， 我 把 他们 分成   5   类 ： 字符 字符串 函数 、 数值 函数 、 时间 函数 、 统计 函数 、 流程 控制 函数 。 想 知道 更 多 函数 详情 详情请 参考   MySQL   官方 文档 。 \n 知识 要点 ： \n   计算 字 段 、 计算 列 、 虚拟 列   常用 字符 字符串 函数   常用 数值 计算 、 数值 函数   常用 日期 时间 函数   流程 控制 函数     这里 列举 的 使 平时 常用 的   4   中 类型 函数 分类 ， 另外 的 统计 函数 将 在 下次 单独 说明 。 \n \n 在 查询 里面 使用 计算 表达 达式 表达式 或 函数 表达 达式 表达式 的 列 称为 计算 列 或 计算 字 段 。 它 是 一个 虚拟 列 ， 数据 据库 数据库 并 不 实际 存储 在 表中 ， 计算 列 的 表达 达式 表达式 可以 使用 其他 列中 的 数据 来 计算 其 所属 列 的 值 。 \n 字符 字符串 函数   下面 是 常用 的 一些 字符 处理 函数 处理函数 \n       函数   描述   实例           concat ( )   拼接 字符 字符串   SELECT   concat ( & lsquo ; Hello & rsquo ; ,   & lsquo ; ,   & lsquo ; ,   & lsquo ; World & rsquo ; , & lsquo ; ! & rsquo ; ) ;       format ( )   格式 格式化 数字 到 字符 字符串   SELECT   format ( 12332.1 , 4 ) ;       length ( )   返回 字符 字符串 长度   SELECT   length ( & lsquo ; xxx & rsquo ; ) ;       lcase ( ) / lower ( )   转换 小写   SELECT   lower ( & lsquo ; ABcDef & rsquo ; ) ;       ltrim ( )   去掉 左边 空白 字符   SELECT   ltrim ( & rsquo ;   AB   cD   f   & lsquo ; ) ;       repeat ( )   重复 输出 字符 字符串   SELECT   repeat ( & lsquo ; A & rsquo ; ,   3 ) ;       replace ( )   替换 字符 字符串   SELECT   replace ( & lsquo ; ABBCD & rsquo ; ,   & lsquo ; BB & rsquo ; ,   & lsquo ; W & rsquo ; ) ;       reverse ( )   翻转 输出 字符 字符串   SELECT   reverse ( & lsquo ; abcd & rsquo ; ) ;       left ( )   返回 左边 字符 字符串   SELECT   left ( & lsquo ; abcdf & rsquo ; ,   2 ) ;       right ( )   返回 右边 字符 字符串   SELECT   right ( & lsquo ; abcdf & rsquo ; ,   2 ) ;       rtrim ( )   去掉 右边 空白 字符   SELECT   rtrim ( & rsquo ;   AB   cD   f   & lsquo ; ) ;       substr ( ) / substring ( )   截取 子 字符 字符串   SELECT   substr ( & lsquo ; Quadratically & rsquo ; , 5 ) ; \n SELECT   substr ( & lsquo ; Quadratically & rsquo ; , 5 , 6 ) ;       trim ( )   去掉 空白 字符   SELECT   trim ( & rsquo ;   AB   cD   f   & lsquo ; ) ;       ucase ( ) / upper ( )   转换 大写   SELECT   upper ( & lsquo ; ABcDef & rsquo ; ) ;         还是 通过 实例 分析 他们 的 使用 \n 查询 班主 主任 班主任 信息 ， 输出 3 遍 老师 信息     分析 ： 查询 老师 信息 ， 输出 3 遍 老师 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 3   遍 班主 主任 班主任 信息   过滤 条件 ： 无   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   班主 主任 班主任   *   3 \n from   班级 ; \n     班主 主任 班主任   *   3   由于 班主 主任 班主任 存储 的 是 字符 字符串 类型 ， 重复 3 次 表示 为   repeat ( c _ head _ teacher ,   3 )       得到 如下   SQL \n select   repeat ( c _ head _ teacher ,   3 )   from   class ;     执行 得到 如下 结果 \n 试试 \n 查询 班级 名称 长度 并 将 班级 名称 翻转 输出     数值 计算 、 数值 函数   数值 计算 操作 操作符 \n       操作 操作符   描述   实例           +   加   select   2 + 3 ;       -   减   或   取反   select   2 - 1 ,   - 2 ;       *   乘   select   2 * 3 ;       /   或   div   除   select   2 & frasl ; 4 ,   2   div   4 ;       %   或   mod   取余   或   取模   select   2% 4 ,   2   mod   4 ;         数值 计算 函数 \n       函数   描述   实例           abs ( )   绝对 绝对值   SELECT   abs ( - 10 ) ,   abs ( 9 ) ;       ceil ( ) / ceilling ( )   上 取整   SELECT   ceiling ( 3.4 ) ,   ceil ( 3.5 ) ,   ceil ( 3.6 ) ;       conv ( )   进制 转换   SELECT   conv ( 10 , 10   , 2 ) ,   conv ( 10 , 2   , 10 ) ;       exp ( )   自然 自然数 数   e   的   n   次方   SELECT   exp ( 1 ) ,   exp ( 0 ) ,   exp ( - 1 ) ;       floor ( )   下 取整   SELECT   floor ( 3.4 ) ,   floor ( 3.5 ) ,   floor ( 3.6 ) ;       pow ( ) / power ( )   指数 函数 指数函数   SELECT   POW ( 1 , 3 ) ,   pow ( 2 , 3 ) ,   pow ( 4 , 2 ) ;       round ( )   四舍五入 取整   SELECT   round ( 3.4 ) ,   round ( 3.5 ) ,   round ( 3.6 ) ;       rand ( )   随机 机数 随机数   SELECT   rand ( ) ,   rand ( ) * 10 ;       mod ( )   取余 / 取模   SELECT   mod ( 25 ,   7 ) ,   25   %   7 ,   mod ( 25.4 ,   7 ) ,   25.4   %   7 ;       pi ( )   PI   值   SELECT   pi ( ) ,   pi ( ) + 0.0000000000 ;         查询 所有 学生 姓名 和 年龄 ， 将 所有 学生 的 年龄 翻倍 ， 且 年龄 大 的 在 后面     分析 ： 查询 所有 学生 信息 ， 将 所有 学生 的 年龄 翻倍 ， 且 年龄 大 的 在 后面 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 姓名 、 年龄 翻倍   过滤 条件 ： 无   排序 字 段 ： 龄 大 的 在 后面   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   姓名 ,   年龄 翻倍 \n from   学生 \n order   by   龄 大 的 在 后面 ; \n     得到 如下   SQL \n select   s _ name ,   s _ age   *   2   from   student   order   by   s _ age   *   2   asc ;     执行 得到 如下 结果 \n 查询 学生 年龄 和 姓名 ， 并 按照 年龄 的   1 & frasl ; 3   下 取整 输出     分析 ： 查询 学生 年龄 和 姓名 ， 并 按照 年龄 的 的   1 & frasl ; 3   下 取整 输出 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 姓名 、 年龄 的   1 & frasl ; 3   下 取整   过滤 条件 ： 无   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   姓名 ,   年龄 的   1 & frasl ; 3   下 取整 \n from   学生 \n order   by   龄 大 的 在 后面 ; \n   年龄 的   1 & frasl ; 3   下 取整   先求 出 年龄 的   1 / 3 ， 再用   下 取整 函数 处理 \n   得到 如下   SQL \n select   s _ name ,   floor ( s _ age / 3 )   from   student ;     执行 得到 如下 结果 \n 试试 \n 查询 所有 10 岁 的 学生 姓名 和 年龄 ， 要求 输出 2 遍 姓名 和 5 年 后 的 年龄     日期 时间 函数         函数   描述   实例           now ( )   当前 日期 时间   select   now ( ) ,   CURRENT _ TIMESTAMP ( ) ;       curtime ( )   当前 时间   select   curtime ( ) ;       curdate ( )   当前 日期   select   curdate ( ) ;       from _ unixtime ( )   从 时间 戳 到 日期   select   from _ unixtime ( 1 ) ;       unix _ timestamp ( )   返回 日期 时间 戳   select   unix _ timestamp ( now ( ) ) ;       time ( )   从 时间 里面 获取 时间 部分   select   time ( now ( ) )       date ( )   从 时间 里面 获取 日期 部分   select   now ( ) ,   date ( now ( ) ) ;       date _ format ( )   格式 格式化 日期 / 时间 数据 \n date _ format ( date ,   format )   select   date _ format ( now ( ) , & lsquo ; % b   % d   % Y   % h : % i   % p & rsquo ; ) , \n date _ format ( now ( ) , & lsquo ; % m - % d - % Y & rsquo ; ) ;       adddate ( ) / date _ add ( )   向 日期 添加 指定 的 时间 间隔 \n adddate ( date ,   interval   num   unit )   select   date _ add ( now ( )   , interval   45   DAY ) ,   adddate ( now ( )   , interval   45   DAY ) ;       subdate ( ) / date _ sub ( )   向 日期 减去 指定 的 时间 间隔 \n subdate ( date ,   interval   num   Type )   select   date _ sub ( now ( )   , interval   45   DAY ) ,   subdate ( now ( )   , interval   45   DAY ) ;       datediff ( )   返回 两个 日期 之间 的 天数   SELECT   datediff ( & lsquo ; 2018 - 01 - 30 & rsquo ; , & lsquo ; 2018 - 04 - 27 & rsquo ; ) ;         还有 很多 的 时间 获取 函数 ， 这里 不再 列举 ， 在 用到 的 时候 查下 文件 就行   《 MySQL   日期 时间 函数 》 \n 时间   ADD   和   SUB   的   unit   可 取值 有         Type   值           MICROSECOND       SECOND       MINUTE       HOUR       DAY       WEEK       MONTH       QUARTER       YEAR       SECOND _ MICROSECOND       MINUTE _ MICROSECOND       MINUTE _ SECOND       HOUR _ MICROSECOND       HOUR _ SECOND       HOUR _ MINUTE       DAY _ MICROSECOND       DAY _ SECOND       DAY _ MINUTE       DAY _ HOUR       YEAR _ MONTH         时间   format   可 使用 的 格式 有 ：         格式   描述           % a   缩写 星期 名       % b   缩写 月 名       % c   月 ， 数值       % D   带有 英文 前缀 的 月 中 的 天       % d   月 的 天 ， 数值 （ 00 - 31 ）       % e   月 的 天 ， 数值 （ 0 - 31 ）       % f   微秒       % H   小时 （ 00 - 23 ）       % h   小时 （ 01 - 12 ）       % I   小时 （ 01 - 12 ）       % i   分钟 ， 数值 （ 00 - 59 ）       % j   年 的 天 （ 001 - 366 ）       % k   小时 （ 0 - 23 ）       % l   小时 （ 1 - 12 ）       % M   月 名       % m   月 ， 数值 （ 00 - 12 ）       % p   AM   或   PM       % r   时间 ， 12 - 小时 （ hh : mm : ss   AM   或   PM ）       % S   秒 （ 00 - 59 ）       % s   秒 （ 00 - 59 ）       % T   时间 ,   24 - 小时 （ hh : mm : ss ）       % U   周 （ 00 - 53 ） 星期 期日 星期日 是 一周 的 第一 一天 第一天       % u   周 （ 00 - 53 ） 星期 星期一 是 一周 的 第一 一天 第一天       % V   周 （ 01 - 53 ） 星期 期日 星期日 是 一周 的 第一 一天 第一天 ， 与   % X   使用       % v   周 （ 01 - 53 ） 星期 星期一 是 一周 的 第一 一天 第一天 ， 与   % x   使用       % W   星期 名       % w   周 的 天 （ 0 = 星期 期日 星期日 ,   6 = 星期 星期六 ）       % X   年 ， 其中 的 星期 期日 星期日 是 周 的 第一 一天 第一天 ， 4   位 ， 与   % V   使用       % x   年 ， 其中 的 星期 星期一 是 周 的 第一 一天 第一天 ， 4   位 ， 与   % v   使用       % Y   年 ， 4   位       % y   年 ， 2   位         查询 学生 在 一年 哪一年 出生 ， 年份 早 的 排 在 前面     分析 ： 查询 学生 在 一年 哪一年 出生 ， 年份 早 的 排 在 前面 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 学生   得到 哪些 信息 ： 在 一年 哪一年 出生   过滤 条件 ： 无   排序 字 段 ： 年份 早 的 排 在 前面   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   在 一年 哪一年 出生 \n from   学生 \n order   by   年份 早 的 排 在 前面 ; \n   在 一年 哪一年 出生   这个 信息 是 在 生日 字 段 里面 ， 生日 字段 是 包含 了 年月日 信息 ， 只 需要 使用   year   函数 处理 就 能 得到 年 了 ： year ( s _ birthday ) \n   得到   SQL   语句 \n select   year ( s _ birthday )   from   student   order   by   year ( s _ birthday )   asc ;     执行 得到 如下 结果 \n 试试 \n 大家 发现 学生 表 里面 有 年龄 字段 和 生日 字 段 ， 上面 我们 使用 了 生日 计算 出生 年 ， 现在 使用 年龄 计算 出生 年 ， 看看 会 是 什么 结果 ， 应该 是 和 生日 不 一样 的 （ 这里 是 故意 的 ， 后面 在 修改 数据 时候 会 改过 过来 改过来 ）   计算 班级 从 开班 时间 到 结束 时间 持续 了 多少 天     流程 控制 函数   MySQL   流程 控制 函数 有   4   个 ： CASE 、 IF ( ) 、 IFNULL   、 NULLIF   ， 我 自己 平时 用 的 最 多 的 是   CASE   ， 这里 只 演示   CASE   的 使用 ， 其他 几个 在 一个 特定 的 场景 下 使用 ， 时候 到时候 遇到 了 查下 文档 吧 。 \n CASE   语法   CASE   语句 有 2 中 语法 ， 一种 是 值 判断 ， 一种 是 条件 判断 。 \n 值 判断 语法   CASE   value   WHEN   [ compare _ value ]   THEN   result   [ WHEN   [ compare _ value ]   THEN   result   ... ]   [ ELSE   result ]   END     条件 判断 语法   CASE   WHEN   [ condition ]   THEN   result   [ WHEN   [ condition ]   THEN   result   ... ]   [ ELSE   result ]   END     查询 学生 性别 和 姓名 ， 性别 输出 文 中文 男和女 （ 0 ： 女 ， 1 ： 男 ）   select   s _ name ,   case   c _ sex   when   0   then   ' 女 '   when   1   then   ' 男 '   end   as   ' 性别 '   from   student     查询 学习 性别 和 年龄 年龄段 ， 年龄 年龄段 输出 为 ： 1 ~ 10 的 为 小 ， 11 ~ 15 的 中 ， 16 ~ 20 的 大   select   s _ name ,   case   when   s _ age & gt ; = 1   and   s _ age & lt ; = 10   then   ' 小 '   when   s _ age & gt ; = 11   and   s _ age & lt ; = 15   then   ' 中 '   when   s _ age & gt ; = 16   and   s _ age & lt ; = 20   then   ' 大 '   end   as   ' 年龄 年龄段 '   from   student ;     试试 \n 查询 学生 生日 的 月份 ， 要求 中文 数值 输出 月份 ( 比如 ： 一月 、 二月 、 三月 )       上面 最后 两个   SQL   没有 给出 详细 的 分析 过程 ， 对于 这个 分析 过程 可以 自行 按照 之前 的 模式 进行 ， 这种 分析 模式 掌握 过后 ， 不论 多 复杂 的 需求 和   SQL   都 可以 做到 游刃 有余 游刃有余 ， 所以 大家 一定 要 掌握 。 对于 后面 简单 的   SQL   不再 给出 详细 细分 分析 详细分析 过程 ， 分析 过程 只 针对 复杂   SQL   和 关键 部分 ， 如果 大家 对于 哪个 问题 和 SQL   需要 分析 过程 的 ， 可以 在 后面 留言 或 联系 我 。 \n   总结     计算 字 段 、 计算 列 、 虚拟 列   常用 字符 字符串 函数   常用 数值 计算 、 数值 函数   常用 日期 时间 函数   流程 控制 函数 ： case   语句 的   2   种 格式  ", "title_s": "小白学   SQL   第五 五天 第五天 ： 数据 操作 函数"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/4-query-where/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第四天：数据过滤查询", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/4-query-where/", "content": "在第三天的时候学习了数据的基本查询结构，包括：查询指定列，返回指定大小结果集，数据排序，数据去重。今天将学习查询里面另外一个基础且重要的查询结构：过滤查询（也叫条件查询），可以说现今你能看到的所有涉及到 RDBMS 软件一定都有 过滤查询 。所以今天的内容一定要掌握，也是一切用到 RDBMS 系统的所需掌握的基础知识之一。\n今天涉及到的知识要点：\n where子句子结构 数值、时间 字符串匹配： like、百分号（%）通配符、下划线（_）通配符 范围值检查：between 、in 空值查询：is null、not 组合查询：and、or、求值顺序  \nWHERE 子句结构 既然是子句就一定是跟在主句后面，where 子句可以用在 select、update、delete 语句中。今天只会讲解在 select 语句中的使用，update 和 delete 中的使用会在后面 数据插入、修改和删除 中讲解。首先还是来看一下 where 子句在 select 中的结构\nselect [distinct] 列1，列2，... from table_name [where 条件1 [and|or] 条件2 ...] [order by 列1 desc[, 列2 asc]] [limit offset, size];   where 条件1 [and|or] 条件2 … 过滤条件。可以使用逻辑连接符（and 或 or）连接多个条件。\n条件N 每个条件。格式： &lt;列&gt; &lt;操作符&gt; &lt;值&gt;\n 大家可以和前一天的 Select 语句做对比看有什么不同\n操作符    操作符 说明 操作符 说明     = 等于 &gt; 大于   &lt;&gt; 不等于 &gt;= 大于等于   != 不等于 !&gt; 不大于   &lt; 小于 between 在指定两个值之间   &lt;= 小于等于 is null 为null的值   !&lt; 不小于 like 匹配   and 逻辑与 or 逻辑或   not 逻辑非      数值、时间过滤 还记得之前在《数据表创建》时说明的数据类型吗？如果没有什么印象可以转过去浏览一遍。在做数据过滤查询的，我们要关注所使用过滤列的数据类型，判断我们所需要使用的操作符和数值表达方式，我们还是通过实例讲解。\n查询已开学班级的名称和班主任  分析：查询 已开学 班级 的 名称 和 班主任\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：名称、班主任 过滤条件：已开学 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,班主任\nfrom 班级\nwhere 已开学;\n  这里的 已开学 怎么表示呢？我们看班级的创建 SQL，会发现列 c_status 的描述是 班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】\n  在结合*条件格式： &lt;列&gt; &lt;操作符&gt; &lt;值&gt;，这时候就比较清晰了吧：班级状态 是/等于 已开学，班级状态在数据库存的数据类型是 数值型 ，这里也就是 3 。这个时候在将语言翻译成代码表达：c_status = 3 。\n 现在所有需要的信息都收集完成了，组装我们 SQL 语句：\nselect c_name, c_head_teacher from class where c_status = 3;  执行这个语句会的一下结果\n查询标识 id大于10 的班级的标识 id 和名称信息  分析：查询 标识 id大于10** 班级 的 标识 id 和 名称 信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：标识 id，名称 过滤条件：标识 id大于10 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,班主任\nfrom 班级\nwhere 标识 id 大于 10;\n 结合上面的操作符描述 标识 id 大于 10 的代码标识：c_id &gt; 10\n 所以的 SQL 语句：\nselect c_name, c_head_teacher from class where c_id &gt; 10;  执行这个语句会的一下结果\n查询在2018年4月2日开班的班级名称、标识 id和开班时间  分析：查询 在 在 2018年4月2日开班 的 班级名称 和 标识 id\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：标识 id，名称，开班时间 过滤条件：在 2018年4月2日开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,标识 id,开班时间\nfrom 班级\nwhere 在 2018年4月2日开班;\n 在这里我们发现 开班时间 在表里面的存储类型是日期 date 类型，这里就涉及到日志的表示方式，以下是默认表示方式:\n    日志类型 表示格式 例子     year YYYY 或 YY 第一种是直接插入4位字符串或者4位数字（推荐）。\n第二种是插入2位字符串。如插入‘00’~‘69’，则相当于插入2000~2069；如果插入‘70’~‘99’，则相当于插入1970~1999。第二种情况下插入的如果是‘0’，则与插入‘00’效果相同，都是表示2000年。\n第三种是插入2位数字，它与第二种（插入两位字符串）不同之处仅在于：如果插入的是一位数字0，则表示的是0000，而不是2000年。所以在给YEAR类型赋值时，一定要分清0和‘0’，虽然两者相差个引号，但实际效果确实相差了2000年。   time HH:MM:SS 14:23:23   date YYYY-MM-DD 2018-04-23   datetime YYYY-MM-DD HH:MM:SS 2018-04-23 14:23:23   timestamp YYYY-MM-DD HH:MM:SS A、CURRENT_TIMESTAMP或 NULL或无任何输入 这时系统会自动填入当前 timestamp 值（这个需要创建列时设置）\nB、`2018-04-23 14:23:23\n注意： timestamp数值是与时区相关的。    通过以上分析，得到 SQL 语句：\nselect c_name, c_status, c_start_time, c_end_time from class where c_start_time='2018-04-02';  执行这个语句会的一下结果\n试试\n查找还未结束的且开始时间最晚的前6个班级的名称、状态、开始时间和结束时间信息  字符串匹配 首先字符串在 SQL 中需要单引号包裹起来，比如：'字符串1'、'hello world!'。\n查询班主任姓名为 老师10 的班级信息，结束时间最晚的在前面  分析：查询 在 班主任姓名为 老师10 的 班级信息，结束时间最晚的在前面\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：班主任姓名为 老师10 排序字段：结束时间 -&gt; 倒序（结束时间最晚的在前面） 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 班主任姓名为 老师10\norder by 结束时间 倒序;\n  所以得到 SQL\nselect * from class where c_head_teacher = '老师10' order by c_end_time desc;  执行 sql 得到如下结果\n 在实际使用字符串匹配查询的时候，处理上面例子演示的 精确查找 以外，我们还会有 模糊查找 的需求（也叫 *模糊匹配*）。比如我们常常有 查找姓王的用户 、 查询名字中含有水字的用户 等需求。\n字符串的模糊匹配使用 like 关键字，既然是模式匹配就说明列里面的部分信息我们是不关心的，也不知道他们具体是什么值，这时对于这些不关心的数据我们使用 占位符 。MySQL 数据库支持的占位符有 2 个: % 和 _ ，这两个的比较说明如下：\n   占位符 说明 实例     % 一次匹配多个任意字符 王%：所有以 王 开头的任意长度的数据，例如：王，王x、王 xx\n%王：所有以 王 开头的任意长度的数据，例如：王，x王、xx王\n%王%：所有包含 王 的数据，不论王所在位置   _ 一次匹配一个任意字符 王_：所以以 王 开头的 2 个长度的数据，例如：王 x，王2    \n试试\n大家可以思考一下 %刘_ 是匹配什么样的数据   查询所有以老师开头的班主任信息，结果去重  分析：查询 所有 以老师开头 的 班主任信息，结果去重\n 操作类型：select （查询） 到哪里取数据：班级（班主任信息在班级表里） 得到哪些信息：班主任信息 过滤条件：以 &ldquo;老师&rdquo; 开头的班主任 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 去重 班主任\nfrom 班级\nwhere 以 &ldquo;老师&rdquo; 开头的班主任;\n  所得 SQL\nselect distinct c_head_teacher from class where c_head_teacher like '老师%';  直接结果\n试试\n查询所有姓张且姓名包含三个字的学生信息  空值查询 在数据库里面还存在一种类型：null ，他表示没有值，意味着我们什么都没有输入。注意这个值和 空字符串'' 的区别：'' 标识值是空字符串(有值)；null 标识无值。我们要查询一个列是否包含有无值得数据使用 is null 。大家可以执行下面这个 SQL ，大家可以自行分析一下这个 SQL 所表达的需求\nselect * from class where c_start_time is null;  由于我们现在数据库里面没有无值的数据，所以结果是空的\n现在我们在加入 2 条空值数据，请执行下面的插入 SQL\nINSERT INTO `sql-learn`.`class`(`c_id`, `c_name`, `c_head_teacher`, `c_start_time`, `c_end_time`, `c_status`, `c_created`) VALUES (17, '酱油班1', '酱油老师', NULL, NULL, 3, '2018-04-24 13:03:39'), (18, '酱油班2', '酱油老师', NULL, NULL, 2, '2018-04-24 13:03:33');  插入完成过后，再执行上面的查询 SQL ，这时候就会出现我们刚才插入的 2 条数据：酱油班1 和 酱油班2 。这时我们查询出了所有的 无值 数据，那我们怎么得到所有 有值 数据呢？这里只要我们对过滤条件取反（或叫取非）就可以了：关键字 not 。请大家执行下面 SQL 分析结果：\nselect * from class where not c_start_time is null;   not 关键字就是对某一过滤条件取反，它不仅仅是用在 is null 条件上面，可以用在任何一个过滤条件上，甚至后面的组合查询里面的组合条件也是可以使用的。大家可以将前面实验的 SQL 语句的查询条件上面加上 not 在执行看看结果，是否和你理解的一致。\n建议大家不要随意使用 not ，这个会导致你的 SQL 语句变复制、不易理解，同时导致后面优化 SQL 变得困难。建议只使用在 is null 和 like 操作上。\n 范围查询 前面的所有查询都是单个值查询，现在如果我们知道了 2 个班主任老师的名称：酱油老师 和 *会计老师1*，我们需要查询这 2 个老师的负责的所有班级怎么办呢？用我们的上面的查询都办不到，现在需要一种新的查询类型：范文查询。范围查询有 2 中格式：between start_value and end_value 和 in ，between 表示连续值范围查询，多用在数值和时间范围；in 表示非连续值范围，多用在字符串范围查询。具体我们通过实例分析\n查询 会计老师1 和 酱油老师 2个老师负责的所有班级信息  分析：查询 会计老师1 和 酱油老师 2个老师负责的所有班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：会计老师1 和 酱油老师 (使用 in) 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 会计老师1 和 酱油老师;\n 在这里我们可以看到同时有 2 个值，同时这两个值没有相关性和连续性，所以这里使用 in\n 得到以下 SQL\nselect * from class where c_head_teacher in ('会计老师1', '酱油老师');  执行 SQL 得到以下结果\n查询开班时间在2017-12-03到2018-04-01之间的所有班级信息  分析：查询开班时间在2017-12-03到2018-04-01之间的所有班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：开班时间在2017-12-03到2018-04-01之间（使用 between） 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 开班时间在2017-12-03到2018-04-01之间;\n 在这里我们发现也是 2 个条件值，但是这次的要求是找到 2017-12-03到2018-04-01之间 的所有班级，因为在我们查询数据之前没有办法知道每个班级的具体开班时间，同时从2017-12-03到2018-04-01之间 的所有日期时间点我们没有办法穷举出来（这里可能有人会说可以列举出来，这之间也没有多少天，但是如果我们这里存入的不是天，而是需要精确到秒呢，更进一步这里需要精确到毫秒呢（如创建时间）），所以这里我们就不能用 in 了，需要使用 between\n 通过上面分析，得到如下 SQL\nselect * from class where c_start_time between '2017-12-03' and '2018-04-01';  得到如下结果\n试试\n查询开班时间是 2017-10-09 和 2018-04-02 的班级信息 在 between 语句中的 2 值有包含在查询结果集里面吗？写出 SQL 验证你的结论  组合查询 在前面我们已经学习了很多的过滤条件，但是大家会发现这些条件都是基于某一个属性的单个值或多个值进行查询，那我们如果我们需要同时匹配多个属性的值查询应该怎么办呢？这个时候就需要用到我们接下来学习的 组合查询 了。组合查询顾名思义就是组合了多个过滤条件的查询语句，其中组合的方式有 2 中：and 和 or 。这两个的含义和区别如下：\n   组合方式 含义 实例     and 逻辑与（同时满足） A and B and C：A、B、C 3个条件必须全部为真才满足   or 逻辑或（满足其一） A or B or C：A、B、C 3个条件 只要其中一个为真就满足    下面我们还是通过 2 个实例来具体学习\n查询老师10在2018-04-02这天开班的班级信息  分析：查询老师10在2018-04-02这天开班的班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：老师10 、2018-04-02开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 老师10 、2018-04-02开班;\n 这这里我们看到有 老师10 和 2018-04-02开班 2 个值，我们发现 老师10 是班主任信息字段，而 2018-04-02开班 是开班时间字段，两个不是同一个字段，这样就不能使用上面的范围查询了(between 和 in)。既然是 2 个字段条件，那我们就来分开分析：\n 老师10：要求班主任是老师10 =&gt; c_head_teacher='老师10' 2018-04-02开班：开班时间在2018-04-02 =&gt; c_start_time='2018-04-02'  现在两个条件都分析清楚了，那这两个条件的组合方式是什么呢？根据问题 *老师10在 2018-04-02这天开班*： 必须需要 老师10 在 2018-04-02 这天开班的班级信息，老师和开班时间 2 个条件必须满足，所以组合方式是 and，组合得到的过滤条件就是:c_head_teacher='老师10' and c_start_time='2018-04-02' 。现在所有的分析都完成了，来看我们得到的 SQL 语句\n 所得 SQL 语句\nselect * from class where c_head_teacher='老师10' and c_start_time='2018-04-02';  执行得到以下结果\n查询老师5 或 2018-04-02这天开班的班级信息  分析：查询老师10在2018-04-02这天开班的班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：老师10 或 2018-04-02开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 老师10 或 2018-04-02开班;\n 根据之前的分析这里的两个条件\n c_head_teacher='老师5' c_start_time='2018-04-02'  但是这里这里的组合方式和上面会不一样，有发现吗？这里的需求是: 老师5 或 2018-04-02 ，应该使用的组合方式是 or。\n所以组合得到的过滤条件就是:c_head_teacher='老师5' or c_start_time='2018-04-02'\n 所得 SQL 语句\nselect * from class where c_head_teacher='老师5' or c_start_time='2018-04-02';  执行得到以下结果\n  当组合多个过滤的时候如果同时有 and 和 or 的组合方式，需要注意执行的优先级和先后顺序 sql语句中not and or的执行优先级从高到低依次为: not &gt; and &gt; or\n 执行时从左到右依次执行\n 重要建议 对于不能确定的时候可以使用小括号 () 改变或指明优先级\n 对于同时又 not、and、or 的组合查询始终使用 () 指明优先级\n   试试\n试着把上面使用 in 的查询改成组合查询：查询 会计老师1和酱油老师2个老师负责的所有班级信息 查询姓王且年龄在16岁以下学生和在西安的学生，年龄最小的排在前面  总结 这次的东西有点多，特别是组合查询需要多多联系和实践，\n where子句子结构，操作符 数值、时间：时间的表示方法 字符串匹配： like、百分号（%）通配符、下划线（_）通配符 范围值检查：between … and … 、in 空值查询：is null、not 组合查询：and、or、优先级和求值顺序 ", "content_s": "在 第三 三天 第三天 的 时候 学习 了 数据 的 基本 查询 结构 ， 包括 ： 查询 指定 列 ， 返回 指定 大小 结果 集 ， 数据 排序 ， 数据 去 重 。 今天 将 学习 查询 里面 另外 一个 基础 且 重要 的 查询 结构 ： 过滤 查询 （ 也 叫 条件 查询 ） ， 可以 说 现今 你 能 看到 的 所有 涉及 到   RDBMS   软件 一定 都 有   过滤 查询   。 所以 今天 的 内容 一定 要 掌握 ， 也 是 一切 用到   RDBMS   系统 的 所 需 掌握 的 基础 知识 基础知识 之一 。 \n 今天 涉及 到 的 知识 要点 ： \n   where 子 句子 结构   数值 、 时间   字符 字符串 匹配 ：   like 、 百分 分号 百分号 （ % ） 通配符 、 下划 划线 下划线 （ _ ） 通配符   范围 值 检查 ： between   、 in   空值 查询 ： is   null 、 not   组合 查询 ： and 、 or 、 求值 顺序     \n WHERE   子句 结构   既然 是 子句 就 一定 是 跟 在 主句 后面 ， where   子句 可以 用 在   select 、 update 、 delete   语句 中 。 今天 只会 讲解 在   select   语句 中 的 使用 ， update   和   delete   中 的 使用 会 在 后面   数据 插入 、 修改 和 删除   中 讲解 。 首先 还是 来看 一下   where   子句 在   select   中 的 结构 \n select   [ distinct ]   列 1 ， 列 2 ， ...   from   table _ name   [ where   条件 1   [ and | or ]   条件 2   ... ]   [ order   by   列 1   desc [ ,   列 2   asc ] ]   [ limit   offset ,   size ] ;       where   条件 1   [ and | or ]   条件 2   …   过滤 条件 。 可以 使用 逻辑 连接 连接符 （ and   或   or ） 连接 多个 条件 。 \n 条件 N   每个 条件 。 格式 ：   & lt ; 列 & gt ;   & lt ; 操作 操作符 & gt ;   & lt ; 值 & gt ; \n   大家 可以 和 一天 前一天 的   Select   语句 做 对比 看 有 什么 不同 \n 操作 操作符         操作 操作符   说明   操作 操作符   说明           =   等于   & gt ;   大于       & lt ; & gt ;   不 等于   & gt ; =   大于 等于       ! =   不 等于   ! & gt ;   不 大于       & lt ;   小于   between   在 指定 两个 值 之间       & lt ; =   小于 等于   is   null   为 null 的 值       ! & lt ;   不 小于   like   匹配       and   逻辑 与   or   逻辑 或       not   逻辑 非             数值 、 时间 过滤   还 记得 之前 在 《 数据 数据表 创建 》 时 说明 的 数据 类型 数据类型 吗 ？ 如果 没有 什么 印象 可以 转过 去 浏览 一遍 。 在 做 数据 过滤 查询 的 ， 我们 要 关注 所 使用 过滤 列 的 数据 类型 数据类型 ， 判断 我们 所 需要 使用 的 操作 操作符 和 数值 表达 方式 表达方式 ， 我们 还是 通过 实例 讲解 。 \n 查询 已 开学 班级 的 名称 和 班主 主任 班主任     分析 ： 查询   已 开学   班级   的   名称   和   班主 主任 班主任 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 名称 、 班主 主任 班主任   过滤 条件 ： 已 开学   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称 , 班主 主任 班主任 \n from   班级 \n where   已 开学 ; \n     这里 的   已 开学   怎么 表示 呢 ？ 我们 看 班级 的 创建   SQL ， 会 发现 列   c _ status   的 描述 是   班级 状态 【 0 ： 报名 未 开始 ， 1 ： 报名 中 ， 2 ： 报名 完成 ， 3 ： 已 开学 ， 4 ： 已 结业 】 \n     在 结合 * 条件 格式 ：   & lt ; 列 & gt ;   & lt ; 操作 操作符 & gt ;   & lt ; 值 & gt ; ， 这时 时候 这时候 就 比较 清晰 了 吧 ： 班级 状态   是 / 等于   已 开学 ， 班级 状态 在 数据 据库 数据库 存 的 数据 类型 数据类型 是   数值 型   ， 这里 也 就是   3   。 这个 时候 在 将 语言 翻译 译成 翻译成 代码 表达 ： c _ status   =   3   。 \n   现在 所有 需要 的 信息 都 收集 完成 了 ， 组装 我们   SQL   语句 ： \n select   c _ name ,   c _ head _ teacher   from   class   where   c _ status   =   3 ;     执行 这个 语句 会 的 一下 结果 \n 查询 标识   id 大于 10   的 班级 的 标识   id   和 名称 信息     分析 ： 查询   标识   id 大于 10 * *   班级   的   标识   id   和   名称   信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 标识   id ， 名称   过滤 条件 ： 标识   id 大于 10   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称 , 班主 主任 班主任 \n from   班级 \n where   标识   id   大于   10 ; \n   结合 上面 的 操作 操作符 描述   标识   id   大于   10   的 代码 标识 ： c _ id   & gt ;   10 \n   所以 的   SQL   语句 ： \n select   c _ name ,   c _ head _ teacher   from   class   where   c _ id   & gt ;   10 ;     执行 这个 语句 会 的 一下 结果 \n 查询 在 2018 年 4 月 2 日 开班 的 班级 名称 、 标识   id 和 开班 时间     分析 ： 查询   在   在   2018 年 4 月 2 日 开班   的   班级 名称   和   标识   id \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 标识   id ， 名称 ， 开班 时间   过滤 条件 ： 在   2018 年 4 月 2 日 开班   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称 , 标识   id , 开班 时间 \n from   班级 \n where   在   2018 年 4 月 2 日 开班 ; \n   在 这里 我们 发现   开班 时间   在 表 里面 的 存储 类型 是 日期   date   类型 ， 这里 就 涉及 到 日志 的 表示 方式 ， 以下 是 默认 表示 方式 : \n         日志 类型   表示 格式   例子           year   YYYY   或   YY   第一 一种 第一种 是 直接 接插 插入 直接插入 4 位 字符 字符串 或者 4 位 数字 （ 推荐 ） 。 \n 第二 二种 第二种 是 插入 2 位 字符 字符串 。 如 插入 ‘ 00 ’ ~ ‘ 69 ’ ， 则 相当 当于 相当于 插入 2000 ~ 2069 ； 如果 插入 ‘ 70 ’ ~ ‘ 99 ’ ， 则 相当 当于 相当于 插入 1970 ~ 1999 。 第二 二种 第二种 情况 下 插入 的 如果 是 ‘ 0 ’ ， 则 与 插入 ‘ 00 ’ 效果 相同 ， 都 是 表示 2000 年 。 \n 第三 三种 第三种 是 插入 2 位 数字 ， 它 与 第二 二种 第二种 （ 插入 两位 字符 字符串 ） 不同 之处 不同之处 仅 在于 ： 如果 插入 的 是 一位 数字 0 ， 则 表示 的 是 0000 ， 而 不是 2000 年 。 所以 在 给 YEAR 类型 赋值 时 ， 一定 要 分清 0 和 ‘ 0 ’ ， 虽然 两者 相差 个 引号 ， 但 实际 效果 实际效果 确实 相差 了 2000 年 。       time   HH : MM : SS   14 : 23 : 23       date   YYYY - MM - DD   2018 - 04 - 23       datetime   YYYY - MM - DD   HH : MM : SS   2018 - 04 - 23   14 : 23 : 23       timestamp   YYYY - MM - DD   HH : MM : SS   A 、 CURRENT _ TIMESTAMP 或   NULL 或 无 任何 输入   这时 系统 会 自动 填入 当前   timestamp   值 （ 这个 需要 创建 列时 设置 ） \n B 、 ` 2018 - 04 - 23   14 : 23 : 23 \n 注意 ：   timestamp 数值 是 与 时区 相关 的 。         通过 以上 分析 ， 得到   SQL   语句 ： \n select   c _ name ,   c _ status ,   c _ start _ time ,   c _ end _ time   from   class   where   c _ start _ time = ' 2018 - 04 - 02 ' ;     执行 这个 语句 会 的 一下 结果 \n 试试 \n 查找 还 未 结束 的 且 开始 时间 最晚 的 前 6 个 班级 的 名称 、 状态 、 开始 时间 和 结束 时间 信息     字符 字符串 匹配   首先 字符 字符串 在   SQL   中 需要 引号 单引号 包裹 起来 ， 比如 ： ' 字符 字符串 1 ' 、 ' hello   world ! ' 。 \n 查询 班主 主任 班主任 姓名 为   老师 10   的 班级 信息 ， 结束 时间 最晚 的 在 前面     分析 ： 查询   在   班主 主任 班主任 姓名 为   老师 10   的   班级 信息 ， 结束 时间 最晚 的 在 前面 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 班主 主任 班主任 姓名 为   老师 10   排序 字 段 ： 结束 时间   - & gt ;   倒序 （ 结束 时间 最晚 的 在 前面 ）   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   班主 主任 班主任 姓名 为   老师 10 \n order   by   结束 时间   倒序 ; \n     所以 得到   SQL \n select   *   from   class   where   c _ head _ teacher   =   ' 老师 10 '   order   by   c _ end _ time   desc ;     执行   sql   得到 如下 结果 \n   在 实际 使用 字符 字符串 匹配 查询 的 时候 ， 处理 上面 例子 演示 的   精确 查找   以外 ， 我们 还会 有   模糊 查找   的 需求 （ 也 叫   * 模糊 匹配 * ） 。 比如 我们 常常 有   查找 姓王 的 用户   、   查询 名字 中 含有 水字 的 用户   等 需求 。 \n 字符 字符串 的 模糊 匹配 使用   like   关键 关键字 ， 既然 是 模式 匹配 模式匹配 就 说明 列 里面 的 部分 信息 我们 是 不 关心 的 ， 也 不 知道 他们 具体 是 什么 值 ， 这时 对于 这些 不 关心 的 数据 我们 使用   占位 符   。 MySQL   数据 据库 数据库 支持 的 占位 符有   2   个 :   %   和   _   ， 这 两个 的 比较 说明 如下 ： \n       占位 符   说明   实例           %   一次 匹配 多个 任意 字符   王 % ： 所有 以   王   开头 的 任意 长度 的 数据 ， 例如 ： 王 ， 王 x 、 王   xx \n % 王 ： 所有 以   王   开头 的 任意 长度 的 数据 ， 例如 ： 王 ， x 王 、 xx 王 \n % 王 % ： 所有 包含   王   的 数据 ， 不论 王 所在 在位 位置 所在位置       _   一次 匹配 一个 任意 字符   王 _ ： 所以 以   王   开头 的   2   个 长度 的 数据 ， 例如 ： 王   x ， 王 2         \n 试试 \n 大家 可以 思考 一下   % 刘 _   是 匹配 什么 什么样 的 数据       查询 所有 以 老师 开头 的 班主 主任 班主任 信息 ， 结果 去 重     分析 ： 查询   所有   以 老师 开头   的   班主 主任 班主任 信息 ， 结果 去 重 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级 （ 班主 主任 班主任 信息 在 班级 表里 ）   得到 哪些 信息 ： 班主 主任 班主任 信息   过滤 条件 ： 以   & ldquo ; 老师 & rdquo ;   开头 的 班主 主任 班主任   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   去 重   班主 主任 班主任 \n from   班级 \n where   以   & ldquo ; 老师 & rdquo ;   开头 的 班主 主任 班主任 ; \n     所得   SQL \n select   distinct   c _ head _ teacher   from   class   where   c _ head _ teacher   like   ' 老师 % ' ;     直接 结果 \n 试试 \n 查询 所有 姓张 且 姓名 包含 三个 字 的 学生 信息     空值 查询   在 数据 据库 数据库 里面 还 存在 一种 类型 ： null   ， 他 表示 没有 值 ， 意味 意味着 我们 什么 都 没有 输入 。 注意 这个 值 和   空 字符 字符串 ' '   的 区别 ： ' '   标识 值 是 空 字符 字符串 ( 有值 ) ； null   标识 无值 。 我们 要 查询 一个 列 是否 包含 有无 值得 数据 使用   is   null   。 大家 可以 执行 下面 这个   SQL   ， 大家 可以 自行 分析 一下 这个   SQL   所 表达 的 需求 \n select   *   from   class   where   c _ start _ time   is   null ;     由于 我们 现在 数据 据库 数据库 里面 没有 无值 的 数据 ， 所以 结果 是 空 的 \n 现在 我们 在 加入   2   条 空值 数据 ， 请 执行 下面 的 插入   SQL \n INSERT   INTO   ` sql - learn ` . ` class ` ( ` c _ id ` ,   ` c _ name ` ,   ` c _ head _ teacher ` ,   ` c _ start _ time ` ,   ` c _ end _ time ` ,   ` c _ status ` ,   ` c _ created ` )   VALUES   ( 17 ,   ' 酱油 班 1 ' ,   ' 酱油 老师 ' ,   NULL ,   NULL ,   3 ,   ' 2018 - 04 - 24   13 : 03 : 39 ' ) ,   ( 18 ,   ' 酱油 班 2 ' ,   ' 酱油 老师 ' ,   NULL ,   NULL ,   2 ,   ' 2018 - 04 - 24   13 : 03 : 33 ' ) ;     插入 完成 过后 ， 再 执行 上面 的 查询   SQL   ， 这时 时候 这时候 就 会 出现 我们 刚才 插入 的   2   条 数据 ： 酱油 班 1   和   酱油 班 2   。 这时 我们 查询 出 了 所有 的   无值   数据 ， 那 我们 怎么 得到 所有   有值   数据 呢 ？ 这里 只要 我们 对 过滤 条件 取反 （ 或 叫 取非 ） 就 可以 了 ： 关键 关键字   not   。 请 大家 执行 下面   SQL   分析 结果 ： \n select   *   from   class   where   not   c _ start _ time   is   null ;       not   关键 关键字 就是 对 某 一 过滤 条件 取反 ， 它 不仅 仅仅 不仅仅 是 用 在   is   null   条件 上面 ， 可以 用 在 任何 一个 过滤 条件 上 ， 甚至 后面 的 组合 查询 里面 的 组合 条件 也 是 可以 使用 的 。 大家 可以 将 前面 实验 的   SQL   语句 的 查询 条件 上面 加上   not   在 执行 看看 结果 ， 是否 和 你 理解 的 一致 。 \n 建议 大家 不要 随意 使用   not   ， 这个 会 导致 你 的   SQL   语句 变 复制 、 不易 理解 ， 同时 导致 后面 优化   SQL   变得 困难 。 建议 只 使用 在   is   null   和   like   操作 上 。 \n   范围 查询   前面 的 所有 查询 都 是 单个 值 查询 ， 现在 如果 我们 知道 了   2   个 班主 主任 班主任 老师 的 名称 ： 酱油 老师   和   * 会计 老师 1 * ， 我们 需要 查询 这   2   个 老师 的 负责 的 所有 班级 怎么 怎么办 呢 ？ 用 我们 的 上面 的 查询 都 不到 办不到 ， 现在 需要 一种 新 的 查询 类型 ： 范文 查询 。 范围 查询 有   2   中 格式 ： between   start _ value   and   end _ value   和   in   ， between   表示 连续 值 范围 查询 ， 多用 在 数值 和 时间 范围 ； in   表示 非 连续 值 范围 ， 多用 在 字符 字符串 范围 查询 。 具体 我们 通过 实例 分析 \n 查询   会计 老师 1   和   酱油 老师   2 个 老师 负责 的 所有 班级 信息     分析 ： 查询   会计 老师 1   和   酱油 老师   2 个 老师 负责 的 所有 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 会计 老师 1   和   酱油 老师   ( 使用   in )   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   会计 老师 1   和   酱油 老师 ; \n   在 这里 我们 可以 看到 同时 有   2   个值 ， 同时 这 两个 值 没有 相关 相关性 和 连续 连续性 ， 所以 这里 使用   in \n   得到 以下   SQL \n select   *   from   class   where   c _ head _ teacher   in   ( ' 会计 老师 1 ' ,   ' 酱油 老师 ' ) ;     执行   SQL   得到 以下 结果 \n 查询 开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 的 所有 班级 信息     分析 ： 查询 开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 的 所有 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 （ 使用   between ）   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   开班 时间 在 2017 - 12 - 03 到 2018 - 04 - 01 之间 ; \n   在 这里 我们 发现 也 是   2   个 条件 值 ， 但是 这次 的 要求 是 找到   2017 - 12 - 03 到 2018 - 04 - 01 之间   的 所有 班级 ， 因为 在 我们 查询 数据 之前 没有 办法 知道 每个 班级 的 具体 开班 时间 ， 同时 从 2017 - 12 - 03 到 2018 - 04 - 01 之间   的 所有 日期 时间 点 我们 没有 办法 穷举 出来 （ 这里 可能 有人 会 说 可以 列举 出来 ， 这 之间 也 没有 多少 天 ， 但是 如果 我们 这里 存入 的 不是 天 ， 而是 需要 精确 到 秒 呢 ， 一步 进一步 更进一步 这里 需要 精确 到 毫秒 呢 （ 如 创建 时间 ） ） ， 所以 这里 我们 就 不能 用   in   了 ， 需要 使用   between \n   通过 上面 分析 ， 得到 如下   SQL \n select   *   from   class   where   c _ start _ time   between   ' 2017 - 12 - 03 '   and   ' 2018 - 04 - 01 ' ;     得到 如下 结果 \n 试试 \n 查询 开班 时间 是   2017 - 10 - 09   和   2018 - 04 - 02   的 班级 信息   在   between   语句 中 的   2   值有 包含 在 查询 结果 集 里面 吗 ？ 写出   SQL   验证 你 的 结论     组合 查询   在 前面 我们 已经 学习 了 很多 的 过滤 条件 ， 但是 大家 会 发现 这些 条件 都 是 基于 某 一个 属性 的 单个 值 或 多个 值 进行 查询 ， 那 我们 如果 我们 需要 同时 匹配 多个 属性 的 值 查询 应该 怎么 怎么办 呢 ？ 这个 时候 就 需要 用到 我们 接下 下来 接下来 学习 的   组合 查询   了 。 组合 查询 顾名 顾名思义 就是 组合 了 多个 过滤 条件 的 查询 语句 ， 其中 组合 的 方式 有   2   中 ： and   和   or   。 这 两个 的 含义 和 区别 如下 ： \n       组合 方式   含义   实例           and   逻辑 与 （ 同时 满足 ）   A   and   B   and   C ： A 、 B 、 C   3 个 条件 必须 全部 为 真 才 满足       or   逻辑 或 （ 满足 其一 ）   A   or   B   or   C ： A 、 B 、 C   3 个 条件   只要 其中 一个 为 真 就 满足         下面 我们 还是 通过   2   个 实例 来 具体 学习 \n 查询 老师 10 在 2018 - 04 - 02 这天 开班 的 班级 信息     分析 ： 查询 老师 10 在 2018 - 04 - 02 这天 开班 的 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 老师 10   、 2018 - 04 - 02 开班   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   老师 10   、 2018 - 04 - 02 开班 ; \n   这 这里 我们 看到 有   老师 10   和   2018 - 04 - 02 开班   2   个值 ， 我们 发现   老师 10   是 班主 主任 班主任 信息 字 段 ， 而   2018 - 04 - 02 开班   是 开班 时间 字 段 ， 两个 不是 同一 一个 同一个 字 段 ， 这样 就 不能 使用 上面 的 范围 查询 了 ( between   和   in ) 。 既然 是   2   个 字 段 条件 ， 那 我们 就 来 分开 分析 ： \n   老师 10 ： 要求 班主 主任 班主任 是 老师 10   = & gt ;   c _ head _ teacher = ' 老师 10 '   2018 - 04 - 02 开班 ： 开班 时间 在 2018 - 04 - 02   = & gt ;   c _ start _ time = ' 2018 - 04 - 02 '     现在 两个 条件 都 分析 清楚 了 ， 那 这 两个 条件 的 组合 方式 是 什么 呢 ？ 根据 问题   * 老师 10 在   2018 - 04 - 02 这天 开班 * ：   必须 需要   老师 10   在   2018 - 04 - 02   这天 开班 的 班级 信息 ， 老师 和 开班 时间   2   个 条件 必须 满足 ， 所以 组合 方式 是   and ， 组合 得到 的 过滤 条件 就是 : c _ head _ teacher = ' 老师 10 '   and   c _ start _ time = ' 2018 - 04 - 02 '   。 现在 所有 的 分析 都 完成 了 ， 来看 我们 得到 的   SQL   语句 \n   所得   SQL   语句 \n select   *   from   class   where   c _ head _ teacher = ' 老师 10 '   and   c _ start _ time = ' 2018 - 04 - 02 ' ;     执行 得到 以下 结果 \n 查询 老师 5   或   2018 - 04 - 02 这天 开班 的 班级 信息     分析 ： 查询 老师 10 在 2018 - 04 - 02 这天 开班 的 班级 信息 \n   操作 类型 ： select   （ 查询 ）   到 哪里 取 数据 ： 班级   得到 哪些 信息 ： 所有 信息   过滤 条件 ： 老师 10   或   2018 - 04 - 02 开班   排序 字 段 ： 无   取 多少 数据 ： 所有 数据 （ 无   limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   * \n from   班级 \n where   老师 10   或   2018 - 04 - 02 开班 ; \n   根据 之前 的 分析 这里 的 两个 条件 \n   c _ head _ teacher = ' 老师 5 '   c _ start _ time = ' 2018 - 04 - 02 '     但是 这里 这里 的 组合 方式 和 上面 会 不 一样 ， 有 发现 吗 ？ 这里 的 需求 是 :   老师 5   或   2018 - 04 - 02   ， 应该 使用 的 组合 方式 是   or 。 \n 所以 组合 得到 的 过滤 条件 就是 : c _ head _ teacher = ' 老师 5 '   or   c _ start _ time = ' 2018 - 04 - 02 ' \n   所得   SQL   语句 \n select   *   from   class   where   c _ head _ teacher = ' 老师 5 '   or   c _ start _ time = ' 2018 - 04 - 02 ' ;     执行 得到 以下 结果 \n     当 组合 多个 过滤 的 时候 如果 同时 有   and   和   or   的 组合 方式 ， 需要 注意 执行 的 优先 优先级 和 先后 顺序 先后顺序   sql 语句 中 not   and   or 的 执行 优先 优先级 从 高到 低 依次 为 :   not   & gt ;   and   & gt ;   or \n   执行 时 从左到右 依次 执行 \n   重要 建议   对于 不能 确定 的 时候 可以 使用 括号 小括号   ( )   改变 或 指明 优先 优先级 \n   对于 同时 又   not 、 and 、 or   的 组合 查询 始终 使用   ( )   指明 优先 优先级 \n       试试 \n 试着 把 上面 使用   in   的 查询 改成 组合 查询 ： 查询   会计 老师 1 和 酱油 老师 2 个 老师 负责 的 所有 班级 信息   查询 姓 王且 年龄 在 16 岁 以下 学生 和 在 西安 的 学生 ， 年龄 最小 的 排 在 前面     总结   这次 的 东西 有点 多 ， 特别 是 组合 查询 需要 多多 联系 和 实践 ， \n   where 子 句子 结构 ， 操作 操作符   数值 、 时间 ： 时间 的 表示 方法   字符 字符串 匹配 ：   like 、 百分 分号 百分号 （ % ） 通配符 、 下划 划线 下划线 （ _ ） 通配符   范围 值 检查 ： between   …   and   …   、 in   空值 查询 ： is   null 、 not   组合 查询 ： and 、 or 、 优先 优先级 和 求值 顺序  ", "title_s": "小白学   SQL   第四 四天 第四天 ： 数据 过滤 查询"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/3-query-data/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第三天：单表数据查询", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/3-query-data/", "content": "《小白学 SQL》第三天\n数据查询应该是我们平时用得最多的数据库操作，所以我们优先学习数据查询，今天我们就来看看基础的数据查询操作：单表数据查询，涉及到的知识点有：\n 检索单个列 检索多个列 数据去重 返回定量数据集 排序检索数据  \n先启动联系环境，具体启动方式和步骤请参看《小白学 SQL 第二天：数据表创建》。\nSELECT 语句结构 查询数据使用的到时 SELECT 语句，首先一起看一下今天用到 SELECT 语句结构：（这里不能理解没有关系，有个印象就行，稍后我们通过后面的例子理解）\nselect [distinct] 列1，列2，... from table_name [order by 列1 desc[, 列2 asc]] [limit offset, size];   列1、列2 列。在实际使用的时候，就是表示我们需要得到的信息，就是 E-R 图里面 椭圆 的部分\ntable_name 表名。在实际使用的时候，就是表示我们需要到哪里获得数据，就是 E-R 图里面 矩形 的部分\ndistinct 去重标识。如果多条数据完全相同的时候，只保留一条数据结果\norder by 排序语句。指定查询结果集按照特定列排序，可以同时多个列排序用,分割。排序可以正序(asc)或倒序(desc)\nlimit offset, size 数据限定。在实际使用的时候，就是表示我们需要获得多少数据，就是常说的分页查询。当没有 limit 限定时，表示取到所有数据\n 要学习详细完整的 SELECT 语句结构请查看 MySQL 官方文档。\n查询实例 我们的学习主要是以实际使用为主，所以所有的 SQL 语句之前都会给出命题和分析。\n还记得我们之前建立的数据表结构吧，这里我们会用到班级表，建议大家回顾一个班级的 E-R 图和创建表 SQL。\n查询所有班级的所有信息  分析：查询 所有 班级 的 所有信息\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：所有信息 （所有的*椭圆*） 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 班级所有信息 from 班级;\n 由于 班级所有信息 的所有椭圆是：标识 id、名称、班主任、开班时间、结束时间、状态、创建时间，这样我们可以得到下面的分析结果：\n select 标识 id,名称,班主任,开班时间,结束时间,状态,创建时间 from 班级;\n  通过上面的分析我们得到了和 E-R 图对应的类 SQL 语句，现在需要把这个 sql 翻译成数据库可以执行的正式 SQL。在从 E-R 图到数据表的过程中我们在名字上有这样的对应的关系：\n   E-R 图中的名称 数据库中的对应名称     班级 class   表示 id c_id   名称 c_name   班主任 c_head_teacher   开班时间 c_start_time   结束时间 c_end_time   状态 c_status   创建时间 c_created    按照这个对应表我们替换上面的类 SQL，得到下面的真实可执行 SQL：\nselect c_id,c_name,c_head_teacher,c_start_time,c_end_time,c_status,c_created from class;  copy 到 Navicat 的 SQL 执行其中会得到如下结果：\n执行下面这个 SQL 应该会得到和上面一样的结果\nselect * from calss;  这里的* 表示返回所有列信息，在实际使用中查询所有列或所有信息时，我们常常是用*代替。\n查询所有班级的名称  分析：查询 所有 班级 的 名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：名称 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称 from 班级;\n 这里名称已经是一个存在的特定列（属性）了，所以不再替换分析了。\n 对照上面的映射表，我们很容易得到真实可执行 SQL：\nselect c_name from class;  执行 SQL 语句会得到如下结果\n试试\n查询所有班级的名称和班主任信息  查询前5个班级的标识 id和名称  分析：查询 前5个 班级 的 标识 id和名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id 、名称 取多少数据：5 (前5个) 从哪里开始取：0（前5个）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称 from 班级 limit 0,5;\n  limit 0,5 说明: 我们可以建档的理解成：数据库在执行的时候，先执行没有 limit 限定的 SQL，得到所有的结果；然后在根据 limit 限定条件对数据进行 裁剪 返回。必须这里的limit 0,5: 从第 0 个(不包含 0)开始的 5 条数据（就是前 5 条数据）。大家可以想象 limit 3,4 的含义，并执行看看会有什么结果。\n   对照上面的映射表，转换得到真实可执行 SQL：\nselect c_id,c_name from class limit 0,5;  执行 SQL 语句会得到如下结果\nlimit 在实际使用的时候往往是用在分页数据查询，比如大家逛淘宝、京东都会不断翻页的查找数据。这个时候我们常常使用的表达是：按照每页4条数据大小 分页查询 第3页 班级数据的标识 id 和名称。我们来简单分析一下这个 SQL\n 分析：按照每页4条数据大小 分页查询 第3页 班级数据的标识 id 和名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id 、名称 取多少数据：4 (按照每页4条数据大小 ) 从哪里开始取：4 x (3-1) = 8（第3页，跳过前面2页数据，从第 2 页最后一条数据开始(不包含)往后取）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称 from 班级 limit 8,4;\n 所以得到 SQL\n select c_id, c_name from class limit 8,4;\n 大家执行上面的 SQL 看看结果。\n 试试\n按照每页3条数据大小分页查询第4页班级数据的标识 id 、名称和班主任  数据去重 请执这条 SQL\nselect c_name from class;  大家可以看到里面有2条 会计考试班 2 数据，在实际使用的时候我们常常会遇到去掉重复数据需求，这是往往大家描述的时候会出现 去掉重复、去重 等修饰词。这个时候我们需要使用 SQL 的 distinct 关键字，请大家只想下面的 SQL\nselect distinct c_name from class;   注意: distinct 去重试会比较所有 返回数据列 。请大家执行下面两个 SQL，然后看结果和之前的 2 个 SQL 进行对比，就比较好理解了\n select c_id, c_name from class;\nselect distinct c_id, c_name from class;\n  排序检索 排序我们通过 2 个实例讲解，分别讲解单列排序和多列排序\n查询所有班级信息，标识 id 大的在前面  分析：查询 所有 班级信息，标识 id 大的在前面\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：全部 排序字段：标识 id -&gt; 倒序（大的在前面） 取多少数据：不做限制  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select * from 班级\norder by 标识 id desc;\n 还记得吗！如果返回所有的列，我们可以使用 * 标识\n 现在结合E-R 图到表的映射，我们得到如下SQL\nselect * from class order by c_id desc;  执行这个结果我们会得到如下结果\n大家可以将 desc 改变成 asc 查看一下效果\n查询班级的标识 id、名称、开班时间，按照开班时间先后排列，开班时间相同的标识 id 倒序返回  分析：查询班级的标识 id、名称、开班时间，按照开班时间倒序，开班时间相同的标识 id 倒序返回\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id、名称、开班时间 排序字段1：开班时间 -&gt; 正序 排序字段2：标识 id -&gt; 倒序 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称, 开班时间 from 班级\norder by 开班时间 正序, 标识 id 倒序;\n  现在结合E-R 图到表的映射，我们得到如下SQL\nselect c_id,c_name,c_start_time from class order by c_start_time asc, c_id desc;  执行这个结果我们会得到如下结果\n 当使用多个列排序的时候，排序的处理顺序是从左到右，对于左边列值相同的行数据才会使用后面的列对其排序操作。\n 试试（综合实例）\n查询结束时间最早的 10 个班级的标识 id、名称、开班时间、结束时间；如果结束时间相同，就返回开发时间最好的；如果结束时间和开班时间都相同，就返回标识 id 最大的。查询结果应该如下：  按每页6条数据查询第 3 页班级信息，按照创建时间最大的排在前面，如果创建时间一样就按照 班主任 信息顺序排列。查询结果应该如下：  总结  SELECT 语句基本基本结构 查询需求或问题分析方法：综合 需求或问题描述、E-R 图 和 表结构 3方信息实施从问题到可执行 SQL 的分析设计 查询单列、多列、所有列数据 使用 limit 子句限定返回结果集中的数据的数量(结果集大小) 使用关键字 distinct 进行查询结果去重，注意取重时是比较所有查询列 使用 order by 子句对结果进行排序，可以是单列或多列，每列可以指定自己的排序方式：正序(asc)或倒序(desc)   大家会发现我们这里交替出现 属性、字段、列 如果没有特殊说明，这三个词语表达的含义是一样的，都不是标识数据表列或 ER 图属性。\n", "content_s": "《 小白学   SQL 》 第三 三天 第三天 \n 数据 查询 应该 是 我们 平时 用 得 最 多 的 数据 据库 数据库 操作 ， 所以 我们 优先 学习 数据 查询 ， 今天 我们 就 来 看看 基础 的 数据 查询 操作 ： 单表 数据 查询 ， 涉及 到 的 知识 知识点 有 ： \n   检索 单个 列   检索 多个 列   数据 去 重   返回 定量 数据 集   排序 检索 数据     \n 先 启动 联系 环境 ， 具体 启动 方式 和 步骤 请 参看 《 小白学   SQL   第二 二天 第二天 ： 数据 数据表 创建 》 。 \n SELECT   语句 结构   查询 数据 使用 的 到 时   SELECT   语句 ， 首先 一起 看 一下 今天 用到   SELECT   语句 结构 ： （ 这里 不能 理解 没有 关系 ， 有个 印象 就行 ， 稍后 我们 通过 后面 的 例子 理解 ） \n select   [ distinct ]   列 1 ， 列 2 ， ...   from   table _ name   [ order   by   列 1   desc [ ,   列 2   asc ] ]   [ limit   offset ,   size ] ;       列 1 、 列 2   列 。 在 实际 使用 的 时候 ， 就是 表示 我们 需要 得到 的 信息 ， 就是   E - R   图 里面   椭圆   的 部分 \n table _ name   表名 。 在 实际 使用 的 时候 ， 就是 表示 我们 需要 到 哪里 获得 数据 ， 就是   E - R   图 里面   矩形   的 部分 \n distinct   去 重 标识 。 如果 多条 数据 完全 相同 完全相同 的 时候 ， 只 保留 一条 数据 结果 \n order   by   排序 语句 。 指定 查询 结果 集 按照 特定 列 排序 ， 可以 同时 多个 列 排序 用 , 分割 。 排序 可以 正序 ( asc ) 或 倒序 ( desc ) \n limit   offset ,   size   数据 限定 。 在 实际 使用 的 时候 ， 就是 表示 我们 需要 获得 多少 数据 ， 就是 常说 的 分页 查询 。 当 没有   limit   限定 时 ， 表示 取 到 所有 数据 \n   要 学习 详细 完整 的   SELECT   语句 结构 请 查看   MySQL   官方 文档 。 \n 查询 实例   我们 的 学习 主要 是 以 实际 使用 为主 ， 所以 所有 的   SQL   语句 之前 都 会 给出 命题 和 分析 。 \n 还 记得 我们 之前 建立 的 数据 数据表 结构 吧 ， 这里 我们 会 用到 班级 表 ， 建议 大家 回顾 一个 班级 的   E - R   图 和 创建 表   SQL 。 \n 查询 所有 班级 的 所有 信息     分析 ： 查询   所有   班级   的   所有 信息 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 所有 信息   （ 所有 的 * 椭圆 * ）   取 多少 数据 ： 所有 班级   （ 没有 limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   班级 所有 信息   from   班级 ; \n   由于   班级 所有 信息   的 所有 椭圆 是 ： 标识   id 、 名称 、 班主 主任 班主任 、 开班 时间 、 结束 时间 、 状态 、 创建 时间 ， 这样 我们 可以 得到 下面 的 分析 结果 ： \n   select   标识   id , 名称 , 班主 主任 班主任 , 开班 时间 , 结束 时间 , 状态 , 创建 时间   from   班级 ; \n     通过 上面 的 分析 我们 得到 了 和   E - R   图 对应 的 类   SQL   语句 ， 现在 需要 把 这个   sql   翻译 译成 翻译成 数据 据库 数据库 可以 执行 的 正式   SQL 。 在 从   E - R   图到 数据 数据表 的 过程 中 我们 在 名字 上 有 这样 的 对应 的 关系 ： \n       E - R   图中 的 名称   数据 据库 数据库 中 的 对应 名称           班级   class       表示   id   c _ id       名称   c _ name       班主 主任 班主任   c _ head _ teacher       开班 时间   c _ start _ time       结束 时间   c _ end _ time       状态   c _ status       创建 时间   c _ created         按照 这个 对应 表 我们 替换 上面 的 类   SQL ， 得到 下面 的 真实 可 执行   SQL ： \n select   c _ id , c _ name , c _ head _ teacher , c _ start _ time , c _ end _ time , c _ status , c _ created   from   class ;     copy   到   Navicat   的   SQL   执行 其中 会 得到 如下 结果 ： \n 执行 下面 这个   SQL   应该 会 得到 和 上面 一样 的 结果 \n select   *   from   calss ;     这里 的 *   表示 返回 所有 列 信息 ， 在 实际 使用 中 查询 所有 列 或 所有 信息 时 ， 我们 常常 是 用 * 代替 。 \n 查询 所有 班级 的 名称     分析 ： 查询   所有   班级   的   名称 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 名称   取 多少 数据 ： 所有 班级   （ 没有 limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   名称   from   班级 ; \n   这里 名称 已经 是 一个 存在 的 特定 列 （ 属性 ） 了 ， 所以 不再 替换 分析 了 。 \n   对照 上面 的 映射 表 ， 我们 很 容易 得到 真实 可 执行   SQL ： \n select   c _ name   from   class ;     执行   SQL   语句 会 得到 如下 结果 \n 试试 \n 查询 所有 班级 的 名称 和 班主 主任 班主任 信息     查询 前 5 个 班级 的 标识   id 和 名称     分析 ： 查询   前 5 个   班级   的   标识   id 和 名称 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 标识   id   、 名称   取 多少 数据 ： 5   ( 前 5 个 )   从 哪里 开始 取 ： 0 （ 前 5 个 ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   标识   id ,   名称   from   班级   limit   0 , 5 ; \n     limit   0 , 5   说明 :   我们 可以 建档 的 理解 成 ： 数据 据库 数据库 在 执行 的 时候 ， 先 执行 没有   limit   限定 的   SQL ， 得到 所有 的 结果 ； 然后 在 根据   limit   限定 条件 对 数据 进行   裁剪   返回 。 必须 这里 的 limit   0 , 5 :   从 第   0   个 ( 不 包含   0 ) 开始 的   5   条 数据 （ 就是 前   5   条 数据 ） 。 大家 可以 想象   limit   3 , 4   的 含义 ， 并 执行 看看 会 有 什么 结果 。 \n       对照 上面 的 映射 表 ， 转换 得到 真实 可 执行   SQL ： \n select   c _ id , c _ name   from   class   limit   0 , 5 ;     执行   SQL   语句 会 得到 如下 结果 \n limit   在 实际 使用 的 时候 往往 是 用 在 分页 数据 查询 ， 比如 大家 逛 淘宝 、 京东 都 会 不断 翻页 的 查找 数据 。 这个 时候 我们 常常 使用 的 表达 是 ： 按照 每页 4 条 数据 大小   分页 查询   第 3 页   班级 数据 的 标识   id   和 名称 。 我们 来 简单 分析 一下 这个   SQL \n   分析 ： 按照 每页 4 条 数据 大小   分页 查询   第 3 页   班级 数据 的 标识   id   和 名称 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 标识   id   、 名称   取 多少 数据 ： 4   ( 按照 每页 4 条 数据 大小   )   从 哪里 开始 取 ： 4   x   ( 3 - 1 )   =   8 （ 第 3 页 ， 跳过 前面 2 页 数据 ， 从 第   2   页 最后 一条 数据 开始 ( 不 包含 ) 往后 取 ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   标识   id ,   名称   from   班级   limit   8 , 4 ; \n   所以 得到   SQL \n   select   c _ id ,   c _ name   from   class   limit   8 , 4 ; \n   大家 执行 上面 的   SQL   看看 结果 。 \n   试试 \n 按照 每页 3 条 数据 大小 分页 查询 第 4 页 班级 数据 的 标识   id   、 名称 和 班主 主任 班主任     数据 去 重   请 执 这条   SQL \n select   c _ name   from   class ;     大家 可以 看到 里面 有 2 条   会计 考试 班   2   数据 ， 在 实际 使用 的 时候 我们 常常 会 遇到 去掉 重复 数据 需求 ， 这是 往往 大家 描述 的 时候 会 出现   去掉 重复 、 去 重   等 修饰 饰词 修饰词 。 这个 时候 我们 需要 使用   SQL   的   distinct   关键 关键字 ， 请 大家 只想 下面 的   SQL \n select   distinct   c _ name   from   class ;       注意 :   distinct   去 重试 会 比较 所有   返回 数据 列   。 请 大家 执行 下面 两个   SQL ， 然后 看 结果 和 之前 的   2   个   SQL   进行 对比 ， 就 比较 好 理解 了 \n   select   c _ id ,   c _ name   from   class ; \n select   distinct   c _ id ,   c _ name   from   class ; \n     排序 检索   排序 我们 通过   2   个 实例 讲解 ， 分别 讲解 单列 排序 和 多列 排序 \n 查询 所有 班级 信息 ， 标识   id   大 的 在 前面     分析 ： 查询   所有   班级 信息 ， 标识   id   大 的 在 前面 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 全部   排序 字 段 ： 标识   id   - & gt ;   倒序 （ 大 的 在 前面 ）   取 多少 数据 ： 不 做 限制     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   *   from   班级 \n order   by   标识   id   desc ; \n   还 记得 吗 ！ 如果 返回 所有 的 列 ， 我们 可以 使用   *   标识 \n   现在 结合 E - R   图到 表 的 映射 ， 我们 得到 如下 SQL \n select   *   from   class   order   by   c _ id   desc ;     执行 这个 结果 我们 会 得到 如下 结果 \n 大家 可以 将   desc   改变 成   asc   查看 一下 效果 \n 查询 班级 的 标识   id 、 名称 、 开班 时间 ， 按照 开班 时间 先后 排列 ， 开班 时间 相同 的 标识   id   倒序 返回     分析 ： 查询 班级 的 标识   id 、 名称 、 开班 时间 ， 按照 开班 时间 倒序 ， 开班 时间 相同 的 标识   id   倒序 返回 \n   查询 ： select   到 哪里 取 数据 ： 班级   得到 哪些 信息 ( 列 ) ： 标识   id 、 名称 、 开班 时间   排序 字段 1 ： 开班 时间   - & gt ;   正序   排序 字段 2 ： 标识   id   - & gt ;   倒序   取 多少 数据 ： 所有 班级   （ 没有 limit ）     我们 将 这些 信息 套入 到   SELECT   语句 结构 会 得到 如下 ： \n   select   标识   id ,   名称 ,   开班 时间   from   班级 \n order   by   开班 时间   正序 ,   标识   id   倒序 ; \n     现在 结合 E - R   图到 表 的 映射 ， 我们 得到 如下 SQL \n select   c _ id , c _ name , c _ start _ time   from   class   order   by   c _ start _ time   asc ,   c _ id   desc ;     执行 这个 结果 我们 会 得到 如下 结果 \n   当 使用 多个 列 排序 的 时候 ， 排序 的 处理 顺序 是 从左到右 ， 对于 左边 列值 相同 的 行 数据 才 会 使用 后面 的 列 对 其 排序 操作 。 \n   试试 （ 综合 实例 ） \n 查询 结束 时间 最早 的   10   个 班级 的 标识   id 、 名称 、 开班 时间 、 结束 时间 ； 如果 结束 时间 相同 ， 就 返回 开发 时间 最好 的 ； 如果 结束 时间 和 开班 时间 都 相同 ， 就 返回 标识   id   最大 的 。 查询 结果 应该 如下 ：     按 每页 6 条 数据 查询 第   3   页 班级 信息 ， 按照 创建 时间 最大 的 排 在 前面 ， 如果 创建 时间 一样 就 按照   班主 主任 班主任   信息 顺序 排列 顺序排列 。 查询 结果 应该 如下 ：     总结     SELECT   语句 基本 基本 结构   查询 需求 或 问题 分析 方法 分析方法 ： 综合   需求 或 问题 描述 、 E - R   图   和   表 结构   3 方 信息 实施 从 问题 到 可 执行   SQL   的 分析 设计   查询 单列 、 多列 、 所有 列 数据   使用   limit   子句 限定 返回 结果 集中 的 数据 的 数量 ( 结果 集 大小 )   使用 关键 关键字   distinct   进行 查询 结果 去 重 ， 注意 取重 时 是 比较 所有 查询 列   使用   order   by   子句 对 结果 进行 排序 ， 可以 是 单列 或 多列 ， 每列 可以 指定 自己 的 排序 方式 ： 正序 ( asc ) 或 倒序 ( desc )       大家 会 发现 我们 这里 交替 出现   属性 、 字 段 、 列   如果 没有 特殊 说明 ， 这 三个 词语 表达 的 含义 是 一样 的 ， 都 不是 标识 数据 数据表 列 或   ER   图 属性 。 \n", "title_s": "小白学   SQL   第三 三天 第三天 ： 单表 数据 查询"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/2-create-table/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第二天：数据表创建", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/2-create-table/", "content": "《小白学 SQL》第二天\n今天我们来学习数据表（table）的建立，涉及到的内容可能大家还不能完全理解，这里主要是为后面的查询语句做些基本准备和数据准备，后面还会专门学习 DDL（数据学习语言），所以没有关系这里大家只要能执行得到正确结果就行。\n今天涉及到的内容有：\n 表创建语句（create） 数据插入语句（insert ） MySQL 基本数据类型 E-R图（实体关系图）  \n启动学习环境 这里假设你的 docker 服务由于某些原因停止了（如：开关机），需要手动启动相关服务。如果你的 docker 服务和 sql-learn 已经正常启动，请跳过此章节（什么？你还没有 docker 和 sql-learn，请看这里）。这里所有的操作都可以参考第一天的内容，在这里。\n 启动 docker 服务   A、windows 通过桌面图标 或 系统菜单来启动\nB、Mac 通过 Launchpad 面板来图标启动\nC、Linux 通过命令行启动，不同版本会有所不同，可以查看第一天学的内容。\n  启动数据库服务器 (sql-learn 容器)   打开命令行工具输入一下命令，启动 sql-learn 容器\ndocker start sql-learn  输入一下命令查看启动状态\ndocker ps  结果如下：\n 启动数据库客户端（Navicat）  打开 Navicat 软件，通过左边的连接收藏栏，双击 sql-learn 连接，连接到数据库服务器（图中 ）。然后打开 sql-learn 数据库，就是双击 sql-learn 数据库（图中 ）。打开结果如下图：\n 通过以上 3 步，我们就打开了我们的学习环境，对于我们以后的每次学习进来的操作步骤都是一样的，所以这里大家一定要会，如果有什么问题可以给我留言。\n 创建数据表 create table (创建表)语句结构 以下是上面 SQL 语句的简单模板说明，具体完整的 CREATE TABLE 语句语法请参考 MySQL 官方文档。我们这里使用的足够了\nCREATE TABLE &lt;table_name&gt; ( &lt;column_name&gt; &lt;data_type&gt; [column_options] [COMMENT '&lt;comment&gt;'] [, ...] ) [table_options]   table_name: 表名称 column_name： 列名称 data_type： 列数据类型 column_options：列定义选项 comment ：注释 table_options：表定义选项 [, …]: 表示可以有多个列定义，使用 , 分割  设计并创建表 这里我们构想一个培训班的业务场景：\n 一个培训班有很多学生\n每个学生可以参加多个培训班\n 班级信息表 班级表创建 SQL ：\nCREATE TABLE `class` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，组件', `c_name` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班级名称', `c_head_teacher` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班主任名称', `c_start_time` date DEFAULT NULL COMMENT '开班日期', `c_end_time` date DEFAULT NULL COMMENT '结束日期', `c_status` int(11) NOT NULL COMMENT '班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】', `c_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`c_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表';  学生信息表 学生表创建 SQL：\nCREATE TABLE `student` ( `s_id` int(11) NOT NULL AUTO_INCREMENT COMMENT ' 学生 id', `s_name` varchar(64) NOT NULL COMMENT '学生名称', `s_sex` tinyint(4) DEFAULT NULL COMMENT '学生性别', `s_age` int(11) DEFAULT NULL COMMENT '学生年龄', `s_birthday` date NOT NULL COMMENT '学生生日', `s_addr` varchar(512) DEFAULT NULL COMMENT '学生地址', `s_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', `s_status` int(11) DEFAULT NULL COMMENT '状态（0：禁用，1：可用）', PRIMARY KEY (`s_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生信息表';  学生班级关联表 学生班级关联表(记录学生参加了那些培训班) SQL：\nCREATE TABLE `student_join_class` ( `c_id` int(11) NOT NULL COMMENT '班级 id', `s_id` int(11) NOT NULL COMMENT '学生表', `cs_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', PRIMARY KEY (`c_id`,`s_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生班级关联表';  对于以上 SQL 语句可以在 这里下载.\n数据类型说明 在我们的数据表创建语句里面，有个很重要的概念，也是数据库重要概念之一：数据类型（如：int(11)、timestamp、date等）。列的数据类型是描述了列可以接受保持的数据和如何存储数据。每种数据库管理系统的数据类型定义有略微不同，这里我们以 MySQL 数据类型为例说明，其他数据库的请查询相关文档。这里的数据类型大家不用全部记住，只要用到的时候查询参考文档就行。\n在 MySQL 中，有三种主要的类型：文本、数字、和日期/时间类型。\n文本类型（Text）    数据类型 描述     CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。   VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。   TINYTEXT 存放最大长度为 255 个字符的字符串。   TEXT 存放最大长度为 65,535 个字符的字符串。   BLOB 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。   MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。   MEDIUMBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。   LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。   LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。   ENUM(x,y,z,etc.) 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(&lsquo;X&rsquo;,&lsquo;Y&rsquo;,&lsquo;Z&rsquo;)   SET 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。    数字类型（Number）    数据类型 描述     TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。   SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。   MEDIUMINT(size) -8388608 到 8388607 普通。0 到 16777215 无符号*。在括号中规定最大位数。   INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。   BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。   FLOAT(size,d) 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。   DOUBLE(size,d) 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。   DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。     这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。\n 日期/时间类型（Date）    数据类型 描述     DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 &lsquo;1000-01-01&rsquo; 到 &lsquo;9999-12-31&rsquo;   DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 &lsquo;1000-01-01 00:00:00&rsquo; 到 &lsquo;9999-12-31 23:59:59&rsquo;   TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(&lsquo;1970-01-01 00:00:00&rsquo; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 &lsquo;1970-01-01 00:00:01&rsquo; UTC 到 &lsquo;2038-01-09 03:14:07&rsquo; UTC   TIME() 时间。格式：HH:MM:SS 注释：支持的范围是从 &lsquo;-838:59:59&rsquo; 到 &lsquo;838:59:59&rsquo;   YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。     即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。\n 录入数据 数据库插入数据使用 insert 语句，我们使用到的所有数据插入 sql 到 这里下载。下载下来过后将里面所有 SQL 语句拷贝到 Navicat 客户端的查询窗口里面，如下图：\n点击执行，会得到一下结果：\n这时打开左边 Tables 里面 class 表 会看到如下图数据已经进去了\n里面涉及到的 insert 有一下如下两种格式\n语法格式一\nINSERT INTO [数据库名.]表名称[(列1,列2,...)] VALUES (值1, 值2,....)  实例：\nINSERT INTO student(s_id, s_name, s_sex, s_age, s_birthday, s_addr, s_created, s_status) VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  语法格式二（批量插入）\nINSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) [,...]  实例：\nINSERT INTO `sql-learn`.`student_join_class`(`c_id`, `s_id`, `cs_created`) VALUES (1, 2, '2018-03-18 10:37:00'), (1, 3, '2018-02-18 09:41:41'), (1, 4, '2017-04-03 12:10:00'), (1, 5, '2018-01-28 14:30:00'), (1, 10, '2018-04-18 22:26:41');  详细语法格式参考 MySQL 官方文档。\nE-R 图（实体关系图） E-R 图是我个人感觉学习数据库必须掌握的一个技能，它是学习和分析数据库的一个有力工具，能让我们很快的对数据表之间关系形成一个全局观，对我们编写、分析 SQL 也是一个有力的工具。今天先简单讲解一下 E-R 图的基本内容，让大家可以看懂后面出现的 ER 图，后面会有专门的章节详解讲解 E-R 图。\nER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。\nER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。\nER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。\nER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。\nER图中关联关系有三种：\n 1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。 1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N&gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。 多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M&gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N&gt;0）个实体有关系。  实例讲解：这个是上面创建的班级、学生 ER 图（注意：此图的部分画法不是标准的，不过不影响大家理解，也建议大家平时多多手画 ER 图，不是那么标准也没有关系，只要不影响理解就行） 班级、学生 是实体。一个学生一个参加多个(M)班级，一个班级可以包含多个(N)学生。 班级名称、学生性别 是属性。每个实体(班级或学生)都可以有多个属性。 参加 是关系，参见关系本身还包含有 参加时间 属性。学生加入班级的时候有 参加时间 。  有兴趣的可以自己手动画一下下面的 ER 图：有一个 班级 的实体，包含属性：课程名称、课程学分、授课老师。一个班级只授一门课程，但是班级的学生可以多次参加这么课程的考试。\n大家可能已经发现这里和我们实际建立的数据库表有所区别，这里表示的实体只有 2 个，但是我们时间建立的表却有 3 个。这里是我有意为之的，因为我发现很多初学者往往会有一个误区：误认为数据库的每个数据表都会对应 ER 图中的一个实体，其实这个是错误的。\n这是由于我们在实际建立数据库表的时候，会将 多对多（M:N） 关系拆分成 1对多（1:N） 关系，中间会多建立一个 关联表 （关联表也是物理数据表）。所以这里大家记住： ER图 转换成物理数据表的时候，可能会有所不同，但是他们的关系结构一定是一致的。我们有时还会把一个 实体 拆分成多个数据表进行存储，只要到家记住这个误区就行，具体为什么这个不属于这次内容范围，有兴趣的可以自行查找相关文档。\n总结  完成数据表创建和数据导入，知道 create 语句和 insert 语句基本结构和用户（可以看懂别人写的语句程度） 知道数据库基本类型，并且类型是描述列的 E-R 图基本知识：实体、属性、关系。可以看懂别人给出的 E-R 图，可以自己手绘简单 E-R 图，能够分析简单的数据表 E-R 图 ", "content_s": "《 小白学   SQL 》 第二 二天 第二天 \n 今天 我们 来 学习 数据 数据表 （ table ） 的 建立 ， 涉及 到 的 内容 可能 大家 还 不能 完全 理解 ， 这里 主要 是 为 后面 的 查询 语句 做些 基本 准备 和 数据 准备 ， 后面 还会 专门 学习   DDL （ 数据 学习 语言 ） ， 所以 没有 关系 这里 大家 只要 能 执行 得到 正确 结果 就行 。 \n 今天 涉及 到 的 内容 有 ： \n   表 创建 语句 （ create ）   数据 插入 语句 （ insert   ）   MySQL   基本 数据 类型 数据类型   E - R 图 （ 实体 关系 图 ）     \n 启动 学习 环境   这里 假设 你 的   docker   服务 由于 某些 原因 停止 了 （ 如 ： 开关 关机 开关机 ） ， 需要 手动 启动 相关 服务 。 如果 你 的   docker   服务 和   sql - learn   已经 正常 启动 ， 请 跳 过 此 章节 （ 什么 ？ 你 还 没有   docker   和   sql - learn ， 请 看 这里 ） 。 这里 所有 的 操作 都 可以 参考 第一 一天 第一天 的 内容 ， 在 这里 。 \n   启动   docker   服务       A 、 windows   通过 桌面 图标 桌面图 桌面图标   或   系统 菜单 来 启动 \n B 、 Mac   通过   Launchpad   面板 来 图标 启动 \n C 、 Linux   通过 命令 命令行 启动 ， 不同 版本 会 有所 不同 有所不同 ， 可以 查看 第一 一天 第一天 学 的 内容 。 \n     启动 数据 据库 数据库 服务 务器 服务器   ( sql - learn   容器 )       打开 命令 命令行 工具 输入 一下 命令 ， 启动   sql - learn   容器 \n docker   start   sql - learn     输入 一下 命令 查看 启动 状态 \n docker   ps     结果 如下 ： \n   启动 数据 据库 数据库 客户 客户端 （ Navicat ）     打开   Navicat   软件 ， 通过 左边 的 连接 收藏 栏 ， 双击   sql - learn   连接 ， 连接 到 数据 据库 数据库 服务 务器 服务器 （ 图中   ） 。 然后 打开   sql - learn   数据 据库 数据库 ， 就是 双击   sql - learn   数据 据库 数据库 （ 图中   ） 。 打开 结果 如下 图 ： \n   通过 以上   3   步 ， 我们 就 打开 了 我们 的 学习 环境 ， 对于 我们 以后 的 每次 学习 进来 的 操作 步骤 操作步骤 都 是 一样 的 ， 所以 这里 大家 一定 要会 ， 如果 有 什么 问题 可以 给 我 留言 。 \n   创建 数据 数据表   create   table   ( 创建 表 ) 语句 结构   以下 是 上面   SQL   语句 的 简单 模板 说明 ， 具体 完整 的   CREATE   TABLE   语句 语法 请 参考   MySQL   官方 文档 。 我们 这里 使用 的 足够 了 \n CREATE   TABLE   & lt ; table _ name & gt ;   (   & lt ; column _ name & gt ;   & lt ; data _ type & gt ;   [ column _ options ]   [ COMMENT   ' & lt ; comment & gt ; ' ]   [ ,   ... ]   )   [ table _ options ]       table _ name :   表 名称   column _ name ：   列 名称   data _ type ：   列 数据 类型 数据类型   column _ options ： 列 定义 选项   comment   ： 注释   table _ options ： 表 定义 选项   [ ,   … ] :   表示 可以 有 多个 列 定义 ， 使用   ,   分割     设计 并 创建 表   这里 我们 构想 一个 培训 培训班 的 业务 场景 ： \n   一个 培训 培训班 有 很多 学生 \n 每个 学生 可以 参加 多个 培训 培训班 \n   班级 信息 表   班级 表 创建   SQL   ： \n CREATE   TABLE   ` class `   (   ` c _ id `   int ( 11 )   NOT   NULL   AUTO _ INCREMENT   COMMENT   ' 班级   id ， 组件 ' ,   ` c _ name `   varchar ( 512 )   COLLATE   utf8mb4 _ unicode _ ci   NOT   NULL   COMMENT   ' 班级 名称 ' ,   ` c _ head _ teacher `   varchar ( 64 )   COLLATE   utf8mb4 _ unicode _ ci   NOT   NULL   COMMENT   ' 班主 主任 班主任 名称 ' ,   ` c _ start _ time `   date   DEFAULT   NULL   COMMENT   ' 开班 日期 ' ,   ` c _ end _ time `   date   DEFAULT   NULL   COMMENT   ' 结束 日期 ' ,   ` c _ status `   int ( 11 )   NOT   NULL   COMMENT   ' 班级 状态 【 0 ： 报名 未 开始 ， 1 ： 报名 中 ， 2 ： 报名 完成 ， 3 ： 已 开学 ， 4 ： 已 结业 】 ' ,   ` c _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 创建 时间 ' ,   PRIMARY   KEY   ( ` c _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COLLATE = utf8mb4 _ unicode _ ci   COMMENT = ' 班级 信息 表 ' ;     学生 信息 表   学生 表 创建   SQL ： \n CREATE   TABLE   ` student `   (   ` s _ id `   int ( 11 )   NOT   NULL   AUTO _ INCREMENT   COMMENT   '   学生   id ' ,   ` s _ name `   varchar ( 64 )   NOT   NULL   COMMENT   ' 学生 名称 ' ,   ` s _ sex `   tinyint ( 4 )   DEFAULT   NULL   COMMENT   ' 学生 性别 ' ,   ` s _ age `   int ( 11 )   DEFAULT   NULL   COMMENT   ' 学生 年龄 ' ,   ` s _ birthday `   date   NOT   NULL   COMMENT   ' 学生 生日 ' ,   ` s _ addr `   varchar ( 512 )   DEFAULT   NULL   COMMENT   ' 学生 地址 ' ,   ` s _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 加入 时间 ' ,   ` s _ status `   int ( 11 )   DEFAULT   NULL   COMMENT   ' 状态 （ 0 ： 禁用 ， 1 ： 可用 ） ' ,   PRIMARY   KEY   ( ` s _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COMMENT = ' 学生 信息 表 ' ;     学生 班级 关联 表   学生 班级 关联 表 ( 记录 学生 参加 了 那些 培训 培训班 )   SQL ： \n CREATE   TABLE   ` student _ join _ class `   (   ` c _ id `   int ( 11 )   NOT   NULL   COMMENT   ' 班级   id ' ,   ` s _ id `   int ( 11 )   NOT   NULL   COMMENT   ' 学生 表 ' ,   ` cs _ created `   timestamp   NOT   NULL   DEFAULT   CURRENT _ TIMESTAMP   ON   UPDATE   CURRENT _ TIMESTAMP   COMMENT   ' 加入 时间 ' ,   PRIMARY   KEY   ( ` c _ id ` , ` s _ id ` )   )   ENGINE = InnoDB   DEFAULT   CHARSET = utf8mb4   COMMENT = ' 学生 班级 关联 表 ' ;     对于 以上   SQL   语句 可以 在   这里 下载 . \n 数据 类型 数据类型 说明   在 我们 的 数据 数据表 创建 语句 里面 ， 有个 很 重要 的 概念 ， 也 是 数据 据库 数据库 重要 概念 之一 ： 数据 类型 数据类型 （ 如 ： int ( 11 ) 、 timestamp 、 date 等 ） 。 列 的 数据 类型 数据类型 是 描述 了 列 可以 接受 保持 的 数据 和 如何 存储 数据 。 每种 数据 据库 数据库 管理 系统 管理系 管理系统 的 数据 类型 数据类型 定义 有 略微 不同 ， 这里 我们 以   MySQL   数据 类型 数据类型 为例 说明 ， 其他 数据 据库 数据库 的 请 查询 相关 文档 。 这里 的 数据 类型 数据类型 大家 不用 全部 记住 ， 只要 用到 的 时候 查询 参考 文档 就行 。 \n 在   MySQL   中 ， 有 三种 主要 的 类型 ： 文本 、 数字 、 和 日期 / 时间 类型 。 \n 文本 类型 （ Text ）         数据 类型 数据类型   描述           CHAR ( size )   保存 固定 长度 的 字符 字符串 （ 可 包含 字母 、 数字 以及 特殊 字符 特殊字符 ） 。 在 括号 中 指定 字符 字符串 的 长度 。 最 多   255   字符 个字符 。       VARCHAR ( size )   保存 可变 长度 的 字符 字符串 （ 可 包含 字母 、 数字 以及 特殊 字符 特殊字符 ） 。 在 括号 中 指定 字符 字符串 的 最大 长度 。 最 多   255   字符 个字符 。 注释 ： 如果 值 的 长度 大于   255 ， 则 被 转换 为   TEXT   类型 。       TINYTEXT   存放 最大 长度 为   255   字符 个字符 的 字符 字符串 。       TEXT   存放 最大 长度 为   65 , 535   字符 个字符 的 字符 字符串 。       BLOB   用于   BLOBs   ( Binary   Large   OBjects ) 。 存放 最 多   65 , 535   字节 的 数据 。       MEDIUMTEXT   存放 最大 长度 为   16 , 777 , 215   字符 个字符 的 字符 字符串 。       MEDIUMBLOB   用于   BLOBs   ( Binary   Large   OBjects ) 。 存放 最 多   16 , 777 , 215   字节 的 数据 。       LONGTEXT   存放 最大 长度 为   4 , 294 , 967 , 295   字符 个字符 的 字符 字符串 。       LONGBLOB   用于   BLOBs   ( Binary   Large   OBjects ) 。 存放 最 多   4 , 294 , 967 , 295   字节 的 数据 。       ENUM ( x , y , z , etc . )   允许 你 输入 可能 值 的 列表 。 可以 在   ENUM   列表 中 列出 最大   65535   个值 。 如果 列表 中 不 存在 插入 的 值 ， 则 插入 空值 。 注释 ： 这些 值 是 按照 你 输入 的 顺序 存储 顺序存储 的 。 可以 按照 此 格式 输入 可能 的 值 ： ENUM ( & lsquo ; X & rsquo ; , & lsquo ; Y & rsquo ; , & lsquo ; Z & rsquo ; )       SET   与   ENUM   类似 ， SET   最 多 只能 包含   64   个 列表 项 ， 不过   SET   可 存储 一个 以上 的 值 。         数字 类型 （ Number ）         数据 类型 数据类型   描述           TINYINT ( size )   - 128   到   127   常规 。 0   到   255   无 符号 * 。 在 括号 中 规定 最大 位数 。       SMALLINT ( size )   - 32768   到   32767   常规 。 0   到   65535   无 符号 * 。 在 括号 中 规定 最大 位数 。       MEDIUMINT ( size )   - 8388608   到   8388607   普通 。 0   到   16777215   无 符号 * 。 在 括号 中 规定 最大 位数 。       INT ( size )   - 2147483648   到   2147483647   常规 。 0   到   4294967295   无 符号 * 。 在 括号 中 规定 最大 位数 。       BIGINT ( size )   - 9223372036854775808   到   9223372036854775807   常规 。 0   到   18446744073709551615   无 符号 * 。 在 括号 中 规定 最大 位数 。       FLOAT ( size , d )   带有 浮动 小数 数点 小数点 的 小 数字 。 在 括号 中 规定 最大 位数 。 在   d   参数 中 规定 小数 数点 小数点 右侧 的 最大 位数 。       DOUBLE ( size , d )   带有 浮动 小数 数点 小数点 的 大 数字 。 在 括号 中 规定 最大 位数 。 在   d   参数 中 规定 小数 数点 小数点 右侧 的 最大 位数 。       DECIMAL ( size , d )   作为 字符 字符串 存储 的   DOUBLE   类型 ， 允许 固定 的 小数 数点 小数点 。           这些 整数 类型 拥有 额外 的 选项   UNSIGNED 。 通常 ， 整数 可以 是 负数 或 正数 。 如果 添加   UNSIGNED   属性 ， 那么 范围 将 从   0   开始 ， 而 不是 某个 负数 。 \n   日期 / 时间 类型 （ Date ）         数据 类型 数据类型   描述           DATE ( )   日期 。 格式 ： YYYY - MM - DD 注释 ： 支持 的 范围 是从   & lsquo ; 1000 - 01 - 01 & rsquo ;   到   & lsquo ; 9999 - 12 - 31 & rsquo ;       DATETIME ( )   * 日期 和 时间 的 组合 。 格式 ： YYYY - MM - DD   HH : MM : SS 注释 ： 支持 的 范围 是从   & lsquo ; 1000 - 01 - 01   00 : 00 : 00 & rsquo ;   到   & lsquo ; 9999 - 12 - 31   23 : 59 : 59 & rsquo ;       TIMESTAMP ( )   * 时间 戳 。 TIMESTAMP   值 使用   Unix   纪元 ( & lsquo ; 1970 - 01 - 01   00 : 00 : 00 & rsquo ;   UTC )   至今 的 描述 来 存储 。 格式 ： YYYY - MM - DD   HH : MM : SS 注释 ： 支持 的 范围 是从   & lsquo ; 1970 - 01 - 01   00 : 00 : 01 & rsquo ;   UTC   到   & lsquo ; 2038 - 01 - 09   03 : 14 : 07 & rsquo ;   UTC       TIME ( )   时间 。 格式 ： HH : MM : SS   注释 ： 支持 的 范围 是从   & lsquo ; - 838 : 59 : 59 & rsquo ;   到   & lsquo ; 838 : 59 : 59 & rsquo ;       YEAR ( )   2   位 或   4   位 格式 的 年 。 注释 ： 4   位 格式 所 允许 的 值 ： 1901   到   2155 。 2   位 格式 所 允许 的 值 ： 70   到   69 ， 表示 从   1970   到   2069 。           即便   DATETIME   和   TIMESTAMP   返回 相同 的 格式 ， 它们 的 工作 方式 很 不同 。 在   INSERT   或   UPDATE   查询 中 ， TIMESTAMP   自动 把 自身 设置 为 当前 的 日期 和 时间 。 TIMESTAMP   也 接受 不同 的 格式 ， 比如   YYYYMMDDHHMMSS 、 YYMMDDHHMMSS 、 YYYYMMDD   或   YYMMDD 。 \n   录入 数据   数据 据库 数据库 插入 数据 使用   insert   语句 ， 我们 使用 到 的 所有 数据 插入   sql   到   这里 下载 。 下载 下来 过后 将 里面 所有   SQL   语句 拷贝 拷贝到   Navicat   客户 客户端 的 查询 窗口 里面 ， 如下 图 ： \n 点击 执行 ， 会 得到 一下 结果 ： \n 这时 打开 左边   Tables   里面   class   表   会 看到 如下 图 数据 已经 进去 了 \n 里面 涉及 到 的   insert   有 一下 如下 两种 格式 \n 语法 格式 一 \n INSERT   INTO   [ 数据 据库 数据库 名 . ] 表 名称 [ ( 列 1 , 列 2 , ... ) ]   VALUES   ( 值 1 ,   值 2 , .... )     实例 ： \n INSERT   INTO   student ( s _ id ,   s _ name ,   s _ sex ,   s _ age ,   s _ birthday ,   s _ addr ,   s _ created ,   s _ status )   VALUES   ( 1 ,   ' 王   1 ' ,   1 ,   16 ,   ' 2007 - 04 - 18 ' ,   ' 重庆 ' ,   ' 2018 - 04 - 18   22 : 29 : 27 ' ,   1 ) ;     语法 格式 二 （ 批量 插入 ） \n INSERT   INTO   table _ name   ( 列 1 ,   列 2 , ... )   VALUES   ( 值 1 ,   值 2 , .... )   [ , ... ]     实例 ： \n INSERT   INTO   ` sql - learn ` . ` student _ join _ class ` ( ` c _ id ` ,   ` s _ id ` ,   ` cs _ created ` )   VALUES   ( 1 ,   2 ,   ' 2018 - 03 - 18   10 : 37 : 00 ' ) ,   ( 1 ,   3 ,   ' 2018 - 02 - 18   09 : 41 : 41 ' ) ,   ( 1 ,   4 ,   ' 2017 - 04 - 03   12 : 10 : 00 ' ) ,   ( 1 ,   5 ,   ' 2018 - 01 - 28   14 : 30 : 00 ' ) ,   ( 1 ,   10 ,   ' 2018 - 04 - 18   22 : 26 : 41 ' ) ;     详细 语法 格式 参考   MySQL   官方 文档 。 \n E - R   图 （ 实体 关系 图 ）   E - R   图是 我 个人 感觉 个人感觉 学习 数据 据库 数据库 必须 掌握 的 一个 技能 ， 它 是 学习 和 分析 数据 据库 数据库 的 一个 有力 工具 ， 能 让 我们 很快 的 对 数据 数据表 之间 关系 形成 一个 全局 观 ， 对 我们 编写 、 分析   SQL   也 是 一个 有力 的 工具 。 今天 先 简单 讲解 一下   E - R   图 的 基本 内容 ， 让 大家 可以 看 懂 后面 出现 的   ER   图 ， 后面 会 有 专门 的 章节 详解 讲解   E - R   图 。 \n ER 图 分为 实体 、 属性 、 关系 三个 核心 部分 。 实体 是 长方 方形 长方形 体现 ， 而 属性 则 是 椭圆 圆形 椭圆形 ， 关系 为 菱形 。 \n ER 图 的 实体 （ entity ） 即 数据 模型 数据模型 中 的 数据 对象 ， 例如 人 、 学生 、 音乐 都 可以 作为 一个 数据 对象 ， 用 长方 长方体 来 表示 ， 每个 实体 都 有 自己 的 实体 成员 （ entity   member ） 或者 或者说 实体 对象 （ entity   instance ） ， 例如 学生 实体 里 包括 张三 、 李四 等 ， 实体 成员 （ entity   member ） / 实体 实例 （ entity   instance ）   不 需要 出现 在 ER 图中 。 \n ER 图 的 属性 （ attribute ） 即 数据 对象 所 具有 的 属性 ， 例如 学生 具有 姓名 、 学 号 、 年级 等 属性 ， 用 椭圆 圆形 椭圆形 表示 ， 属性 分为 唯一 属性 （   unique   attribute ） 和 非 唯一 属性 ， 唯一 属性 指 的 是 唯一 可用 来 标识 该 实体 实例 或者 成员 的 属性 ， 用 下划 划线 下划线 表示 ， 一般 来讲 一般来讲 实体 都 至少 有 一个 唯一 属性 。 \n ER 图 的 关系 （ relationship ） 用来 表现 数据 对象 与 数据 对象 之间 的 联系 ， 例如 学生 的 实体 和 成绩 成绩表 的 实体 之间 有 一定 的 联系 ， 每个 学生 都 有 自己 的 成绩 成绩表 ， 这 就是 一种 关系 ， 关系 用 菱形 来 表示 。 \n ER 图中 关联 关系 有 三种 ： \n   1 对 1 （ 1 : 1 ）   ： 1 对 1 关系 是 指 对于 实体 集 A 与 实体 集 B ， A 中 的 每 一个 实体 至多 与 B 中 一个 实体 有 关系 ； 反之 ， 在 实体 集 B 中 的 每个 实体 至多 与 实体 集 A 中 一个 实体 有 关系 。   1 对 多 （ 1 : N ）   ： 1 对 多 关系 是 指 实体 集 A 与 实体 集 B 中 至少 有 N ( N & gt ; 0 ) 个 实体 有 关系 ； 并且 实体 集 B 中 每 一个 实体 至多 与 实体 集 A 中 一个 实体 有 关系 。   多 对 多 （ M : N ）   ： 多 对 多 关系 是 指 实体 集 A 中 的 每 一个 实体 与 实体 集 B 中 至少 有 M ( M & gt ; 0 ) 个 实体 有 关系 ， 并且 实体 集 B 中 的 每 一个 实体 与 实体 集 A 中 的 至少 N （ N & gt ; 0 ） 个 实体 有 关系 。     实例 讲解 ： 这个 是 上面 创建 的 班级 、 学生   ER   图 （ 注意 ： 此图 的 部分 画法 不是 标准 的 ， 不过 不 影响 大家 理解 ， 也 建议 大家 平时 多多 手画   ER   图 ， 不是 那么 标准 也 没有 关系 ， 只要 不 影响 理解 就行 ）   班级 、 学生   是 实体 。 一个 学生 一个 参加 多个 ( M ) 班级 ， 一个 班级 可以 包含 多个 ( N ) 学生 。   班级 名称 、 学生 性别   是 属性 。 每个 实体 ( 班级 或 学生 ) 都 可以 有 多个 属性 。   参加   是 关系 ， 参见 关系 本身 还 包含 有   参加 时间   属性 。 学生 加入 班级 的 时候 有   参加 时间   。     有 兴趣 的 可以 自己 手 动画 一下 下面 的   ER   图 ： 有 一个   班级   的 实体 ， 包含 属性 ： 课程 名称 课程名称 、 课程 学分 、 授课 老师 。 一个 班级 只授 一门 课程 ， 但是 班级 的 学生 可以 多次 参加 这么 课程 的 考试 。 \n 大家 可能 已经 发现 这里 和 我们 实际 建立 的 数据 据库 数据库 表 有所 区别 有所区别 ， 这里 表示 的 实体 只有   2   个 ， 但是 我们 时间 建立 的 表 却 有   3   个 。 这里 是 我 有意 为 之 的 ， 因为 我 发现 很多 初学 学者 初学者 往往 会 有 一个 误区 ： 误认 认为 误认为 数据 据库 数据库 的 每个 数据 数据表 都 会 对应   ER   图中 的 一个 实体 ， 其实 这个 是 错误 的 。 \n 这是 由于 我们 在 实际 建立 数据 据库 数据库 表 的 时候 ， 会 将   多 对 多 （ M : N ）   关系 拆 分成   1 对 多 （ 1 : N ）   关系 ， 中间 会多 建立 一个   关联 表   （ 关联 表 也 是 物理 数据 数据表 ） 。 所以 这里 大家 记住 ：   ER 图   转换 换成 转换成 物理 数据 数据表 的 时候 ， 可能 会 有所 不同 有所不同 ， 但是 他们 的 关系 结构 一定 是 一致 的 。 我们 有时 还会 把 一个   实体   拆 分成 多个 数据 数据表 进行 存储 ， 只要 到家 记住 这个 误区 就行 ， 具体 什么 为什么 这个 不 属于 这次 内容 范围 ， 有 兴趣 的 可以 自行 查找 相关 文档 。 \n 总结     完成 数据 数据表 创建 和 数据 导入 ， 知道   create   语句 和   insert   语句 基本 结构 和 用户 （ 可以 看 懂 别人 写 的 语句 程度 ）   知道 数据 据库 数据库 基本 类型 ， 并且 类型 是 描述 列 的   E - R   图 基本 知识 基本知识 ： 实体 、 属性 、 关系 。 可以 看 懂 别人 给出 的   E - R   图 ， 可以 自己 手绘 简单   E - R   图 ， 能够 分析 简单 的 数据 数据表   E - R   图  ", "title_s": "小白学   SQL   第二 二天 第二天 ： 数据 数据表 创建"}, {"description": "", "objectID": "https://blog.threeq.me/post/team-communication/agile-practice-record/", "tags": ["Scrum", "看板", "敏捷开发", "团队管理"], "title": "Scrum + 看板 开发实践：记录", "uri": "https://blog.threeq.me/post/team-communication/agile-practice-record/", "content": "目前我们团队正实践 Scrum 框架 和 看板管理，这边文章正是对我们自己的实践的记录。这里的记录并不是按照时间顺序进行的，而是按照我自己的针对实践目标的先后进行的。目前我们团队还没有完全实现以上所有目标，对 Scrum 框架 理解和使用也还在初级阶段，所以有很多不足的地方，并且还有很多地方还在聊胜于无的状态，欢迎大家指正。\n我们现在正在进行的实践有：\n 统一团队对“完成”的定义 看板管理流程 每日晨会 迭代回顾会议 迭代计划会议 code review  我们团队刚开始的时候管理、开发混乱完全没有章法，大家各种打架、各种撕逼、各种甩锅。没有哪一次迭代不通宵，没有哪一次迭代不延期，没有哪一次迭代质量过关，没有哪一次上线不出问题，这种状态持续了很长一段时间。我感觉不行了，再这样下去还能做个啥产品，开始寻找各种解决方案并且不断反思团队遇到问题的本质，后来学习了敏捷，接触到 Scrum 和 看板，里面的方法论和实践操作不正是我们团队需要的吗？于是坚决决定团队开始敏捷实践，当然正所谓：软件开发没有银弹，实践证明 Scrum 和 看板并不能解决我们团队所有问题，但是确实可以让团队慢慢变好。\n\n团队目标一致：完成定义 虽然决定引入 Scrum 和 看板，但是从哪里开始呢？这么多团队问题，应该从哪个或哪几个问题开始引入解决呢？还是团队全面调整引入？这些问题是任何团队在开始引入的时候都会遇到的，但是我相信每个团队最后的答案都是不一样的。Scrum 框架建议团队全面调整和引入，这样团队提升效果最明显，但是这个需要团队和公司整体努力才能达到。通过沟通和分析我们当时的团队内外情况，全面引入条件还不成熟，所以只能逐步引入。通过分析我们团队自身情况，决定优先引入能最大化解决团队 撕逼和甩锅 情况的实践。这里我们选着了：\n 统一团队对“完成”的定义  在某次迭代完成过后，选在了一个下午时间，我们整个团队发起了《针对“完成”定义的讨论会议》，会议分成 5 个阶段：\n 说明会议原则   谦虚、尊重、信任原则\n会议期间尽量不被“打扰”，手机或者其他任何事情\n  收集大家对“完成”的想法：   使用便签箱收集大家的想法，每个参会成员使用便签写下自己的想法，然后读出来，最后将便签投入便签箱中，可以是新想法，也可以是对别人的补充。便签箱不断在成员之间循环传递，就会有越来越多的想法，直到大家所有想法都收集完了，一般在 3 轮后基本就完了。\n  整理大家想法   将搜集到的想法全部贴在版本上，记住是全部并且最好能大家一起做，同时将重复的便签贴在一起。然后移动便签，将意思相近的便签挨在一起，这样就形成了初略的分类。\n  讨论“完成”   对白板上的便签和初步形成的分类进行讨论和提炼，在过程中不断调整分类和精炼完成解释\n  总结得到最新“完成”定义   总结大家对分类和完成的讨论，结果形成 SMART 目标\n 在整个过程中需要保持谦虚、尊重、信任的原则，这样才能保持平等公平，让团队在微小的声音都被听到。最总我们得出了我们对于迭代完成的定义:\n团队信息透明：看板 为了做到团队信息透明，我们引入了看板方法，目标是尽量做到迭代过程中：所有人员对团队的任何信息“信息触手可及”。第一次引入看板我们没有进行全员参与，是由我直接给出了一个初始看板设计。\n 这里如果大家团队有时间建议还是全员参与看板设计，这样大家对流程理解会更清晰。如果做不到全员参与设计关系也不大，因为看板本身是跟着团队不断进化的，在你团队感觉他不合适的时候，再来改进也是可以的。比如我们团队现在看板是这样的（这个是在后来团队所有成员一起改进了 2 次后的）\n 及时有效沟通：每日晨会 每日例会我们称为晨会，因为我们是规定在早上进行。我们会选择一位主持人来主持晨会，晨会上每个人主要回答三个问题：\n 昨天做了什么？ 今天计划做什么？ 有没有遇到问题？  主持人也可以在这个3个主要问题之上加入自己的内容，主持人要引导大家回答出这3个问题。通过这样的方式让团队成员对团队做出承诺，并让团队监督你的承诺是否有被实现和你是否做出了过度承诺，同时也让团队人员思考团队其他人员是否需要帮助，我可以帮助哪些人。\n现在我们晨会形式也有所改变，主持人逐渐改变成一个迭代统一一个主持人，而不是原来的一天换一个主持人。并且主持的形式也可以有第二种选择\n 主持人对看板上每一个 未完成 的任务进行询问一下问题\n 任务现在什么状态？ 任务有无人在跟踪？ 有无阻力导致任务无法进行？ 完成任务还需要什么协助？   在每次晨会的时候，如果团队有发现需要改进的点（比如时间方法、沟通模式等），可以在会后来一个小的及时讨论，针对好的方案可以记录下来，留到回顾会议的时候详细讨论。\n迭代质量提升：迭代计划会议 迭代计划会议我们现在是由迭代学习会议和迭代评估会议 2 个会议组成。\n迭代学习会议 迭代backlog在我们开始一个迭代之前会由产品人员提前提取到迭代规划中（我们现在展现在TAPD中），并且和开发负责人确认好这个个迭代的开发范围。这个工作基本上是在上个迭代中后期完成的，产品人员在做的过程中需要和开发人员进行相关沟通，特别是开发负责人，所以这个时期的开发人员积极支持也是很关键的。在这个backlog里面，每个需求必须写明业务逻辑和验收标准，如果有必要还需要补充使用场景说明和功能的UI设计。\n迭代评估会议 迭代计划主要是围绕迭代backlog进行，我们对迭代计划会议做了不少调整。我们首先在迭代计划中进行业务学习会议，在这个过程中我们要求每个开发人员和测试人员对本次迭代范围内的业务进行宣讲，其他没有参与宣讲的人员需要对宣讲人员的疑问进行解答，特别是产品人员。在这个过程中让我们每个开发人员对业务目标达成共识，识别迭代中的重点和难点。同时这个过程可以对迭代范围提出质疑，如果有质疑，团队则必须在会议中决策出迭代范围。然后我们会在业务学习会议过后，立即召开难点设计会议，这个会议目前主要是开发人员参与，在会议上开发人员要针对迭代中的难点和重点进行详细设计，这个过程中如果有必要会协调产品人员一起参与（如范围调整，实现复杂度导致业务功能的变化等），得出详细设计中需要的必要结果（如：ER图，流程图，时序图等），如果有需要会后形成详细的设计说明书，一般情况下将会议中形成的白板图形成文档即可。最后所有人员对业务目标和重难点的设计达成一致后，开发人员进行估算会议，我们现在才用的形式是卡牌游戏对任务进行评估，目前通过卡牌游戏可以在一定程度上规避个人经验主义和单点故障问题。进过迭代计划会议团队对整个迭代的业务范围和迭代时间做出承诺，当然这个迭代计划会议持续的时间会随着迭代范围和难度有很大变化，目前我们团队最长的一次时间是5个工作日。\n迭代质量提升：code review 每日分享会我们之前叫做每日code review 或 集体代码解释（只有开发人员参与），但是由于近期产品人员和测试人员的参与，发现之前的名字已经不合适了，就改成了每日分享会。每日分享会紧跟在每日例会后进行，也像每日例会一样选定一个分享者（之前是2个）来完成一个30分钟的分享，并且对于开发人员做了特定规定只能做code review，目前规定这个主持人和每日例会主持人为同一人。并且在每日分享会过后，观察者（目前是项目负责人）有义务并且也是必须和当天主持人一起对当天他自己的表现做一个简单的评估和回顾，并做相关记录。这里不只是包括人员的技术，还包括人员的沟通、演讲等能力。\n目前这个会议也在调整，之前一个分享者很多时候不能达到 30 分钟，并且现在团队的情况让产品、开发和测试一起做分享已经不再合适。\n高效学习团队：迭代回顾会议 迭代会议必须准守 2 个基本原则：\n 无论我们发现了什么，考虑到当时的已知情况、个人的技术水平和能力、可用的资源，以及现实情况，我们理解并坚信：每个人对自己的工作都已全力以赴。 我们的目标是发现改进的机会，而不是去责备某个人  迭代回顾会议在整个迭代上线完成过后进行，迭代会议也和我们的晨会一样，选定一位主持人。主持人负责引导团队回顾在本次迭代中：\n 团队实践回顾（这里有很多方法，如：时间轴法，团队情绪表等） 团队做得好的地方； 有哪些地方我们可以做得更好； 我们可以做哪些实践来让我们改善。  在操作过程中我们会让团队所有人员对我们可以做得更好的事情，进行投票选举出团队认为最急迫、最重要的前面3个出来，我们进行讨论得出我们需要的实践。在得出实践的过程中，最重要的是团队可以看到实际可执行的实践，也就是这个实践最好有明确的结果和判断好坏的标准，能形成 SMART 目标最好。主持人在这个会议中，也可以加入自己的元素，但是需要遵守2个原则：\n 不能偏离主题内容； 必须是针对整个团队的内容。  以下是我们一次在迭代会议中进行的团队情绪表实践：\n在这里回顾会议中 Master 角色的人(观察者)员需要记录会议全过程，并且需要把会议记录同步到所有人，一下使我们使用的记录末班\n   记录项 内容     记录 记录这次会议的内容   历史问题跟踪 前一次会议总结内容，需要提醒住持人让团队评估上次的目标是否完成   总结 记录这次会议得出的结论 和 目标   观察 观察这次迭代回顾会议本省的情况，并在会后主持人和团队交流可以改进的地方    迭代回顾会议可以让我们及时发现团队需要改进的地方，也可以让我们发现团队里面需要继续维持的地方，让我们不断调整团队步伐和实践，让团队里面正确的、好的事情不断发生。\n未来 我们目前正在引入的实践\n TDD（测试驱动开发） 迭代演示 CI/CD 迭代跟踪者  同时也在不断调整我们现在的部分实践，如完成的定义、团队卓越（高效绩）的定义和目标。这就意味着团队会是一个持续变化和持续学习的过程，同时团队所在的外界因素也在不断的变化，这就需要团队的每个人都需要做到“学习学习再学习，实践实践再实践”，让团队不断的成长来适应各种变化。\n总结 管理方法论改变和进化的驱动力是项目利益的最大化，但是改变的本质是项目的沟通模式。沟通模式的改变可以是信息的展现形式、信息的载体、信息的传递方式、信息流转和反馈方式。这些改变都会对我们项目管理中其他方面产生直接影响，并且也直接影响到我们的管理模式。在项目进行过程中既需要一对一的精细沟通，也需要针对项目成功目标的宏观沟通。\n我们上面谈到了项目沟通中模式的改变，其实由于沟通模式的改变，会引发项目中其他管理方面的改变。\n在这个过程中团队负责人要保证团队是在正确的道路上，并且要让正确的事情不断的发生。及时识别团队的所处阶段，识别为团队引入变化的时机，及时引入变化；不断通过实践结果总结团队的失败模式和成功模式，促进成功模式不断出现，让团队在不断出现的失败模式中恢复。同时和团队一起不断提高自己，做好对自我掌控，定义好自己的成功，接受团队比自己更好的想法。\n推荐给大家几本团队和管理方法的书：\n 《Scrum 敏捷软件开发》 《Scrum 实战：故事、模型与成功秘诀》 《Scrum 精髓：敏捷转型指南》 《敏捷软件开发实践：估算与计划》 《敏捷教练：如何打造优秀的敏捷团队》 《如何构建敏捷项目管理团队》 《看板方法》 《看板实战》 《架构即未来》 ", "content_s": "目前 我们 团队 正 实践   Scrum   框架   和   看 板 管理 ， 这边 文章 正是 对 我们 自己 的 实践 的 记录 。 这里 的 记录 并 不是 按照 时间 顺序 进行 的 ， 而是 按照 我 自己 的 针对 实践 目标 的 先后 进行 的 。 目前 我们 团队 还 没有 完全 实现 以上 所有 目标 ， 对   Scrum   框架   理解 和 使用 也 还 在 初级 阶段 初级阶段 ， 所以 有 很多 不足 的 地方 ， 并且 还有 很多 地方 还 在 胜于 聊胜于无 的 状态 ， 欢迎 大家 指正 。 \n 我们 现在 正在 进行 的 实践 有 ： \n   统一 团队 对 “ 完成 ” 的 定义   看 板 管理 流程   每日 晨会   迭代 回顾 会议   迭代 计划 会议   code   review     我们 团队 刚 开始 的 时候 管理 、 开发 混乱 完全 没有 章法 ， 大家 各种 打架 、 各种 撕 逼 、 各种 甩锅 。 没有 哪 一次 迭代 不 通宵 ， 没有 哪 一次 迭代 不 延期 ， 没有 哪 一次 迭代 质量 过关 ， 没有 哪 一次 上线 不 出 问题 ， 这种 状态 持续 了 很长 一段 时间 段时间 一段时间 。 我 感觉 不行 了 ， 再 这样 下去 还 能 做 个 啥 产品 ， 开始 寻找 各种 解决 方案 解决方案 并且 不断 反思 团队 遇到 问题 的 本质 ， 后来 学习 了 敏捷 ， 接触 到   Scrum   和   看 板 ， 里面 的 方法 方法论 和 实践 操作 不 正是 我们 团队 需要 的 吗 ？ 于是 坚决 决定 团队 开始 敏捷 实践 ， 当然 正 所谓 ： 软件 开发 软件开发 没有 银弹 ， 实践 证明 实践证明   Scrum   和   看板 并 不能 解决 我们 团队 所有 问题 ， 但是 确实 可以 让 团队 慢慢 变 好 。 \n \n 团队 目标 一致 ： 完成 定义   虽然 决定 引入   Scrum   和   看 板 ， 但是 从 哪里 开始 呢 ？ 这么 多 团队 问题 ， 应该 从 哪个 或 哪几 几个 哪几个 问题 开始 引入 解决 呢 ？ 还是 团队 全面 调整 引入 ？ 这些 问题 是 任何 团队 在 开始 引入 的 时候 都 会 遇到 的 ， 但是 我 相信 每个 团队 最后 的 答案 都 是 不 一样 的 。 Scrum   框架 建议 团队 全面 调整 和 引入 ， 这样 团队 提升 效果 最 明显 ， 但是 这个 需要 团队 和 公司 整体 努力 才能 达到 。 通过 沟通 和 分析 我们 当时 的 团队 内外 情况 ， 全面 引入 条件 还 不 成熟 ， 所以 只能 逐步 引入 。 通过 分析 我们 团队 自身 情况 ， 决定 优先 引入 能 最大 大化 最大化 解决 团队   撕 逼 和 甩 锅   情况 的 实践 。 这里 我们 选着 了 ： \n   统一 团队 对 “ 完成 ” 的 定义     在 某次 迭代 完成 过后 ， 选在 了 一个 下午 时间 ， 我们 整个 团队 发起 了 《 针对 “ 完成 ” 定义 的 讨论 会议 》 ， 会议 分成   5   个 阶段 ： \n   说明 会议 原则       谦虚 、 尊重 、 信任 原则 \n 会议 期间 尽量 不 被 “ 打扰 ” ， 手机 或者 其他 任何 事情 \n     收集 大家 对 “ 完成 ” 的 想法 ：       使用 便签 箱 收集 大家 的 想法 ， 每个 参会 成员 使用 便签 写下 自己 的 想法 ， 然后 读出 出来 读出来 ， 最后 将 便签 投入 便签 箱中 ， 可以 是 新 想法 ， 也 可以 是 对 别人 的 补充 。 便签 箱 不断 在 成员 之间 循环 传递 ， 就 会 有 越来 越来越 多 的 想法 ， 直到 大家 所有 想法 都 收集 完 了 ， 一般 在   3   轮后 基本 就 完 了 。 \n     整理 大家 想法       将 搜集 到 的 想法 全部 贴 在 版本 上 ， 记住 是 全部 并且 最好 能 大家 一起 做 ， 同时 将 重复 的 便签 贴 在 一起 。 然后 移动 便签 ， 将 意思 相近 的 便签 挨 在 一起 ， 这样 就 形成 了 初略 的 分类 。 \n     讨论 “ 完成 ”       对 白板 上 的 便签 和 初步 形成 的 分类 进行 讨论 和 提炼 ， 在 过程 中 不断 调整 分类 和 精炼 完成 解释 \n     总结 得到 最新 “ 完成 ” 定义       总结 大家 对 分类 和 完成 的 讨论 ， 结果 形成   SMART   目标 \n   在 整个 过程 中 需要 保持 谦虚 、 尊重 、 信任 的 原则 ， 这样 才能 保持 平等 公平 ， 让 团队 在 微小 的 声音 都 被 听到 。 最 总 我们 得出 了 我们 对于 迭代 完成 的 定义 : \n 团队 信息 透明 ： 看 板   为了 做到 团队 信息 透明 ， 我们 引入 了 看板 方法 ， 目标 是 尽量 做到 迭代 过程 中 ： 所有 人员 对 团队 的 任何 信息 “ 信息 触手 触手可及 ” 。 第一 一次 第一次 引入 看 板 我们 没有 进行 全员 参与 ， 是 由 我 直接 给出 了 一个 初始 看 板 设计 。 \n   这里 如果 大家 团队 有 时间 建议 还是 全员 参与 看 板 设计 ， 这样 大家 对 流程 理解 会 更 清晰 。 如果 做 不到 全员 参与 设计 关系 也 不大 ， 因为 看 板 本身 是 跟着 团队 不断 进化 的 ， 在 你 团队 感觉 他 不 合适 的 时候 ， 再 来 改进 也 是 可以 的 。 比如 我们 团队 现在 看板 是 这样 的 （ 这个 是 在 后来 团队 所有 成员 一起 改进 了   2   次后 的 ） \n   及时 有效 沟通 ： 每日 晨会   每日 例会 我们 称为 晨会 ， 因为 我们 是 规定 在 早上 进行 。 我们 会 选择 一位 主持 主持人 来 主持 晨会 ， 晨会 上 每个 人 主要 回答 三个 问题 ： \n   昨天 做 了 什么 ？   今天 计划 做 什么 ？   没有 有没有 遇到 问题 ？     主持 主持人 也 可以 在 这个 3 个 主要 问题 之上 加入 自己 的 内容 ， 主持 主持人 要 引导 大家 回答 出 这 3 个 问题 。 通过 这样 的 方式 让 团队 成员 对 团队 做出 承诺 ， 并 让 团队 监督 你 的 承诺 是否 有 被 实现 和 你 是否 做出 了 过度 承诺 ， 同时 也 让 团队 人员 思考 团队 其他 人员 是否 需要 帮助 ， 我 可以 帮助 哪些 人 。 \n 现在 我们 晨会 形式 也 有所 改变 ， 主持 主持人 逐渐 改变 成 一个 迭代 统一 一个 主持 主持人 ， 而 不是 原来 的 一天 换 一个 主持 主持人 。 并且 主持 的 形式 也 可以 有 第二 二种 第二种 选择 \n   主持 主持人 对 看板 上 每 一个   未 完成   的 任务 进行 询问 一下 问题 \n   任务 现在 什么 状态 ？   任务 有 无人 在 跟踪 ？   有无 阻力 导致 任务 无法 进行 ？   完成 任务 还 需要 什么 协助 ？       在 每次 晨会 的 时候 ， 如果 团队 有 发现 需要 改进 的 点 （ 比如 时间 方法 、 沟通 模式 沟通模式 等 ） ， 可以 在 会 后来 一个 小 的 及时 讨论 ， 针对 好 的 方案 可以 记录 录下 下来 录下来 记录下来 ， 留 到 回顾 会议 的 时候 详细 讨论 。 \n 迭代 质量 提升 ： 迭代 计划 会议   迭代 计划 会议 我们 现在 是 由 迭代 学习 会议 和 迭代 评估 会议   2   个 会议 组成 。 \n 迭代 学习 会议   迭代 backlog 在 我们 开始 一个 迭代 之前 会 由 产品 人员 提前 提取 到 迭代 规划 中 （ 我们 现在 展现 在 TAPD 中 ） ， 并且 和 开发 负责 责人 负责人 确认 好 这个 个 迭代 的 开发 范围 。 这个 工作 基本 基本上 是 在 上 个 迭代 后期 中后期 完成 的 ， 产品 人员 在 做 的 过程 中 需要 和 开发 发人 人员 开发人员 进行 相关 沟通 ， 特别 是 开发 负责 责人 负责人 ， 所以 这个 时期 的 开发 发人 人员 开发人员 积极 支持 积极支持 也 是 很 关键 的 。 在 这个 backlog 里面 ， 每个 需求 必须 写明 业务 逻辑 和 验收 标准 ， 如果 有 必要 还 需要 补充 使用 场景 说明 和 功能 的 UI 设计 。 \n 迭代 评估 会议   迭代 计划 主要 是 围绕 迭代 backlog 进行 ， 我们 对 迭代 计划 会议 做 了 不少 调整 。 我们 首先 在 迭代 计划 中 进行 业务 学习 业务学习 会议 ， 在 这个 过程 中 我们 要求 每个 开发 发人 人员 开发人员 和 测试 人员 测试人员 对 本次 迭代 范围 内 的 业务 进行 宣讲 ， 其他 没有 参与 宣讲 的 人员 需要 对 宣讲 人员 的 疑问 进行 解答 ， 特别 是 产品 人员 。 在 这个 过程 中 让 我们 每个 开发 发人 人员 开发人员 对 业务 目标 达成 共识 ， 识别 迭代 中 的 重点 和 难点 。 同时 这个 过程 可以 对 迭代 范围 提出 质疑 ， 如果 有 质疑 ， 团队 则 必须 在 会议 中 决策 出 迭代 范围 。 然后 我们 会 在 业务 学习 业务学习 会议 过后 ， 立即 召开 难点 设计 会议 ， 这个 会议 目前 主要 是 开发 发人 人员 开发人员 参与 ， 在 会议 上 开发 发人 人员 开发人员 要 针对 迭代 中 的 难点 和 重点 进行 详细 设计 ， 这个 过程 中 如果 有 必要 会 协调 产品 人员 一起 参与 （ 如 范围 调整 ， 实现 复杂 复杂度 导致 业务 功能 的 变化 等 ） ， 得出 详细 设计 中 需要 的 必要 结果 （ 如 ： ER 图 ， 流程 流程图 ， 时序 图 等 ） ， 如果 有 需要 会后 形成 详细 的 设计 说明 说明书 ， 一般 情况 下 将 会议 中 形成 的 白板 图 形成 文档 即可 。 最后 所有 人员 对 业务 目标 和 难点 重难点 的 设计 达成 一致 后 ， 开发 发人 人员 开发人员 进行 估算 会议 ， 我们 现在 才 用 的 形式 是 卡牌 游戏 对 任务 进行 评估 ， 目前 通过 卡牌 游戏 可以 在 一定 程度 上 规避 个人 经验 主义 经验主义 和 单点 故障 单点故障 问题 。 进 过 迭代 计划 会议 团队 对 整个 迭代 的 业务 范围 业务范围 和 迭代 时间 做出 承诺 ， 当然 这个 迭代 计划 会议 持续 的 时间 会 随着 迭代 范围 和 难度 有 很大 变化 ， 目前 我们 团队 最长 的 一次 时间 是 5 个 工作 工作日 。 \n 迭代 质量 提升 ： code   review   每日 分享 会 我们 之前 叫做 每日 code   review   或   集体 代码 解释 （ 只有 开发 发人 人员 开发人员 参与 ） ， 但是 由于 近期 产品 人员 和 测试 人员 测试人员 的 参与 ， 发现 之前 的 名字 已经 不 合适 了 ， 就 改成 了 每日 分享 会 。 每日 分享 会 紧跟 在 每日 例会 后 进行 ， 也 像 每日 例会 一样 选定 一个 分享 分享者 （ 之前 是 2 个 ） 来 完成 一个 30 分钟 的 分享 ， 并且 对于 开发 发人 人员 开发人员 做 了 特定 规定 只能 做 code   review ， 目前 规定 这个 主持 主持人 和 每日 例会 主持 主持人 为 同一 人 。 并且 在 每日 分享 会 过后 ， 观察 观察者 （ 目前 是 项目 负责 责人 负责人 ） 有 义务 并且 也 是 必须 和 当天 主持 主持人 一起 对 当天 他 自己 的 表现 做 一个 简单 的 评估 和 回顾 ， 并 做 相关 记录 。 这里 不 只是 包括 人员 的 技术 ， 还 包括 人员 的 沟通 、 演讲 等 能力 。 \n 目前 这个 会议 也 在 调整 ， 之前 一个 分享 分享者 很多 时候 不能 达到   30   分钟 ， 并且 现在 团队 的 情况 让 产品 、 开发 和 测试 一起 做 分享 已经 不再 合适 。 \n 高效 学习 团队 ： 迭代 回顾 会议   迭代 会议 必须 准守   2   个 基本 原则 ： \n   无论 我们 发现 了 什么 ， 考虑 到 当时 的 已知 情况 、 个人 的 技术 水平 技术水平 和 能力 、 可用 的 资源 ， 以及 现实 实情 情况 现实情况 ， 我们 理解 并 坚信 ： 每个 人 对 自己 的 工作 都 已 全力 全力以赴 。   我们 的 目标 是 发现 改进 的 机会 ， 而 不是 去 责备 某个 人     迭代 回顾 会议 在 整个 迭代 上线 完成 过后 进行 ， 迭代 会议 也 和 我们 的 晨会 一样 ， 选定 一位 主持 主持人 。 主持 主持人 负责 引导 团队 回顾 在 本次 迭代 中 ： \n   团队 实践 回顾 （ 这里 有 很多 方法 ， 如 ： 时间 时间轴 法 ， 团队 情绪 表等 ）   团队 做得好 的 地方 ；   有 哪些 地方 哪些地方 我们 可以 做 得 更好 ；   我们 可以 做 哪些 实践 来 让 我们 改善 。     在 操作 作过 过程 操作过程 中 我们 会 让 团队 所有 人员 对 我们 可以 做 得 更好 的 事情 ， 进行 投票 票选 选举 投票选举 出 团队 认为 最 急迫 、 最 重要 的 前面 3 个 出来 ， 我们 进行 讨论 得出 我们 需要 的 实践 。 在 得出 实践 的 过程 中 ， 最 重要 的 是 团队 可以 看到 实际 可 执行 的 实践 ， 也 就是 这个 实践 最好 有 明确 的 结果 和 判断 好坏 的 标准 ， 能 形成   SMART   目标 最好 。 主持 主持人 在 这个 会议 中 ， 也 可以 加入 自己 的 元素 ， 但是 需要 遵守 2 个 原则 ： \n   不能 偏离 主题 内容 ；   必须 是 针对 整个 团队 的 内容 。     以下 是 我们 一次 在 迭代 会议 中 进行 的 团队 情绪 表 实践 ： \n 在 这里 回顾 会议 中   Master   角色 的 人 ( 观察 观察者 ) 员 需要 记录 会议 过程 全过程 ， 并且 需要 把 会议 记录 会议记录 同步 到 所有 有人 所有人 ， 一下 使 我们 使用 的 记录 末班 \n       记录 项   内容           记录   记录 这次 会议 的 内容       历史 问题 跟踪   前 一次 会议 总结 内容 ， 需要 提醒 住持 人 让 团队 评估 上次 的 目标 是否 完成       总结   记录 这次 会议 得出 的 结论   和   目标       观察   观察 这次 迭代 回顾 会议 本省 的 情况 ， 并 在 会后 主持 主持人 和 团队 交流 可以 改进 的 地方         迭代 回顾 会议 可以 让 我们 及时 发现 及时发现 团队 需要 改进 的 地方 ， 也 可以 让 我们 发现 团队 里面 需要 继续 维持 的 地方 ， 让 我们 不断 调整 团队 步伐 和 实践 ， 让 团队 里面 正确 的 、 好 的 事情 不断 发生 。 \n 未来   我们 目前 正在 引入 的 实践 \n   TDD （ 测试 驱动 开发 ）   迭代 演示   CI / CD   迭代 跟踪 者     同时 也 在 不断 调整 我们 现在 的 部分 实践 ， 如 完成 的 定义 、 团队 卓越 （ 高效 绩 ） 的 定义 和 目标 。 这 就 意味 意味着 团队 会 是 一个 持续 变化 和 持续 学习 的 过程 ， 同时 团队 所在 的 外界 因素 也 在 不断 的 变化 ， 这 就 需要 团队 的 每个 人 都 需要 做到 “ 学习 学习 再 学习 ， 实践 实践 再 实践 ” ， 让 团队 不断 的 成长 来 适应 各种 变化 。 \n 总结   管理 方法 方法论 改变 和 进化 的 驱动 动力 驱动力 是 项目 利益 的 最大 大化 最大化 ， 但是 改变 的 本质 是 项目 的 沟通 模式 沟通模式 。 沟通 模式 沟通模式 的 改变 可以 是 信息 的 展现 形式 、 信息 的 载体 、 信息 的 传递 方式 、 信息 流转 和 反馈 方式 。 这些 改变 都 会 对 我们 项目 管理 项目管理 中 其他 方面 产生 直接 影响 ， 并且 也 直接 影响 到 我们 的 管理 模式 管理模式 。 在 项目 进行 过程 中 既 需要 一对 一对一 的 精细 沟通 ， 也 需要 针对 项目 成功 目标 的 宏观 沟通 。 \n 我们 上面 谈到 了 项目 沟通 中 模式 的 改变 ， 其实 由于 沟通 模式 沟通模式 的 改变 ， 会 引发 项目 中 其他 管理 方面 的 改变 。 \n 在 这个 过程 中 团队 负责 责人 负责人 要 保证 团队 是 在 正确 的 道路 上 ， 并且 要 让 正确 的 事情 不断 的 发生 。 及时 识别 团队 的 所处 阶段 ， 识别 为 团队 引入 变化 的 时机 ， 及时 引入 变化 ； 不断 通过 实践 结果 总结 团队 的 失败 模式 和 成功 模式 ， 促进 成功 模式 不断 出现 ， 让 团队 在 不断 出现 的 失败 模式 中 恢复 。 同时 和 团队 一起 不断 提高 自己 ， 做好 对 自我 掌控 ， 定义 好 自己 的 成功 ， 接受 团队 比 自己 更好 的 想法 。 \n 推荐 给 大家 几本 团队 和 管理 方法 的 书 ： \n   《 Scrum   敏捷 软件 开发 软件开发 》   《 Scrum   实战 ： 故事 、 模型 与 成功 秘诀 》   《 Scrum   精髓 ： 敏捷 转型 指南 》   《 敏捷 软件 开发 软件开发 实践 ： 估算 与 计划 》   《 敏捷 教练 ： 如何 打造 优秀 的 敏捷 团队 》   《 如何 构建 敏捷 项目 管理 项目管理 团队 》   《 看 板 方法 》   《 看 板 实战 》   《 架构 即 未来 》  ", "title_s": "Scrum   +   看 板   开发 实践 ： 记录"}, {"description": "本文是总结我自己在使用 Hugo 进行建站的时候给网站增加内容检索功能的结果。做这个功能的一个原因也是由于自己使用的 Even 主题没有带检索功能，所有只有自己上手撸一把。使用的检索方案包括 Lunrjs 和 Algolia，本文的处理方式可以同时支持 2 中方式，可以根据自己的情况自由选择或切换。", "objectID": "https://blog.threeq.me/post/notes/hugo-site-search/", "tags": ["Hugo"], "title": "Hugo 网站增加搜索功能：Lunrjs 和 Algolia", "uri": "https://blog.threeq.me/post/notes/hugo-site-search/", "content": "本文是总结我自己在使用 Hugo 进行建站的时候给网站增加内容检索功能的结果。做这个功能的一个原因也是由于自己使用的 Even 主题没有带检索功能，所有只有自己上手撸一把。使用的检索方案包括 Lunrjs 和 Algolia，本文的处理方式可以同时支持 2 中方式，可以根据自己的情况自由选择或切换。\n\n很多的 Hugo 主题是没有自带搜索功能的，但是们为了方便用户浏览和查找内容是需要在网站上提供搜索功能。大家可以查看 Hugo 官方推荐的搜索方案，我在使用的时候选择的是 Lunr 和 Algolial，以下是我的方案记录。\n生产网站 JSON 数据 由于 Lunr 和 Algolia 都同时对 JSON 数据格式的支持，所以这里我们选用网站的 JSON 数据格式。\n首先需要在 config.toml 里面增加配置\n[outputs] home = [ &quot;HTML&quot;, &quot;RSS&quot;, &quot;JSON&quot;]  其次需要在你的主题目录里面新建 themes/&lt;your themme name&gt;/layouts/index.json 文件，输入一下内容\n[{{ range $index, $page := .Site.Pages }} {{- if ne $page.Type &quot;json&quot; -}} {{- if and $index (gt $index 0) -}},{{- end }} { &quot;uri&quot;: &quot;{{ $page.Permalink }}&quot;, &quot;title&quot;: &quot;{{ htmlEscape $page.Title}}&quot;, &quot;tags&quot;: [{{ range $tindex, $tag := $page.Params.tags }}{{ if $tindex }}, {{ end }}&quot;{{ $tag| htmlEscape }}&quot;{{ end }}], &quot;description&quot;: &quot;{{ htmlEscape .Description}}&quot;, &quot;content&quot;: {{$page.Plain | jsonify}} } {{- end -}} {{- end -}}]  这个时候我们使用 hugo 生成网站的时候会多生成一个 public/index.json 的数据文件，我们的所有操作都围绕这个数据文件进行。\n搜索框添加  这里的搜索框 HTML、CSS 代码添加会根据你自己的主题会有所不同\n 首先为了支持不同的搜索解决方案，我们需要在 config.toml 里面增加如下配置，这样我们在使用的时候就可以自由的开关和切换搜索功能\n[params.Search] enable = true # true or false type = 'algolia' # lunr or algolia index = 'algolia_index' # algolia enabled appID = 'algolia_application_id' # algolia enabled searchKey = 'algolia_search_only_key' # algolia enabled  然后将一下代码加入到你主题的相应位置\n{{- if .Site.Params.Search.Enable }} &lt;link href=&quot;{{&quot;lib/search/auto-complete.css&quot; | relURL}}&quot; rel=&quot;stylesheet&quot;&gt; &lt;div class=&quot;search-wrapper&quot;&gt; &lt;div class=&quot;searchbox&quot;&gt; &lt;div id='inputfield'&gt; &lt;i class='fa fa-search icon-search'&gt;&lt;/i&gt; &lt;input id=&quot;search-by&quot; autocomplete='off' autocorrect='off' name='address' placeholder=&quot;{{T &quot;Search-placeholder&quot;}}&quot; spellcheck='false' type='text'&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; {{- if (eq .Site.Params.Search.type &quot;lunr&quot;) }} &lt;script type=&quot;text/javascript&quot;&gt; {{ if .Site.IsMultiLingual }} var baseurl = &quot;{{.Site.BaseURL}}{{.Site.LanguagePrefix}}&quot;; {{ else }} var baseurl = &quot;{{.Site.BaseURL}}&quot;; {{ end }} &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/lunr/lunr.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/lunr/auto-complete.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/lunr/search.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; {{- else }} &lt;script type=&quot;text/javascript&quot;&gt; var lagoliaIndex = &quot;{{.Site.Params.Search.index}}&quot; var lagoliaAppID = &quot;{{.Site.Params.Search.appID}}&quot; var lagoliaSearchKey = &quot;{{.Site.Params.Search.searchKey}}&quot; &lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;{{&quot;lib/search/algolia/search-bar.js&quot; | relURL}}&quot;&gt;&lt;/script&gt; {{- end}} {{- end}}  这里用到的一些 JS文件 和 CSS 文件请到此地址下载：https://github.com/threeq/blog.threeq.me/tree/master/themes/even/static/lib/search，放到 static/lib/search 目录下。\n到这里我们为网站所加入的 Lunr 搜索功能就完成了，由于 Lunr 对于中文检索支持很差，我们需要手动处理一下我们的 public/index.josn，进行中文分词。同时这里需要使 Algolia 支持的话，也需要将我们的 JSON 数据提交到 Algolia 数据库中。\n搜索数据预处理 这里为了同时能将 public/index.josn 数据进行中文分词和提交到 Algolia 中，我这里自己写了一个 Python 脚本，方便处理和后续集成自动发布。在网站根目录新建文件 search_process.py，输入一下内容（你也可以到 这里下载）：\n# encoding=utf-8 &quot;&quot;&quot; Hugo 网站使用 Lunr 和 Algolia 搜索方案数据处理 数据处理需要用到 algoliasearch 和 jieba 库，先安装 pip install algoliasearch pip install jieba &quot;&quot;&quot; import sys reload(sys) sys.setdefaultencoding('utf-8') import os from algoliasearch import algoliasearch import jieba import json import argparse parser = argparse.ArgumentParser(description=&quot;site search data process.&quot;) parser.add_argument('--managehKey', '-k', required=False, help='algolia manage key') args = parser.parse_args() def sign_version(data): &quot;&quot;&quot; 计算版本签名 &quot;&quot;&quot; return hash(data['uri'] + '__' + data['title'] + '__' + data['content'])\tdef push_data(items): &quot;&quot;&quot; 提交数据变更 &quot;&quot;&quot; client = algoliasearch.Client(&quot;NIACONWTKJ&quot;, args.managehKey) index = client.init_index('blog.threeq.me') res = index.add_objects(items) print(&quot;push count: %d. items:\\n%s&quot; % (len(res), json.dumps(res, ensure_ascii=False, indent=2))) def delete_data(items): &quot;&quot;&quot; 删除数据 &quot;&quot;&quot; client = algoliasearch.Client(&quot;NIACONWTKJ&quot;, args.managehKey) index = client.init_index('blog.threeq.me') res = index.delete_objects(items) print(&quot;delete count: %d. items:\\n%s&quot; % (len(res), json.dumps(res, ensure_ascii=False, indent=2))) def algolia_push(): &quot;&quot;&quot; algolia 数据提交 &quot;&quot;&quot; # 得到已经 push 的数据 if os.path.isfile('public/index.push_version.json'): with open('public/index.push_version.json', 'r') as f: push_version_data = json.load(f) print(&quot;read version push data&quot;) else: push_version_data = dict() # 计算需要修改的数据 new_items = dict() add_items = [] del_items = [] for index in range(len(data_dict)): data = data_dict[index] data['objectID'] = data['uri'] new_items[(data['objectID'])] = True curr_version = sign_version(data) if push_version_data.has_key(data['objectID']): prev_version = push_version_data[data['objectID']] else: prev_version = None if curr_version != prev_version: add_items.append(data) push_version_data[data['objectID']] = curr_version for old_item in push_version_data.keys(): if not new_items.has_key(old_item): del_items.append(old_item) del push_version_data[old_item] # 需要删除数据 print(&quot;Delete lagolia items count： %d.&quot; % len(del_items)) if len(del_items) &gt; 0: delete_data(del_items) # 处理需要 push 的对象 if len(add_items) &gt; 0: push_data(add_items) else: print(&quot;Don't content Add or Modify. skipped lagolia push.&quot;) # 记录最新提交数据 with open('public/index.push_version.json', 'w') as f: json.dump(push_version_data,f, ensure_ascii=False) print(&quot;write recored push data&quot;) ###### # load public/index.json data ##### with open('public/index.json', 'r') as f: data_dict = json.load(f) print(&quot;load public/index.json complete.&quot;) ###### # algolia search process ###### if len(args.managehKey)&gt;0: algolia_push() else: print(&quot;skipped algolia push.&quot;) ###### # lunr search process # use jieba lib ###### for index in range(len(data_dict)): data = data_dict[index] data['title_s'] = &quot; &quot;.join(jieba.cut_for_search(data['title'])) data['content_s'] = &quot; &quot;.join(jieba.cut_for_search(data['content'])) print(&quot;word segmentation complete.&quot;) with open('public/index.json', 'w') as f: json.dump(data_dict,f, ensure_ascii=False) print(&quot;search process complete.&quot;)  这是可以使用如下命令进行操作\n$ python search_process.py -h # 查看帮助文档 $ python search_process.py -k '' # 只支持 Lunr 处理，中文分词 $ python search_process.py -k &lt;algolia manage key&gt; # 同时进行 Lunr 和 Algolia 处理 $ python search_process.py --managehKey &lt;algolia manage key&gt; # 同时进行 Lunr 和 Algolia 处理  加入发布流程 最后我们还可以很方便和发布流程集成，比如下面的 deploy.sh 脚本\n#!/bin/bash echo -e &quot;\\033[0;32mDeploying updates to GitHub...\\033[0m&quot; fail() { echo &quot;$1&quot; exit 1 } # Build the project. hugo # if using a theme, replace with `hugo -t &lt;YOURTHEME&gt;` echo &quot;search key $2&quot; searchKey=&quot;$2&quot; python2 search_process.py -k &quot;${searchKey}&quot; || fail &quot;site search data process fail. Error Code: [ $? ]&quot; # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=&quot;rebuilding site `date`&quot; if [ $# -ge 1 ] then msg=&quot;$1&quot; fi git commit -m &quot;$msg&quot; # Push source and build repos. git push origin master # Come Back up to the Project Root cd ..  使用时如下：\n$./deploy.sh $./deploy.sh &quot;this is message&quot; &lt;algolia manage key&gt; $./deploy.sh '' &lt;algolia manage key&gt;  参考：\n hugo-lunr-zh ", "content_s": "本文 是 总结 我 自己 在 使用   Hugo   进行 建站 的 时候 给 网站 增加 内容 检索 功能 的 结果 。 做 这个 功能 的 一个 原因 也 是 由于 自己 使用 的   Even   主题 没有 带 检索 功能 ， 所有 只有 自己 上手 撸 一把 。 使用 的 检索 方案 包括   Lunrjs   和   Algolia ， 本文 的 处理 方式 可以 同时 支持   2   中 方式 ， 可以 根据 自己 的 情况 自由 选择 自由选择 或 切换 。 \n \n 很多 的   Hugo   主题 是 没有 自带 搜索 功能 的 ， 但是 们 为了 方便 用户 浏览 和 查找 内容 是 需要 在 网站 上 提供 搜索 功能 。 大家 可以 查看   Hugo   官方 推荐 的 搜索 方案 ， 我 在 使用 的 时候 选择 的 是   Lunr   和   Algolial ， 以下 是 我 的 方案 记录 。 \n 生产 网站   JSON   数据   由于   Lunr   和   Algolia   都 同时 对   JSON   数据 格式 数据格式 的 支持 ， 所以 这里 我们 选用 网站 的   JSON   数据 格式 数据格式 。 \n 首先 需要 在   config . toml   里面 增加 配置 \n [ outputs ]   home   =   [   & quot ; HTML & quot ; ,   & quot ; RSS & quot ; ,   & quot ; JSON & quot ; ]     其次 需要 在 你 的 主题 题目 目录 主题目录 里面 新建   themes / & lt ; your   themme   name & gt ; / layouts / index . json   文件 ， 输入 一下 内容 \n [ { {   range   $ index ,   $ page   : =   . Site . Pages   } }   { { -   if   ne   $ page . Type   & quot ; json & quot ;   - } }   { { -   if   and   $ index   ( gt   $ index   0 )   - } } , { { -   end   } }   {   & quot ; uri & quot ; :   & quot ; { {   $ page . Permalink   } } & quot ; ,   & quot ; title & quot ; :   & quot ; { {   htmlEscape   $ page . Title } } & quot ; ,   & quot ; tags & quot ; :   [ { {   range   $ tindex ,   $ tag   : =   $ page . Params . tags   } } { {   if   $ tindex   } } ,   { {   end   } } & quot ; { {   $ tag |   htmlEscape   } } & quot ; { {   end   } } ] ,   & quot ; description & quot ; :   & quot ; { {   htmlEscape   . Description } } & quot ; ,   & quot ; content & quot ; :   { { $ page . Plain   |   jsonify } }   }   { { -   end   - } }   { { -   end   - } } ]     这个 时候 我们 使用   hugo   生成 网站 的 时候 会多 生成 一个   public / index . json   的 数据 文件 数据文件 ， 我们 的 所有 操作 都 围绕 这个 数据 文件 数据文件 进行 。 \n 搜索 框 添加     这里 的 搜索 框   HTML 、 CSS   代码 添加 会 根据 你 自己 的 主题 会 有所 不同 有所不同 \n   首先 为了 支持 不同 的 搜索 解决 方案 解决方案 ， 我们 需要 在   config . toml   里面 增加 如下 配置 ， 这样 我们 在 使用 的 时候 就 可以 自由 的 开关 和 切换 搜索 功能 \n [ params . Search ]   enable   =   true   #   true   or   false   type   =   ' algolia '   #   lunr   or   algolia   index   =   ' algolia _ index '   #   algolia   enabled   appID   =   ' algolia _ application _ id '   #   algolia   enabled   searchKey   =   ' algolia _ search _ only _ key '   #   algolia   enabled     然后 将 一下 代码 加入 到 你 主题 的 相应 位置 \n { { -   if   . Site . Params . Search . Enable   } }   & lt ; link   href = & quot ; { { & quot ; lib / search / auto - complete . css & quot ;   |   relURL } } & quot ;   rel = & quot ; stylesheet & quot ; & gt ;   & lt ; div   class = & quot ; search - wrapper & quot ; & gt ;   & lt ; div   class = & quot ; searchbox & quot ; & gt ;   & lt ; div   id = ' inputfield ' & gt ;   & lt ; i   class = ' fa   fa - search   icon - search ' & gt ; & lt ; / i & gt ;   & lt ; input   id = & quot ; search - by & quot ;   autocomplete = ' off '   autocorrect = ' off '   name = ' address '   placeholder = & quot ; { { T   & quot ; Search - placeholder & quot ; } } & quot ;   spellcheck = ' false '   type = ' text ' & gt ;   & lt ; / div & gt ;   & lt ; / div & gt ;   & lt ; / div & gt ;   { { -   if   ( eq   . Site . Params . Search . type   & quot ; lunr & quot ; )   } }   & lt ; script   type = & quot ; text / javascript & quot ; & gt ;   { {   if   . Site . IsMultiLingual   } }   var   baseurl   =   & quot ; { { . Site . BaseURL } } { { . Site . LanguagePrefix } } & quot ; ;   { {   else   } }   var   baseurl   =   & quot ; { { . Site . BaseURL } } & quot ; ;   { {   end   } }   & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / lunr / lunr . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / lunr / auto - complete . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / lunr / search . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   { { -   else   } }   & lt ; script   type = & quot ; text / javascript & quot ; & gt ;   var   lagoliaIndex   =   & quot ; { { . Site . Params . Search . index } } & quot ;   var   lagoliaAppID   =   & quot ; { { . Site . Params . Search . appID } } & quot ;   var   lagoliaSearchKey   =   & quot ; { { . Site . Params . Search . searchKey } } & quot ;   & lt ; / script & gt ;   & lt ; script   src = & quot ; / / cdn . jsdelivr . net / autocomplete . js / 0 / autocomplete . jquery . min . js & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   src = & quot ; / / cdn . jsdelivr . net / algoliasearch / 3 / algoliasearch . min . js & quot ; & gt ; & lt ; / script & gt ;   & lt ; script   type = & quot ; text / javascript & quot ;   src = & quot ; { { & quot ; lib / search / algolia / search - bar . js & quot ;   |   relURL } } & quot ; & gt ; & lt ; / script & gt ;   { { -   end } }   { { -   end } }     这里 用到 的 一些   JS 文件   和   CSS   文件 请 到 此 地址 下载 ： https : / / github . com / threeq / blog . threeq . me / tree / master / themes / even / static / lib / search ， 放到   static / lib / search   目录 下 。 \n 到 这里 我们 为 网站 所 加入 的   Lunr   搜索 功能 就 完成 了 ， 由于   Lunr   对于 中文 检索 支持 很差 ， 我们 需要 手动 处理 一下 我们 的   public / index . josn ， 进行 中文 分词 。 同时 这里 需要 使   Algolia   支持 的话 ， 也 需要 将 我们 的   JSON   数据 提交 到   Algolia   数据 据库 数据库 中 。 \n 搜索 数据 处理 预处理   这里 为了 同时 能 将   public / index . josn   数据 进行 中文 分词 和 提交 到   Algolia   中 ， 我 这里 自己 写 了 一个   Python   脚本 ， 方便 处理 和 后续 集成 自动 发布 。 在 网站 目录 根目录 新建 文件   search _ process . py ， 输入 一下 内容 （ 你 也 可以 到   这里 下载 ） ： \n #   encoding = utf - 8   & quot ; & quot ; & quot ;   Hugo   网站 使用   Lunr   和   Algolia   搜索 方案 数据 处理 数据处理   数据 处理 数据处理 需要 用到   algoliasearch   和   jieba   库 ， 先 安装   pip   install   algoliasearch   pip   install   jieba   & quot ; & quot ; & quot ;   import   sys   reload ( sys )   sys . setdefaultencoding ( ' utf - 8 ' )   import   os   from   algoliasearch   import   algoliasearch   import   jieba   import   json   import   argparse   parser   =   argparse . ArgumentParser ( description = & quot ; site   search   data   process .& quot ; )   parser . add _ argument ( ' - - managehKey ' ,   ' - k ' ,   required = False ,   help = ' algolia   manage   key ' )   args   =   parser . parse _ args ( )   def   sign _ version ( data ) :   & quot ; & quot ; & quot ;   计算 版本 签名   & quot ; & quot ; & quot ;   return   hash ( data [ ' uri ' ]   +   ' __ '   +   data [ ' title ' ]   +   ' __ '   +   data [ ' content ' ] ) \t def   push _ data ( items ) :   & quot ; & quot ; & quot ;   提交 数据 变更   & quot ; & quot ; & quot ;   client   =   algoliasearch . Client ( & quot ; NIACONWTKJ & quot ; ,   args . managehKey )   index   =   client . init _ index ( ' blog . threeq . me ' )   res   =   index . add _ objects ( items )   print ( & quot ; push   count :   % d .   items : \\ n% s & quot ;   %   ( len ( res ) ,   json . dumps ( res ,   ensure _ ascii = False ,   indent = 2 ) ) )   def   delete _ data ( items ) :   & quot ; & quot ; & quot ;   删除 数据   & quot ; & quot ; & quot ;   client   =   algoliasearch . Client ( & quot ; NIACONWTKJ & quot ; ,   args . managehKey )   index   =   client . init _ index ( ' blog . threeq . me ' )   res   =   index . delete _ objects ( items )   print ( & quot ; delete   count :   % d .   items : \\ n% s & quot ;   %   ( len ( res ) ,   json . dumps ( res ,   ensure _ ascii = False ,   indent = 2 ) ) )   def   algolia _ push ( ) :   & quot ; & quot ; & quot ;   algolia   数据 提交   & quot ; & quot ; & quot ;   #   得到 已经   push   的 数据   if   os . path . isfile ( ' public / index . push _ version . json ' ) :   with   open ( ' public / index . push _ version . json ' ,   ' r ' )   as   f :   push _ version _ data   =   json . load ( f )   print ( & quot ; read   version   push   data & quot ; )   else :   push _ version _ data   =   dict ( )   #   计算 需要 修改 的 数据   new _ items   =   dict ( )   add _ items   =   [ ]   del _ items   =   [ ]   for   index   in   range ( len ( data _ dict ) ) :   data   =   data _ dict [ index ]   data [ ' objectID ' ]   =   data [ ' uri ' ]   new _ items [ ( data [ ' objectID ' ] ) ]   =   True   curr _ version   =   sign _ version ( data )   if   push _ version _ data . has _ key ( data [ ' objectID ' ] ) :   prev _ version   =   push _ version _ data [ data [ ' objectID ' ] ]   else :   prev _ version   =   None   if   curr _ version   ! =   prev _ version :   add _ items . append ( data )   push _ version _ data [ data [ ' objectID ' ] ]   =   curr _ version   for   old _ item   in   push _ version _ data . keys ( ) :   if   not   new _ items . has _ key ( old _ item ) :   del _ items . append ( old _ item )   del   push _ version _ data [ old _ item ]   #   需要 删除 数据   print ( & quot ; Delete   lagolia   items   count ：   % d .& quot ;   %   len ( del _ items ) )   if   len ( del _ items )   & gt ;   0 :   delete _ data ( del _ items )   #   处理 需要   push   的 对象   if   len ( add _ items )   & gt ;   0 :   push _ data ( add _ items )   else :   print ( & quot ; Don ' t   content   Add   or   Modify .   skipped   lagolia   push .& quot ; )   #   记录 最新 提交 数据   with   open ( ' public / index . push _ version . json ' ,   ' w ' )   as   f :   json . dump ( push _ version _ data , f ,   ensure _ ascii = False )   print ( & quot ; write   recored   push   data & quot ; )   ######   #   load   public / index . json   data   #####   with   open ( ' public / index . json ' ,   ' r ' )   as   f :   data _ dict   =   json . load ( f )   print ( & quot ; load   public / index . json   complete .& quot ; )   ######   #   algolia   search   process   ######   if   len ( args . managehKey ) & gt ; 0 :   algolia _ push ( )   else :   print ( & quot ; skipped   algolia   push .& quot ; )   ######   #   lunr   search   process   #   use   jieba   lib   ######   for   index   in   range ( len ( data _ dict ) ) :   data   =   data _ dict [ index ]   data [ ' title _ s ' ]   =   & quot ;   & quot ; . join ( jieba . cut _ for _ search ( data [ ' title ' ] ) )   data [ ' content _ s ' ]   =   & quot ;   & quot ; . join ( jieba . cut _ for _ search ( data [ ' content ' ] ) )   print ( & quot ; word   segmentation   complete .& quot ; )   with   open ( ' public / index . json ' ,   ' w ' )   as   f :   json . dump ( data _ dict , f ,   ensure _ ascii = False )   print ( & quot ; search   process   complete .& quot ; )     这是 可以 使用 如下 命令 进行 操作 \n $   python   search _ process . py   - h   #   查看 帮助 文档   $   python   search _ process . py   - k   ' '   #   只 支持   Lunr   处理 ， 中文 分词   $   python   search _ process . py   - k   & lt ; algolia   manage   key & gt ;   #   同时 进行   Lunr   和   Algolia   处理   $   python   search _ process . py   - - managehKey   & lt ; algolia   manage   key & gt ;   #   同时 进行   Lunr   和   Algolia   处理     加入 发布 流程   最后 我们 还 可以 很 方便 和 发布 流程 集成 ， 比如 下面 的   deploy . sh   脚本 \n # ! / bin / bash   echo   - e   & quot ; \\ 033 [ 0 ; 32mDeploying   updates   to   GitHub ... \\ 033 [ 0m & quot ;   fail ( )   {   echo   & quot ; $ 1 & quot ;   exit   1   }   #   Build   the   project .   hugo   #   if   using   a   theme ,   replace   with   ` hugo   - t   & lt ; YOURTHEME & gt ; `   echo   & quot ; search   key   $ 2 & quot ;   searchKey = & quot ; $ 2 & quot ;   python2   search _ process . py   - k   & quot ; $ { searchKey } & quot ;   | |   fail   & quot ; site   search   data   process   fail .   Error   Code :   [   $ ?   ] & quot ;   #   Go   To   Public   folder   cd   public   #   Add   changes   to   git .   git   add   .   #   Commit   changes .   msg = & quot ; rebuilding   site   ` date ` & quot ;   if   [   $ #   - ge   1   ]   then   msg = & quot ; $ 1 & quot ;   fi   git   commit   - m   & quot ; $ msg & quot ;   #   Push   source   and   build   repos .   git   push   origin   master   #   Come   Back   up   to   the   Project   Root   cd   ..     使用 时 如下 ： \n $ . / deploy . sh   $ . / deploy . sh   & quot ; this   is   message & quot ;   & lt ; algolia   manage   key & gt ;   $ . / deploy . sh   ' '   & lt ; algolia   manage   key & gt ;     参考 ： \n   hugo - lunr - zh  ", "title_s": "Hugo   网站 增加 搜索 功能 ： Lunrjs   和   Algolia"}, {"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。", "objectID": "https://blog.threeq.me/post/articles/noob-learn-sql/1-install-tools/", "tags": ["数据库", "SQL"], "title": "小白学 SQL 第一天：环境搭建", "uri": "https://blog.threeq.me/post/articles/noob-learn-sql/1-install-tools/", "content": "《小白学 SQL》第一天\n本篇文章是《小白学 SQL》系列的开篇，也是学习的第一天。这个系列的文章是之前的学习笔记整理，同时再加入我自己在使用使用的一些使用经验，属于比较初级的知识整理，适合小白用户（初学者和刚入门）。\n数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。\n作为学习的第一天我们将从搭建环境开始，今天实践涉及到的工具有：\n MySQL Docker ConEmuSetup（windows 版本命令行工具，Linux 和 Mac 不需要） Navicat  \n工具选择和说明 可能大家有些奇怪，为什么这里会选用 Docker，这个和我们 SQL 完全没有关系。这里 Docker 确实和我们学习的 SQL 完全没有关系，但就我个人使用来说 ：\n一、docker 作为基础环境，在上面安装 MySQL 服务比我们在自己裸机上装 MySQL 方便得多，并且不易且不怕出错；\n二、目前整个 IT 行业容器化正在如火如荼的进行，这个是未来不可逆转的趋势，Dcoker 正式这个大军里面的主力军；\n三、MySQL 安装跨平台化，使用 Docker 过后你在任何一个系统里面（Windows、Linux、Mac OS）安装 MySQL 操作都是完全一样的\n基于以上三点原因，所以这里我选择了 Docker 作为数据库运行基础环境。\n软件作用：\n   软件 作用说明     Docker 提供跨平台的软件运行基础环境   MySQL 最常用的 RDBMS 之一，作为我们学习 SQL 的数据库服务器   Navicat 一个被广泛使用的数据库客户端，作为我们主要的 SQL 编辑器   ConEmuSetup 一个 Window 命令行终端（Linux、Mac 使用自带的足以）    安装 Windows 安装 ConEmuSetup  到 ConEmuSetup 下载页面 现在对应软件版本 然后一路 “Next” 就好  Docker 安装 Docker 这里我们使用 Community Edition 版本，请到这里下载：下载地址。\n 对于 Windows 版和 Mac 版，下载下来后双击文件运行，剩下的几乎就是一路 &ldquo;Next&rdquo; 点下去就完了，最后双击桌面图标启动 Docker 服务，这里就不在说明了 对于 Linux 版本，由于不同发行版的需求不同，安装步骤略有不同，但是基本也和常用软件安装差不多，并且官方文档也和齐全这里就直接放官方的安装连接地址了（是英文的哟，如果有好的中文教程推荐，请留言我尽快放上来）: Ubuntu CentOS Fedora Debian  加速器配置：Windows、Mac 对于 Docker 安装完成过后，国内用户还有一步需要操作：指定 docker 加速器（原因不多说）。Windows 和 Mac 系统具体操作如下：\n 找到 Docker 运行系统托盘图片，右击打开菜单如下    点击 Preferences 菜单，打开设置界面如下   点击 Daemon 标签项，再 Rgistry mirrors 中输入镜像加速器网址 https://docker.mirrors.ustc.edu.cn。如下图  对于 Linux 系统配置需要修改相关配置文件，不同系统版本有所不同。\n加速器配置：Ubuntu 14.04、Debian 7 Wheezy 对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS中配置加速器地址：\nDOCKER_OPTS=&quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn&quot;  重启 Docker 服务：\n$ sudo service docker restart  加速器配置：Ubuntu 16.04+、Debian 8+、CentOS 7 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n{ &quot;registry-mirrors&quot;: [ &quot;https://docker.mirrors.ustc.edu.cn&quot; ] }   注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。\n 重启 Docker 服务：\n$ sudo systemctl daemon-reload $ sudo systemctl restart docker  检查加速器是否生效 打开终端（命令行工具）输入 docker info 命令，如果从结果中看到了如下内容，说明配置成功。\nRegistry Mirrors: https://docker.mirrors.ustc.edu.cn/  其他可用的加速服务有很多，这里列举几个方便大家查找：\n Docker 官方提供的中国 registry mirror DaoCloud 加速器 阿里云加速器  MySQL 服务安装 在安装完成 Docker 过后，MySQL 服务的安装就很简单了。在你的终端命令行里面输入如下命令启动 MySQL 服务：\n$ docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql  查看 MySQL 服务运行状态\n$ docker ps  这里不要被命令吓着了，Docker 本身的命令不少，包括以后的所有操作，我们总共用到 docker 命令就4、5个。这里先列出来，大家可以操作一下\n$ docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql # 创建一个名为 sql-learn MySQL 容器 $ docker ps # 查看容器运行状态 $ docker stop sql-learn # 停止 sql-learn 容器 $ docker rm sql-learn # 删除 sql-learn 容器，必须先停止  Navicat 安装 安装和 ConEmuSetup 类似\n 到 Navicat 下载页面 现在对应软件版本。推荐 Navicat Premium 然后一路 “Next” 就好  验证环境安装完成  双击桌面 “Navicat” 应用图标，打开 Navicat 软件  ​  点击 “链接” 增加到 sql-learn 的数据库链接。输入截图里面的内容，这里密码输入 toor ，点击 “Test Connection” 出现绿点没有错误表示成功，如下图   双击 “左边导航列表” 里的 sql-learn 得到如下结果   创建一个用于我们以后学习使用的数据库。点击 “New Query” 新建一个查询窗口  输入一下 SQL 语句\ncreate database `sql-learn` default charset=utf8mb4;  点击执行得到如下结果，表示成功\n支持我们的环境安装和验证全部结束。\n总结 我们学习一下几点：\n 如何安装 Docker 服务\n 如何在 Docker 里面启动 MySQL 服务器\n   docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql # 无 sql-learn 容器时 或 docker start sql-learn # 已有 sql-learn 容器时   我们在使用数据库系统的时候需要一个数据库服务器（这里是 MySQL），还需要一个数据库客户端（这里是 Navicat）\n 在链接 MySQL 服务器之前需要先启动 MySQL 服务器\n 在连接一个 MySQL 服务器是需要提供的基本信息有：服务器 IP、服务器端口、用户名、密码\n ", "content_s": "《 小白学   SQL 》 第一 一天 第一天 \n 本篇 文章 是 《 小白学   SQL 》 系列 的 开篇 ， 也 是 学习 的 第一 一天 第一天 。 这个 系列 的 文章 是 之前 的 学习 笔记 整理 ， 同时 再 加入 我 自己 在 使用 使用 的 一些 使用 经验 ， 属于 比较 初级 的 知识 整理 ， 适合 小白 用户 （ 初学 学者 初学者 和 刚 入门 ） 。 \n 数据 据库 数据库 管理 系统 管理系 管理系统 （ DBMS ） 是   IT   从业 业者 从业者 必备 工具 之一 ， 你 能 在 市面 面上 市面上 看到 的 任何 一个 软件 系统 软件系统 ， 在 后面 支持 的 一定 有 它 的 身影 。   而 这 里面 关系 型 数据 据库 数据库 管理 系统 管理系 管理系统 （ RDBMS ）   目前 暂居 了 绝大 大部 部分 大部分 绝大部分 ， 操作   RDBMS   的 基础 就是 今天 我们 要 开始 学习 的   SQL （ 结构 结构化 查询 语言 查询语言 ） ， 所以 我们 有 必要 针对   SQL   进行 系统 全面 的 学习 。 \n 作为 学习 的 第一 一天 第一天 我们 将 从 搭建 环境 开始 ， 今天 实践 涉及 到 的 工具 有 ： \n   MySQL   Docker   ConEmuSetup （ windows   版本 命令 命令行 工具 ， Linux   和   Mac   不 需要 ）   Navicat     \n 工具 选择 和 说明   可能 大家 有些 奇怪 ， 什么 为什么 这里 会 选用   Docker ， 这个 和 我们   SQL   完全 没有 关系 。 这里   Docker   确实 和 我们 学习 的   SQL   完全 没有 关系 ， 但 就 我 个人 使用 来说   ： \n 一 、 docker   作为 基础 环境 ， 在 上面 安装   MySQL   服务 比 我们 在 自己 裸机 上装   MySQL   方便 得 多 ， 并且 不易 且 不怕 出错 ； \n 二 、 目前 整个   IT   行业 容器 化 正在 如火如荼 的 进行 ， 这个 是 未来 不可 可逆 逆转 不可逆转 的 趋势 ， Dcoker   正式 这个 大军 里面 的 主力 主力军 ； \n 三 、 MySQL   安装 平台 跨平台 化 ， 使用   Docker   过后 你 在 任何 一个 系统 里面 （ Windows 、 Linux 、 Mac   OS ） 安装   MySQL   操作 都 是 完全 一样 的 \n 基于 以上 三点 原因 ， 所以 这里 我 选择 了   Docker   作为 数据 据库 数据库 运行 基础 环境 。 \n 软件 作用 ： \n       软件   作用 说明           Docker   提供 平台 跨平台 的 软件 运行 基础 环境       MySQL   最 常用 的   RDBMS   之一 ， 作为 我们 学习   SQL   的 数据 据库 数据库 服务 务器 服务器       Navicat   一个 被 广泛 使用 的 数据 据库 数据库 客户 客户端 ， 作为 我们 主要 的   SQL   编辑 编辑器       ConEmuSetup   一个   Window   命令 命令行 终端 （ Linux 、 Mac   使用 自带 的 足以 ）         安装   Windows   安装   ConEmuSetup     到   ConEmuSetup   下载 页面   现在 对应 软件 版本   然后 一路   “ Next ”   就 好     Docker   安装   Docker   这里 我们 使用   Community   Edition   版本 ， 请 到 这里 下载 ： 下载 地址 。 \n   对于   Windows   版 和   Mac   版 ， 下载 下来 后 双击 文件 运行 ， 剩下 的 几乎 就是 一路   & ldquo ; Next & rdquo ;   点 下去 就 完 了 ， 最后 双击 桌面 图标 桌面图 桌面图标 启动   Docker   服务 ， 这里 就 不 在 说明 了   对于   Linux   版本 ， 由于 不同 发行 发行版 的 需求 不同 ， 安装 步骤 略有 不同 略有不同 ， 但是 基本 也 和 常用 软件 常用软件 安装 不多 差不多 ， 并且 官方 文档 也 和 齐全 这里 就 直接 放 官方 的 安装 连接 地址 了 （ 是 英文 的 哟 ， 如果 有 好 的 中文 教程 推荐 ， 请 留言 我 尽快 放上 上来 放上来 ） :   Ubuntu   CentOS   Fedora   Debian     加速 加速器 配置 ： Windows 、 Mac   对于   Docker   安装 完成 过后 ， 国内 用户 还有 一步 需要 操作 ： 指定   docker   加速 加速器 （ 原因 不多 说 ） 。 Windows   和   Mac   系统 具体 体操 操作 具体操作 如下 ： \n   找到   Docker   运行 系统 托盘 系统托盘 图片 ， 右击 打开 菜单 如下         点击   Preferences   菜单 ， 打开 设置 界面 如下       点击   Daemon   标签 项 ， 再   Rgistry   mirrors   中 输入 镜像 加速 加速器 网址   https : / / docker . mirrors . ustc . edu . cn 。 如下 图     对于   Linux   系统 统配 配置 系统配 系统配置 需要 修改 相关 配置 文件 配置文件 ， 不同 系统 版本 有所 不同 有所不同 。 \n 加速 加速器 配置 ： Ubuntu   14.04 、 Debian   7   Wheezy   对于 使用   upstart   的 系统 而言 ， 编辑   / etc / default / docker   文件 ， 在 其中 的   DOCKER _ OPTS 中 配置 加速 加速器 地址 ： \n DOCKER _ OPTS = & quot ; - - registry - mirror = https : / / docker . mirrors . ustc . edu . cn & quot ;     重启   Docker   服务 ： \n $   sudo   service   docker   restart     加速 加速器 配置 ： Ubuntu   16.04 + 、 Debian   8 + 、 CentOS   7   对于 使用   systemd   的 系统 ， 请 在   / etc / docker / daemon . json   中 写入 如下 内容 （ 如果 文件 不 存在 请 新建 该 文件 ） \n {   & quot ; registry - mirrors & quot ; :   [   & quot ; https : / / docker . mirrors . ustc . edu . cn & quot ;   ]   }       注意 ， 一定 要 保证 该 文件 符合   json   规范 ， 否则   Docker   将 不能 启动 。 \n   重启   Docker   服务 ： \n $   sudo   systemctl   daemon - reload   $   sudo   systemctl   restart   docker     检查 加速 加速器 是否 生效   打开 终端 （ 命令 命令行 工具 ） 输入   docker   info   命令 ， 如果 从 结果 中 看到 了 如下 内容 ， 说明 配置 成功 。 \n Registry   Mirrors :   https : / / docker . mirrors . ustc . edu . cn /     其他 可用 的 加速 服务 有 很多 ， 这里 列举 几个 方便 大家 查找 ： \n   Docker   官方 提供 的 中国   registry   mirror   DaoCloud   加速 加速器   阿里 云 加速 加速器     MySQL   服务 安装   在 安装 完成   Docker   过后 ， MySQL   服务 的 安装 就 很 简单 了 。 在 你 的 终端 命令 命令行 里面 输入 如下 命令 启动   MySQL   服务 ： \n $   docker   run   - - name   sql - learn   - e   MYSQL _ ROOT _ PASSWORD = toor   - p3306 : 3306   - d   mysql     查看   MySQL   服务 运行 状态 \n $   docker   ps     这里 不要 被 命令 吓 着 了 ， Docker   本身 的 命令 不少 ， 包括 以后 的 所有 操作 ， 我们 总共 用到   docker   命令 就 4 、 5 个 。 这里 先列 出来 ， 大家 可以 操作 一下 \n $   docker   run   - - name   sql - learn   - e   MYSQL _ ROOT _ PASSWORD = toor   - p3306 : 3306   - d   mysql   #   创建 一个 名为   sql - learn   MySQL   容器   $   docker   ps   #   查看 容器 运行 状态   $   docker   stop   sql - learn   #   停止   sql - learn   容器   $   docker   rm   sql - learn   #   删除   sql - learn   容器 ， 必须 先 停止     Navicat   安装   安装 和   ConEmuSetup   类似 \n   到   Navicat   下载 页面   现在 对应 软件 版本 。 推荐   Navicat   Premium   然后 一路   “ Next ”   就 好     验证 环境 安装 完成     双击 桌面   “ Navicat ”   应用 图标 ， 打开   Navicat   软件     ​     点击   “ 链接 ”   增加 到   sql - learn   的 数据 据库 数据库 链接 。 输入 截图 里面 的 内容 ， 这里 密码 输入   toor   ， 点击   “ Test   Connection ”   出现 绿点 没有 错误 表示 成功 ， 如下 图       双击   “ 左边 导航 列表 ”   里 的   sql - learn   得到 如下 结果       创建 一个 用于 我们 以后 学习 使用 的 数据 据库 数据库 。 点击   “ New   Query ”   新建 一个 查询 窗口     输入 一下   SQL   语句 \n create   database   ` sql - learn `   default   charset = utf8mb4 ;     点击 执行 得到 如下 结果 ， 表示 成功 \n 支持 我们 的 环境 安装 和 验证 全部 结束 。 \n 总结   我们 学习 一下 几点 ： \n   如何 安装   Docker   服务 \n   如何 在   Docker   里面 启动   MySQL   服务 务器 服务器 \n       docker   run   - - name   sql - learn   - e   MYSQL _ ROOT _ PASSWORD = toor   - p3306 : 3306   - d   mysql   #   无   sql - learn   容器 时   或   docker   start   sql - learn   #   已有   sql - learn   容器 时       我们 在 使用 数据 据库 系统 数据库 数据库系统 的 时候 需要 一个 数据 据库 数据库 服务 务器 服务器 （ 这里 是   MySQL ） ， 还 需要 一个 数据 据库 数据库 客户 客户端 （ 这里 是   Navicat ） \n   在 链接   MySQL   服务 务器 服务器 之前 需要 先 启动   MySQL   服务 务器 服务器 \n   在 连接 一个   MySQL   服务 务器 服务器 是 需要 提供 的 基本 信息 有 ： 服务 务器 服务器   IP 、 服务 务器 服务器 服务器端 口 、 用户 户名 用户名 、 密码 \n  ", "title_s": "小白学   SQL   第一 一天 第一天 ： 环境 搭建"}, {"description": "", "objectID": "https://blog.threeq.me/post/db/mysql-slow-query-analyse/", "tags": ["Mysql", "数据库", "查询优化", "percona", "pt-query-digest"], "title": "mysql 查询优化：慢查询分析工具 pt-query-digest", "uri": "https://blog.threeq.me/post/db/mysql-slow-query-analyse/", "content": "在系统刚上线的时候，经常会出现慢 SQL 的情况，并且有时候系统会在特定的时间点变慢。这个时候的慢 SQL 查询语句往往是大量出现，MySQL 的慢查询日志文件也会比较大。这个时候我们往往需要从哪些查询最多、耗时最长的 sql 开始优化，以提升我们的处理效益。这个时候就需要我们能对慢日志进行统计分析，在上 M ，甚至 几十 M 的日志文件里面使用手工的方式明显是不可能的，这个时候就需要有专门的统计分析工具来帮我们做统计、分析哪些慢查询日志。percona-toolkit 就是一个提供统计和分析的工具集，这里重点介绍里面的 pt-query-digest 工具。\n\npercona-toolkit 安装 percona-toolkit 首页 文档 下载地址\nmac 安装 可以使用 brew 直接安装\nbrew install percona-toolkit  Linux 安装 详细信息参考 官方安装文档\n源码安装 # 下载源码 wget https://www.percona.com/downloads/percona-toolkit/3.0.8/source/tarball/percona-toolkit-3.0.8.tar.gz # 解压 tar xf percona-toolkit-3.0.8.tar.gz #进入目录安装 cd percona-toolkit-3.0.8 #开始编译安装 perl Makefile.PL make make install #安装完了就有命令了 ll /usr/local/bin/pt-*  pt-query-digest 基本使用 在使用 pt-query-digest 前需要有 MySQL 慢查询日志文件，这里为了大家方便实验提供了一份 MySQL 慢查询日实验数据 供大家下载测试（slow-sql-test.sql.zip 点击我下载，里面包含2018.04.01～2018.04.04 和 2018.04.06 的日志数据）。\n 查看使用帮助  &gt; pt-query-digest --help   默认分析参数  &gt; pt-query-digest slow-sql-test.sql   总体概要信息：\n   信息字段 说明     Exec Time 执行时间   Lock Time 锁时间   Row sent 发送行大小   Row examine 检查行大小   Query size 查询大小   Rank SQL 编号   Query ID 查询 id   Response time sql 总共执行时间 和 时间比例   Calls sql 执行次数   R/Call sql 平均每次执行时间   V/M    Item sql 类型和涉及到的表    单个 SQL 信息：\n ​ 分析结果说明：\n 分析最近一段时间内的慢查询  &gt; pt-query-digest --since=12h slow-sql-test.sql # 最近 12 小时的慢查询   分析指定时间段内的慢查询  &gt; pt-query-digest slow-sql-test.sql --since '2018-04-01 09:30:00' --until '2018-04-02 10:00:00'   分析还有指定特征的慢查询 SQL  &gt; pt-query-digest --filter '$event-&gt;{fingerprint} =~ m/^select/i' slow-sql-test.sql   分析针对某个用户的慢查询  &gt; pt-query-digest --filter '($event-&gt;{member} || &quot;&quot;) =~ m/^root/i' slow-sql-test.sql   ​  pt-query-digest进阶使用 有时候我们会遇到针对慢 SQL 进行长期的跟踪分析，这个时候我们就需要将我们的每次的分析结果进行汇总、对比分析。同时对于部分环境我们是不能直接得到慢 SQL 日志的，这个时候我们可以通过抓取 TCP 协议数据或 binlog 进行分析\n 将分析结果保存到数据库  &gt; pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_review--create-review-table slow-sql-test.sql   通过抓取 TCP 协议数据分析  &gt; tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &gt; mysql.tcp.txt &gt; pt-query-digest --type tcpdump mysql.tcp.txt&gt; slow_report9.log   通过 binlog 日志分析  &gt; mysqlbinlog mysql-bin.000093 &gt; mysql-bin000093.sql &gt; pt-query-digest --type=binlog mysql-bin000093.sql &gt; slow_report10.log  单条 SQL 优化基本分析 通过上面的方法就可以找出系统里面所有的慢 SQL 语句了，并且在分析报告里面会排好序，剩下的就是我们针对每条 SQL 语句的分析调优工作了。针对 SQL 的具体优化方式内容很多，建议大家系统的学习，后面我也会写一些我常用的方法。这里说一下单条 SQL 的基础分析方法，好让大家有个开头。\n 查看 SQL 执行计划  EXPLAIN select ep_name as '企业名称', count(*) as '企业人数', FROM_UNIXTIME(ep_created/1000, GET_FORMAT(DATE,'ISO')) as '注册时间' from uc_member u left join uc_enterprise e on u.ep_id=e.ep_id where ep_domain='yq.vchangyi.com' and mem_status&lt;3 group by u.ep_id order by 企业人数 desc;\t 对于上面每一列的的意义这里不再详细介绍，有兴趣的同学可以查看 MySQL 文档，或者关注我后续的文章，会有专门介绍。\n 查询 SQL 执行信息  查看 MySQL 语句执行信息需要首先开启 profiling 选线\nset profiling = 1;  然后执行完 SQL 过后使用 show profiles; 语句查看执行 SQL 的记录id\nselect ep_name as '企业名称', count(*) as '企业人数', FROM_UNIXTIME(ep_created/1000, GET_FORMAT(DATE,'ISO')) as '注册时间' from uc_member u left join uc_enterprise e on u.ep_id=e.ep_id where ep_domain='yq.vchangyi.com' and mem_status&lt;3 group by u.ep_id order by 企业人数 desc; show profiles;  使用 show profile 查看 SQL 的执行信息\nshow profile ALL for query 3;  语法格式：\nshow profile [type] for query &lt;query_id&gt;;  如果没有指定 FOR QUERY 则显示最近一条查询的详细信息。type 是可选的，有以下几个选项：\n ALL 显示所有性能信息 BLOCK IO 显示块IO操作的次数 CONTEXT SWITCHES 显示上下文切换次数，不管是主动还是被动 CPU 显示用户CPU时间、系统CPU时间 IPC 显示发送和接收的消息数量 MEMORY [暂未实现] PAGE FAULTS 显示页错误数量 SOURCE 显示源码中的函数名称与位置 SWAPS 显示SWAP的次数 ", "content_s": "在 系统 刚 上线 的 时候 ， 经常 会 出现 慢   SQL   的 情况 ， 并且 有时 时候 有时候 系统 会 在 特定 的 时间 点 变慢 。 这个 时候 的 慢   SQL   查询 语句 往往 是 大量 出现 ， MySQL   的 慢 查询 日志 文件 也 会 比较 大 。 这个 时候 我们 往往 需要 从 哪些 查询 最 多 、 耗时 最长 的   sql   开始 优化 ， 以 提升 我们 的 处理 效益 。 这个 时候 就 需要 我们 能 对 慢 日志 进行 统计 计分 分析 统计分析 ， 在 上   M   ， 甚至   几十   M   的 日志 文件 里面 使用 手工 的 方式 明显 是 不 可能 的 ， 这个 时候 就 需要 有 专门 的 统计 计分 分析 统计分析 工具 来 帮 我们 做 统计 、 分析 哪些 慢 查询 日志 。 percona - toolkit   就是 一个 提供 统计 和 分析 的 工具 工具集 ， 这里 重点 介绍 里面 的   pt - query - digest   工具 。 \n \n percona - toolkit   安装   percona - toolkit   首页   文档   下载 地址 \n mac   安装   可以 使用   brew   直接 安装 \n brew   install   percona - toolkit     Linux   安装   详细 信息 详细信息 参考   官方 安装 文档 \n 源码 安装   #   下载 源码   wget   https : / / www . percona . com / downloads / percona - toolkit / 3.0 . 8 / source / tarball / percona - toolkit - 3.0 . 8 . tar . gz   #   解压   tar   xf   percona - toolkit - 3.0 . 8 . tar . gz   # 进入 目录 安装   cd   percona - toolkit - 3.0 . 8   # 开始 编译 安装   perl   Makefile . PL   make   make   install   # 安装 完 了 就 有 命令 了   ll   / usr / local / bin / pt - *     pt - query - digest   基本 使用   在 使用   pt - query - digest   前 需要 有   MySQL   慢 查询 日志 文件 ， 这里 为了 大家 方便 实验 提供 了 一份   MySQL   慢 查询 日 实验 数据   供 大家 下载 测试 （ slow - sql - test . sql . zip   点击 我 下载 ， 里面 包含 2018.04 . 01 ～ 2018.04 . 04   和   2018.04 . 06   的 日志 数据 ） 。 \n   查看 使用 帮助     & gt ;   pt - query - digest   - - help       默认 分析 参数     & gt ;   pt - query - digest   slow - sql - test . sql       总体 概要 信息 ： \n       信息 字 段   说明           Exec   Time   执行 时间       Lock   Time   锁 时间       Row   sent   发送 行 大小       Row   examine   检查 行 大小       Query   size   查询 大小       Rank   SQL   编号       Query   ID   查询   id       Response   time   sql   总共 执行 时间   和   时间 比例       Calls   sql   执行 次数       R / Call   sql   平均 每次 执行 时间       V / M         Item   sql   类型 和 涉及 到 的 表         单个   SQL   信息 ： \n   ​   分析 结果 说明 ： \n   分析 最近 一段 时间 段时间 一段时间 内 的 慢 查询     & gt ;   pt - query - digest   - - since = 12h   slow - sql - test . sql   #   最近   12   小时 的 慢 查询       分析 指定 时间 时间段 内 的 慢 查询     & gt ;   pt - query - digest   slow - sql - test . sql   - - since   ' 2018 - 04 - 01   09 : 30 : 00 '   - - until   ' 2018 - 04 - 02   10 : 00 : 00 '       分析 还有 指定 特征 的 慢 查询   SQL     & gt ;   pt - query - digest   - - filter   ' $ event - & gt ; { fingerprint }   = ~   m / ^ select / i '   slow - sql - test . sql       分析 针对 某个 用户 的 慢 查询     & gt ;   pt - query - digest   - - filter   ' ( $ event - & gt ; { member }   | |   & quot ; & quot ; )   = ~   m / ^ root / i '   slow - sql - test . sql       ​     pt - query - digest 进阶 使用   有时 时候 有时候 我们 会 遇到 针对 慢   SQL   进行 长期 的 跟踪 分析 ， 这个 时候 我们 就 需要 将 我们 的 每次 的 分析 结果 进行 汇总 、 对比 分析 。 同时 对于 部分 环境 我们 是 不能 直接 得到 慢   SQL   日志 的 ， 这个 时候 我们 可以 通过 抓取   TCP   协议 数据 或   binlog   进行 分析 \n   将 分析 结果 保存 到 数据 据库 数据库     & gt ;   pt - query - digest   - - user = root   – password = abc123   - - review   h = localhost , D = test , t = query _ review - - create - review - table   slow - sql - test . sql       通过 抓取   TCP   协议 数据 分析 数据分析     & gt ;   tcpdump   - s   65535   - x   - nn   - q   - tttt   - i   any   - c   1000   port   3306   & gt ;   mysql . tcp . txt   & gt ;   pt - query - digest   - - type   tcpdump   mysql . tcp . txt & gt ;   slow _ report9 . log       通过   binlog   日志 分析     & gt ;   mysqlbinlog   mysql - bin.000093   & gt ;   mysql - bin000093 . sql   & gt ;   pt - query - digest   - - type = binlog   mysql - bin000093 . sql   & gt ;   slow _ report10 . log     单条   SQL   优化 基本 分析   通过 上面 的 方法 就 可以 找出 系统 里面 所有 的 慢   SQL   语句 了 ， 并且 在 分析 报告 里面 会排 好序 ， 剩下 的 就是 我们 针对 每条   SQL   语句 的 分析 调优 工作 了 。 针对   SQL   的 具体 优化 方式 内容 很多 ， 建议 大家 系统 的 学习 ， 后面 我 也 会 写 一些 我 常用 的 方法 。 这里 说 一下 单条   SQL   的 基础 分析 方法 分析方法 ， 好 让 大家 有个 开头 。 \n   查看   SQL   执行 计划     EXPLAIN   select   ep _ name   as   ' 企业 名称 ' ,   count ( * )   as   ' 企业 人数 ' ,   FROM _ UNIXTIME ( ep _ created / 1000 ,   GET _ FORMAT ( DATE , ' ISO ' ) )   as   ' 注册 时间 '   from   uc _ member   u   left   join   uc _ enterprise   e   on   u . ep _ id = e . ep _ id   where   ep _ domain = ' yq . vchangyi . com '   and   mem _ status & lt ; 3   group   by   u . ep _ id   order   by   企业 人数   desc ; \t   对于 上面 每 一列 的 的 意义 这里 不再 详细 介绍 ， 有 兴趣 的 同学 可以 查看   MySQL   文档 ， 或者 关注 我 后续 的 文章 ， 会 有 专门 介绍 。 \n   查询   SQL   执行 信息     查看   MySQL   语句 执行 信息 需要 首先 开启   profiling   选线 \n set   profiling   =   1 ;     然后 执行 完   SQL   过后 使用   show   profiles ;   语句 查看 执行   SQL   的 记录 id \n select   ep _ name   as   ' 企业 名称 ' ,   count ( * )   as   ' 企业 人数 ' ,   FROM _ UNIXTIME ( ep _ created / 1000 ,   GET _ FORMAT ( DATE , ' ISO ' ) )   as   ' 注册 时间 '   from   uc _ member   u   left   join   uc _ enterprise   e   on   u . ep _ id = e . ep _ id   where   ep _ domain = ' yq . vchangyi . com '   and   mem _ status & lt ; 3   group   by   u . ep _ id   order   by   企业 人数   desc ;   show   profiles ;     使用   show   profile   查看   SQL   的 执行 信息 \n show   profile   ALL   for   query   3 ;     语法 格式 ： \n show   profile   [ type ]   for   query   & lt ; query _ id & gt ; ;     如果 没有 指定   FOR   QUERY   则 显示 最近 一条 查询 的 详细 信息 详细信息 。 type   是 可选 的 ， 有 以下 几个 选项 ： \n   ALL   显示 所有 性能 信息   BLOCK   IO   显示 块 IO 操作 的 次数   CONTEXT   SWITCHES   显示 上下 下文 上下文 切换 次数 ， 不管 是 主动 还是 被动   CPU   显示 用户 CPU 时间 、 系统 CPU 时间   IPC   显示 发送 和 接收 的 消息 数量   MEMORY   [ 暂未 实现 ]   PAGE   FAULTS   显示 页 错误 数量   SOURCE   显示 源码 中 的 函数 名称 与 位置   SWAPS   显示 SWAP 的 次数  ", "title_s": "mysql   查询 优化 ： 慢 查询 分析 工具   pt - query - digest"}, {"description": "", "objectID": "https://blog.threeq.me/post/db/mysql-sql-index-analyse-tool/", "tags": ["Mysql", "数据库", "查询优化"], "title": "mysql 查询优化：索引优化", "uri": "https://blog.threeq.me/post/db/mysql-sql-index-analyse-tool/", "content": "我们在产品中使用 MySQL 数据库的时候，肯定会用到索引的，或是在前期建立一些初始索引，或是在后期 SQL 优化的时候根据系统运行状态逐渐增加索引。不论是以什么方式建立的索引，他们都会影响我们对数据库做的操作，并且是对我们所有的数据操作都有影响，包括 增加、删除、修改、查询、统计 操作。这时如果线上有部分索引在系统升级已经失效了，我们怎么知道，怎么及时的排查和删除，需要我们持续的跟踪和分析。今天我就介绍几款针对线上数据库索引的分析工具。\n pt-index-usage userstat check-unused-keys  \n1. pt-index-usage pt-index-usage 从日志里面读取查询，并且分析它们是如何使用索引的。它需要 MySQL 的慢查询日志，在实际分析中我们可以讲 MySQL 的慢查询参数设置为 0 ，这样就可以得到所有的执行 SQL。\npt-index-uage 的安装请参考 [mysql 查询优化：慢查询分析工具 pt-query-digest]\n使用：\n&gt; pt-index-usage [OPTIONS] [FILES]  分析 slow.log 的所有查询语句，并打印报告\n&gt; pt-index-usage /path/to/slow.log --host localhost  不打印报告，同时把分析后的结果存入 percona 数据库\n&gt; pt-index-usage slow.log --no-report --save-results-database percona  详情参考 pt-index-uage 官方文档 和 使用手册 [pt-index-uage --help]\n2. userstat MySQL 设置：\nmysql&gt; SET GLOBAL userstat=ON; mysql&gt; SET GLOBAL `thread_statistics`=1; mysql&gt; SHOW GLOBAL VARIABLES LIKE &quot;userstat&quot;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | userstat | ON | +---------------+-------+ 1 row in set (0.00 sec)  查询客户端连接信息\nmysql&gt; SELECT * FROM INFORMATION_SCHEMA.CLIENT_STATISTICS\\G *************************** 1. row *************************** CLIENT: 10.1.12.30 TOTAL_CONNECTIONS: 20 CONCURRENT_CONNECTIONS: 0 CONNECTED_TIME: 0 BUSY_TIME: 93 CPU_TIME: 48 BYTES_RECEIVED: 5031 BYTES_SENT: 276926 BINLOG_BYTES_WRITTEN: 217 ROWS_FETCHED: 81 ROWS_UPDATED: 0 TABLE_ROWS_READ: 52836023 SELECT_COMMANDS: 26 UPDATE_COMMANDS: 1 OTHER_COMMANDS: 145 COMMIT_TRANSACTIONS: 1 ROLLBACK_TRANSACTIONS: 0 DENIED_CONNECTIONS: 0 LOST_CONNECTIONS: 0 ACCESS_DENIED: 0 EMPTY_QUERIES: 0 TOTAL_SSL_CONNECTIONS: 0  查询索引使用信息：\nmysql&gt; SELECT * FROM INFORMATION_SCHEMA.INDEX_STATISTICS WHERE TABLE_NAME='tables_priv'; +--------------+-----------------------+--------------------+-----------+ | TABLE_SCHEMA | TABLE_NAME | INDEX_NAME | ROWS_READ | +--------------+-----------------------+--------------------+-----------+ | mysql | tables_priv | PRIMARY | 2 | +--------------+-----------------------+--------------------+-----------+  查询表的使用信息：\nmysql&gt; SELECT * FROM INFORMATION_SCHEMA.TABLE_STATISTICS WHERE TABLE_NAME=``tables_priv``; +--------------+-------------------------------+-----------+--------------+------------------------+ | TABLE_SCHEMA | TABLE_NAME | ROWS_READ | ROWS_CHANGED | ROWS_CHANGED_X_INDEXES | +--------------+-------------------------------+-----------+--------------+------------------------+ | mysql | tables_priv | 2 | 0 | 0 | +--------------+-------------------------------+-----------+--------------+------------------------+  具体详情请参考文档：https://www.percona.com/doc/percona-server/5.7/diagnostics/user_stats.html\n3. check-unused-keys check-unused-keys 是 Ryan Lowe 编写的基于 userstat 的一个 perl 脚本。能够比较方便输出需要删除的索引。\n下载地址：https://code.google.com/archive/p/check-unused-keys/downloads / 备份地址\nMySQL 设置：\nmysql&gt; SET GLOBAL userstat=ON; mysql&gt; SET GLOBAL `thread_statistics`=1; mysql&gt; SHOW GLOBAL VARIABLES LIKE &quot;userstat&quot;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | userstat | ON | +---------------+-------+ 1 row in set (0.00 sec)  语法：\n&gt; ./check-unused-keys --help  使用：\n./check-unused-keys --host=127.0.0.1 --username=root --password=toor --port=3306 --create-alter  参考：\nhttps://www.percona.com/blog/2009/06/26/check-unused-keys-a-tool-to-interact-with-index_statistics/\nhttps://www.percona.com/blog/2008/09/12/googles-user_statistics-v2-port-and-changes/\nhttps://code.google.com/archive/p/check-unused-keys/\nhttps://www.percona.com/blog/2012/12/05/quickly-finding-unused-indexes-and-estimating-their-size/\nhttps://yq.aliyun.com/articles/308518\n", "content_s": "我们 在 产品 中 使用   MySQL   数据 据库 数据库 的 时候 ， 肯定 会 用到 索引 的 ， 或是 在 前期 建立 一些 初始 索引 ， 或是 在 后期   SQL   优化 的 时候 根据 系统 运行 状态 逐渐 增加 索引 。 不论 不论是 以 什么 方式 建立 的 索引 ， 他们 都 会 影响 我们 对 数据 据库 数据库 做 的 操作 ， 并且 是 对 我们 所有 的 数据 操作 都 有 影响 ， 包括   增加 、 删除 、 修改 、 查询 、 统计   操作 。 这时 如果 线上 有 部分 索引 在 系统 升级 系统升级 已经 失效 了 ， 我们 怎么 知道 ， 怎么 及时 的 排查 和 删除 ， 需要 我们 持续 的 跟踪 和 分析 。 今天 我 就 介绍 几款 针对 线上 数据 据库 数据库 索引 的 分析 工具 。 \n   pt - index - usage   userstat   check - unused - keys     \n 1 .   pt - index - usage   pt - index - usage   从 日志 里面 读取 查询 ， 并且 分析 它们 是 如何 使用 索引 的 。 它 需要   MySQL   的 慢 查询 日志 ， 在 实际 分析 中 我们 可以 讲   MySQL   的 慢 查询 参数 设置 参数设置 为   0   ， 这样 就 可以 得到 所有 的 执行   SQL 。 \n pt - index - uage   的 安装 请 参考   [ mysql   查询 优化 ： 慢 查询 分析 工具   pt - query - digest ] \n 使用 ： \n & gt ;   pt - index - usage   [ OPTIONS ]   [ FILES ]     分析   slow . log   的 所有 查询 语句 ， 打印 并打印 报告 \n & gt ;   pt - index - usage   / path / to / slow . log   - - host   localhost     不 打印 报告 ， 同时 把 分析 后 的 结果 存入   percona   数据 据库 数据库 \n & gt ;   pt - index - usage   slow . log   - - no - report   - - save - results - database   percona     详情 参考   pt - index - uage   官方 文档   和   使用 手册 使用手册   [ pt - index - uage   - - help ] \n 2 .   userstat   MySQL   设置 ： \n mysql & gt ;   SET   GLOBAL   userstat = ON ;   mysql & gt ;   SET   GLOBAL   ` thread _ statistics ` = 1 ;   mysql & gt ;   SHOW   GLOBAL   VARIABLES   LIKE   & quot ; userstat & quot ; ;   + - - - - - - - - - - - - - - - + - - - - - - - +   |   Variable _ name   |   Value   |   + - - - - - - - - - - - - - - - + - - - - - - - +   |   userstat   |   ON   |   + - - - - - - - - - - - - - - - + - - - - - - - +   1   row   in   set   ( 0.00   sec )     查询 客户 客户端 连接 信息 \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . CLIENT _ STATISTICS \\ G   * * * * * * * * * * * * * * * * * * * * * * * * * * *   1 .   row   * * * * * * * * * * * * * * * * * * * * * * * * * * *   CLIENT :   10.1 . 12.30   TOTAL _ CONNECTIONS :   20   CONCURRENT _ CONNECTIONS :   0   CONNECTED _ TIME :   0   BUSY _ TIME :   93   CPU _ TIME :   48   BYTES _ RECEIVED :   5031   BYTES _ SENT :   276926   BINLOG _ BYTES _ WRITTEN :   217   ROWS _ FETCHED :   81   ROWS _ UPDATED :   0   TABLE _ ROWS _ READ :   52836023   SELECT _ COMMANDS :   26   UPDATE _ COMMANDS :   1   OTHER _ COMMANDS :   145   COMMIT _ TRANSACTIONS :   1   ROLLBACK _ TRANSACTIONS :   0   DENIED _ CONNECTIONS :   0   LOST _ CONNECTIONS :   0   ACCESS _ DENIED :   0   EMPTY _ QUERIES :   0   TOTAL _ SSL _ CONNECTIONS :   0     查询 索引 使用 信息 ： \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . INDEX _ STATISTICS   WHERE   TABLE _ NAME = ' tables _ priv ' ;   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +   |   TABLE _ SCHEMA   |   TABLE _ NAME   |   INDEX _ NAME   |   ROWS _ READ   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +   |   mysql   |   tables _ priv   |   PRIMARY   |   2   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +     查询 表 的 使用 信息 ： \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . TABLE _ STATISTICS   WHERE   TABLE _ NAME = ` ` tables _ priv ` ` ;   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +   |   TABLE _ SCHEMA   |   TABLE _ NAME   |   ROWS _ READ   |   ROWS _ CHANGED   |   ROWS _ CHANGED _ X _ INDEXES   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +   |   mysql   |   tables _ priv   |   2   |   0   |   0   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +     具体 详情 详情请 参考 文档 ： https : / / www . percona . com / doc / percona - server / 5.7 / diagnostics / user _ stats . html \n 3 .   check - unused - keys   check - unused - keys   是   Ryan   Lowe   编写 的 基于   userstat   的 一个   perl   脚本 。 能够 比较 方便 输出 需要 删除 的 索引 。 \n 下载 地址 ： https : / / code . google . com / archive / p / check - unused - keys / downloads   /   备份 地址 \n MySQL   设置 ： \n mysql & gt ;   SET   GLOBAL   userstat = ON ;   mysql & gt ;   SET   GLOBAL   ` thread _ statistics ` = 1 ;   mysql & gt ;   SHOW   GLOBAL   VARIABLES   LIKE   & quot ; userstat & quot ; ;   + - - - - - - - - - - - - - - - + - - - - - - - +   |   Variable _ name   |   Value   |   + - - - - - - - - - - - - - - - + - - - - - - - +   |   userstat   |   ON   |   + - - - - - - - - - - - - - - - + - - - - - - - +   1   row   in   set   ( 0.00   sec )     语法 ： \n & gt ;   . / check - unused - keys   - - help     使用 ： \n . / check - unused - keys   - - host = 127.0 . 0.1   - - username = root   - - password = toor   - - port = 3306   - - create - alter     参考 ： \n https : / / www . percona . com / blog / 2009 / 06 / 26 / check - unused - keys - a - tool - to - interact - with - index _ statistics / \n https : / / www . percona . com / blog / 2008 / 09 / 12 / googles - user _ statistics - v2 - port - and - changes / \n https : / / code . google . com / archive / p / check - unused - keys / \n https : / / www . percona . com / blog / 2012 / 12 / 05 / quickly - finding - unused - indexes - and - estimating - their - size / \n https : / / yq . aliyun . com / articles / 308518 \n", "title_s": "mysql   查询 优化 ： 索引 优化"}, {"description": "", "objectID": "https://blog.threeq.me/post/git-branch-flow/", "tags": ["git"], "title": "Git 代码库分之管理", "uri": "https://blog.threeq.me/post/git-branch-flow/", "content": "代码版本库使用git管理，以下是git版本使用规范\n流程图说明 \n分支使用说明    分支名称 名字 说明 实例     master 线上分支 不用于开发，使用tag功能标记版本。只能由beta和hotfix合并，合并同时打上发布版本tag v1.0.2   beta 灰度分支组 灰度分之只能由test合并master产生，在测试通过后进入灰度阶段产生；灰度通过后合并进入master beta/sign   test(release) 测试分支组 只能用于测试和修改bug，只能由由master合并进feature产生。对于测试通过的test，使用merge合并方式合并master产生beta分之；合并后的release需要删除 test/sign; release/active   feature 功能分支组 从最新master检出用于开发一个新功能，一旦完成开发，合并master进入下一个test，删除本次feature分支；负责开发中多开发者代码同步使用 feature/news; feature/vote   topic 本地开发分支组 开发人员基于feature/release/hotfix检出自己本地开发(或修改bug)分支，在开发(或修改bug)中使用rebase合并方式和feature/release/hotfix进行同步。原则上一个feature/release/hotfix分支对应一个topic分支，开发完成的feature/release/hotfix删除对应的topic分支 topic/feature-news-wlp; topic/release-new-wlp; topic/hotfix-news-wlp   hotfix 修补分支组 对于线上紧急bug修改，产生一个hotfix分支，只能由master上的tag标签签出。修改完成的hotfix合并回master，并且必须删除 hotfix/v1.0.2     注意： 1. 个人开发分支除特殊情况，不允许提交到远程服务器中。\n 代码提交/合并说明 这个是开发人在日常开发中使用最多的操作。\n获取代码库 $ git clone &lt;版本库地址&gt; $ cd &lt;代码目录&gt; $ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt;  建立自己的本地开发分支 $ git checkout feature/&lt;功能分支&gt; $ git checkout -b topic/&lt;功能分支&gt;-&lt;你的标识&gt;  提交修改 $ git status $ git add . $ git commit -am '修改描述'  发布你的修改 $ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt; $ git rebase feature/&lt;功能分支&gt; # 这里可能会产生合并操作 $ git push origin topic/&lt;功能分支&gt;-&lt;你的标识&gt;:feature/&lt;功能分支&gt;  代码发布说明 发布代码是针对功能发布而定的，发布又分为测试发布和上线发布。对于发布操作，必须是先到测试环境(test)，再从测试环境(test)到灰度环境(beta)，最后从灰度环境(beta)到生产环境(master)，对于线上每次发布都必须有标签记录，可以回退。 原则上从beta到master只会产生 fast-forward 类型操作。以下所有操作都在自己的开发分支中完成。\n发布到测试环境 # 合并feature分支 $ git fetch origin master:master $ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt; $ git checkout feature/&lt;功能分支&gt; $ git merge master ~~解决冲突~~ # 生产test分支 $ git checkout -b test/&lt;功能分支&gt; $ git push origin test/&lt;功能分支&gt;: test/&lt;功能分支&gt; # 清理feature分支 $ git push origin :feature/&lt;功能分支&gt; $ git branch -D feature/&lt;功能分支&gt;  发布到灰度环境 # 合并master到测试 $ git fetch origin test/&lt;功能分支&gt;:test/&lt;功能分支&gt; $ git fetch origin master:master $ git checkout test/&lt;功能分支&gt; $ git merge master ~~解决冲突~~ # 生成beta分支 $ git checkout -b beta/&lt;功能分支&gt; $ git push origin beta/&lt;功能分支&gt;:beta/&lt;功能名称&gt; # 清理 test $ git push origin :test/&lt;版本&gt; $ git branch -D test/&lt;版本&gt;  发布到生产环境 # 合并到master $ git fetch origin beta/&lt;版本&gt;:beta/&lt;版本&gt; $ git fetch origin master:master $ git checkout master $ git merge beta/&lt;版本&gt; $ git tag -a &lt;发布版本号&gt; -m &quot;发布功能描述&quot; $ git push origin --tags $ git push origin master:master # 清理 beta $ git push origin :beta/&lt;版本&gt; $ git branch -D beta/&lt;版本&gt;  修改生产环境bug # 创建补丁版本，进行修改 $ git fetch origin --tag $ git checkout -b hotfix/&lt;版本号&gt; &lt;版本号&gt; # 修改完成发布 # 1. 合并到master $ git fetch origin master:master $ git checkout master $ git merge hotfix/&lt;版本号&gt; $ git tag -a &lt;发布版本号&gt; -m &quot;发布功能描述&quot; $ git push origin --tag $ git push origin master:master # 清理 hotfix $ git push origin :hotfix/&lt;版本号&gt; $ git branch -D hotfix/&lt;版本号&gt; ", "content_s": "代码 版本 库 使用 git 管理 ， 以下 是 git 版本 使用 规范 \n 流程 流程图 说明   \n 分支 使用 说明         分支 名称   名字   说明   实例           master   线上 分支   不 用于 开发 ， 使用 tag 功能 标记 版本 。 只能 由 beta 和 hotfix 合并 ， 合并 同时 打 上 发布 版本 tag   v1.0 . 2       beta   灰度 分支 组   灰度 分 之 只能 由 test 合并 master 产生 ， 在 测试 通过 测试通过 后 进入 灰度 阶段 产生 ； 灰度 通过 后 合并 进入 master   beta / sign       test ( release )   测试 分支 组   只能 用于 测试 和 修改 bug ， 只能 由 由 master 合并 进 feature 产生 。 对于 测试 通过 测试通过 的 test ， 使用 merge 合并 方式 合并 master 产生 beta 分 之 ； 合并 后 的 release 需要 删除   test / sign ;   release / active       feature   功能 分支 组   从 最新 master 检出 用于 开发 一个 新 功能 ， 一旦 完成 开发 ， 合并 master 进入 下 一个 test ， 删除 本次 feature 分支 ； 负责 开发 中多 开发 开发者 代码 同步 使用   feature / news ;   feature / vote       topic   本地 开发 分支 组   开发 发人 人员 开发人员 基于 feature / release / hotfix 检出 自己 本地 开发 ( 或 修改 bug ) 分支 ， 在 开发 ( 或 修改 bug ) 中 使用 rebase 合并 方式 和 feature / release / hotfix 进行 同步 。 原则 原则上 一个 feature / release / hotfix 分支 对应 一个 topic 分支 ， 开发 完成 的 feature / release / hotfix 删除 对应 的 topic 分支   topic / feature - news - wlp ;   topic / release - new - wlp ;   topic / hotfix - news - wlp       hotfix   修补 分支 组   对于 线上 紧急 bug 修改 ， 产生 一个 hotfix 分支 ， 只能 由 master 上 的 tag 标签 签出 。 修改 完成 的 hotfix 合并 回 master ， 并且 必须 删除   hotfix / v1.0 . 2           注意 ：   1 .   个人 开发 分支 除 特殊 情况 ， 不 允许 提交 到 远程 服务 务器 服务器 中 。 \n   代码 提交 / 合并 说明   这个 是 开发 人 在 日常 开发 中 使用 最多 的 操作 。 \n 获取 代码 库   $   git   clone   & lt ; 版本 库 地址 & gt ;   $   cd   & lt ; 代码 目录 & gt ;   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;     建立 自己 的 本地 开发 分支   $   git   checkout   feature / & lt ; 功能 分支 & gt ;   $   git   checkout   - b   topic / & lt ; 功能 分支 & gt ; - & lt ; 你 的 标识 & gt ;     提交 修改   $   git   status   $   git   add   .   $   git   commit   - am   ' 修改 描述 '     发布 你 的 修改   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;   $   git   rebase   feature / & lt ; 功能 分支 & gt ;   #   这里 可能 会 产生 合并 操作   $   git   push   origin   topic / & lt ; 功能 分支 & gt ; - & lt ; 你 的 标识 & gt ; : feature / & lt ; 功能 分支 & gt ;     代码 发布 说明   发布 代码 是 针对 功能 发布 而定 的 ， 发布 又 分为 测试 发布 和 上线 发布 。 对于 发布 操作 ， 必须 是 先到 测试 环境 测试环境 ( test ) ， 再 从 测试 环境 测试环境 ( test ) 到 灰度 环境 ( beta ) ， 最后 从 灰度 环境 ( beta ) 到 生产 环境 ( master ) ， 对于 线上 每次 发布 都 必须 有 标签 记录 ， 可以 回退 。   原则 原则上 从 beta 到 master 只会 产生   fast - forward   类型 操作 。 以下 所有 操作 都 在 自己 的 开发 分支 中 完成 。 \n 发布 到 测试 环境 测试环境   #   合并 feature 分支   $   git   fetch   origin   master : master   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;   $   git   checkout   feature / & lt ; 功能 分支 & gt ;   $   git   merge   master   ~ ~ 解决 冲突 ~ ~   #   生产 test 分支   $   git   checkout   - b   test / & lt ; 功能 分支 & gt ;   $   git   push   origin   test / & lt ; 功能 分支 & gt ; :   test / & lt ; 功能 分支 & gt ;   #   清理 feature 分支   $   git   push   origin   : feature / & lt ; 功能 分支 & gt ;   $   git   branch   - D   feature / & lt ; 功能 分支 & gt ;     发布 到 灰度 环境   #   合并 master 到 测试   $   git   fetch   origin   test / & lt ; 功能 分支 & gt ; : test / & lt ; 功能 分支 & gt ;   $   git   fetch   origin   master : master   $   git   checkout   test / & lt ; 功能 分支 & gt ;   $   git   merge   master   ~ ~ 解决 冲突 ~ ~   #   生成 beta 分支   $   git   checkout   - b   beta / & lt ; 功能 分支 & gt ;   $   git   push   origin   beta / & lt ; 功能 分支 & gt ; : beta / & lt ; 功能 名称 & gt ;   #   清理   test   $   git   push   origin   : test / & lt ; 版本 & gt ;   $   git   branch   - D   test / & lt ; 版本 & gt ;     发布 到 生产 环境   #   合并 到 master   $   git   fetch   origin   beta / & lt ; 版本 & gt ; : beta / & lt ; 版本 & gt ;   $   git   fetch   origin   master : master   $   git   checkout   master   $   git   merge   beta / & lt ; 版本 & gt ;   $   git   tag   - a   & lt ; 发布 版本 版本号 & gt ;   - m   & quot ; 发布 功能 描述 & quot ;   $   git   push   origin   - - tags   $   git   push   origin   master : master   #   清理   beta   $   git   push   origin   : beta / & lt ; 版本 & gt ;   $   git   branch   - D   beta / & lt ; 版本 & gt ;     修改 生产 环境 bug   #   创建 补丁 版本 ， 进行 修改   $   git   fetch   origin   - - tag   $   git   checkout   - b   hotfix / & lt ; 版本 版本号 & gt ;   & lt ; 版本 版本号 & gt ;   #   修改 完成 发布   #   1 .   合并 到 master   $   git   fetch   origin   master : master   $   git   checkout   master   $   git   merge   hotfix / & lt ; 版本 版本号 & gt ;   $   git   tag   - a   & lt ; 发布 版本 版本号 & gt ;   - m   & quot ; 发布 功能 描述 & quot ;   $   git   push   origin   - - tag   $   git   push   origin   master : master   #   清理   hotfix   $   git   push   origin   : hotfix / & lt ; 版本 版本号 & gt ;   $   git   branch   - D   hotfix / & lt ; 版本 版本号 & gt ;  ", "title_s": "Git   代码 库分 之 管理"}, {"description": "", "objectID": "https://blog.threeq.me/post/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/gtd-flow/", "tags": ["GTD", "时间管理"], "title": "让网络更好为我们服务", "uri": "https://blog.threeq.me/post/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/gtd-flow/", "content": "你每天早上一醒来有没有立即想拿起手机赶紧看一下（facebook、twitter、微信），无论里面有没有信息都要打开一下才安心？并且在上班之前还要想办法挤出时间看一下各大新闻网站，查收邮件在各种邮件信息中找出今天需要处理的事情。并且在工作的时候，一出现一个消息弹框马上点击进去看，害怕自己遗漏哪怕一次消息。\n这些在一个信息爆炸的时代是正常的，被称为信息饥渴。其实出现这个情况是由于我们没有很好获取信息方式和管理信息方法。这篇文章就介绍如何更好的利用网络工具来为我们管理信息。 这里我先把这些网络工具分为：\n 信息产生工具\ngithub、facebook、twitter、rss博客、linkedin、微信服务号  信息收集转换器\nzapier、ifttt、smooch、feedly、pocket、buffer  时间/任务/信息管理工具（GTD）\nEvernote、todoist、kanbanflow、自己博客、bearychat、slack    作为一个有态度的程序员肯定是从我最爱的github开始了，我们在github上面肯定少不了有自己的开源代码，当有人给我们提交一个issue、发起一个pull request等信息时我们\ngithub --&gt; kanbanflow  我把看书作为一项任务来对待，在我看完一本书的时候自动在 Evernote 里面创建一个书评的待完成的笔记，并在 todolist 中建立一个任务放入到待计划中\nkanbanflow --&gt; Evernote --&gt; kanbanflow  对于facebook、twitter等社交工具中有新信息的时候，全部集中到 slack\nfacebook/twitter --&gt; slack  对于各种新闻信息进行快速过滤，对于感兴趣的放入到pocket,同时建立阅读任务；后面在整理pocket的时候需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。\npocket --&gt; todoist pocket --&gt; Evernote --&gt; kanbanflow  对于自己关注的新闻、博客、论坛等信息，订阅rss信息到feedly，如果有信息时自在todolist建立阅读任务；在阅读过程中需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。\nrss/feedly --&gt; kanbanflow rss/feedly --&gt; Evernote --&gt; kanbanflow  对于自己博客更新，会自动同步到twitter、facebook等账户中，并且保存到 Evernote\n自己博客 --&gt; facebook --&gt; twitter --&gt; Evernote  在工作中我们会用到 gitlab、jenkins 等工具，我把这些信息全都收集到 bearychat 中\ngitlab/jenkins --&gt; bearychat  ", "content_s": "你 每天 早上 一 醒来 没有 有没有 立即 想 拿 起 手机 赶紧 看 一下 （ facebook 、 twitter 、 微信 ） ， 无论 里面 没有 有没有 信息 都 要 打开 一下 才 安心 ？ 并且 在 上班 之前 还要 想 办法 挤出 时间 看 一下 各大 新闻 网站 ， 查收 邮件 在 各种 邮件 信息 中 找出 今天 需要 处理 的 事情 。 并且 在 工作 的 时候 ， 一 出现 一个 消息 弹框 马上 点击 进去 看 ， 害怕 自己 遗漏 哪怕 一次 消息 。 \n 这些 在 一个 信息 爆炸 的 时代 是 正常 的 ， 被 称为 信息 饥渴 。 其实 出现 这个 情况 是 由于 我们 没有 很 好 获取 取信 信息 获取信息 方式 和 管理 信息 方法 。 这 文章 篇文章 就 介绍 如何 更好 的 利用 网络 工具 网络工具 来 为 我们 管理 信息 。   这里 我 先 把 这些 网络 工具 网络工具 分为 ： \n   信息 产生 工具 \n github 、 facebook 、 twitter 、 rss 博客 、 linkedin 、 微信 服务 号     信息 收集 转换 转换器 \n zapier 、 ifttt 、 smooch 、 feedly 、 pocket 、 buffer     时间 / 任务 / 信息 管理 信息管理 工具 （ GTD ） \n Evernote 、 todoist 、 kanbanflow 、 自己 博客 、 bearychat 、 slack         作为 一个 有 态度 的 程序 程序员 肯定 是从 我 最 爱 的 github 开始 了 ， 我们 在 github 上面 肯定 不了 少不了 有 自己 的 开 代码 源代码 ， 当 有人 给 我们 提交 一个 issue 、 发起 一个 pull   request 等 信息 时 我们 \n github   - - & gt ;   kanbanflow     我 把 看书 作为 一项 任务 来 对待 ， 在 我 看 完一 本书 的 时候 自动 在   Evernote   里面 创建 一个 书评 的 待 完成 的 笔记 ， 并 在   todolist   中 建立 一个 任务 放入 到 待 计划 中 \n kanbanflow   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 facebook 、 twitter 等 社交 工具 中有 新 信息 的 时候 ， 全部 集中 到   slack \n facebook / twitter   - - & gt ;   slack     对于 各种 新闻 信息 进行 快速 过滤 ， 对于 感兴 兴趣 感兴趣 的 放入 到 pocket , 同时 建立 阅读 任务 ； 后面 在 整理 pocket 的 时候 需要 整理 笔记 的 时候 自动 在 Evernote 中 建立 需要 完善 的 整理 笔记 和 相关 todolit 任务 。 \n pocket   - - & gt ;   todoist   pocket   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 自己 关注 的 新闻 、 博客 、 论坛 等 信息 ， 订阅 rss 信息 到 feedly ， 如果 有 信息 时自 在 todolist 建立 阅读 任务 ； 在 阅读 过程 中 需要 整理 笔记 的 时候 自动 在 Evernote 中 建立 需要 完善 的 整理 笔记 和 相关 todolit 任务 。 \n rss / feedly   - - & gt ;   kanbanflow   rss / feedly   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 自己 博客 更新 ， 会 自动 同步 到 twitter 、 facebook 等 账户 中 ， 并且 保存 到   Evernote \n 自己 博客   - - & gt ;   facebook   - - & gt ;   twitter   - - & gt ;   Evernote     在 工作 中 我们 会 用到   gitlab 、 jenkins   等 工具 ， 我 把 这些 信息 全都 收集 到   bearychat   中 \n gitlab / jenkins   - - & gt ;   bearychat    ", "title_s": "让 网络 更好 为 我们 服务"}, {"description": "", "objectID": "https://blog.threeq.me/post/ci-cd-tool/", "tags": ["jenkins", "gerrit", "gitlab", "redmine", "CI/CD"], "title": "项目持续集成工具", "uri": "https://blog.threeq.me/post/ci-cd-tool/", "content": " 每个项目管理中都有自己的管理工具集合，这里分享一下我用过的工具集合，这里面有些工具的实践时间可能并不是很长时间，列在这里意味这下一个阶段的实践计划。同时也分享一下我自己在选择工具集合的时候考虑的点(关于每类工具如何比较它们最后做出选择我后面会慢慢补上)。在这里不会详细介绍每种工具的安装、连接和使用过程，如果后面有时间我会专门写这些工具的安装、配置和配合使用。 O 首先列出我认为在项目管理中比较重要的工具，同时这些也是我在实践中用得比较多的一套工具集：\n   工具 职责 描述     git  网上有个在线教程很好《pro git》中文版   gerrit 代码库服务器工具/代码审核工具 基于git的在线代码审查工具，围绕它建立代码审核平台和流程   gitlab 版本库展示平台 gitlab这里只作为代码展示平台和最终的发布代码库   jenkins 自动化持续集成平台 jenkins自动测试/集成/发布，围绕它建立可持续集成平台   redmine 任务管理平台/缺陷跟踪平台    sonar 代码质量报告聚合工具 围绕它搭建一个代码质量监控平台    关于上面工具的安装过程不做描述，不过个人建议可以把每个服务都做成docker容器，这样如果需要再次搭建环境就方便了。\n下面对这套工具集合的流程介绍 工具流程 整理流程 {% plantuml %} ACTOR 开发人员 control gerrit control jenkins ACTOR 审核人员 database sonar database gitlab control redmine\n开发人员-&gt;gerrit: 提交代码审核 gerrit-&gt;jenkins: 触发持续集成测试 jenkins-&gt;jenkins: 执行集成测试 jenkins-&gt;sonar: 收集代码质量报告 gerrit&lt;--jenkins: 返回测试结果 gerrit-&gt;审核人员: 通知人工审核 gerrit&lt;--审核人员: 人工审核反馈 gerrit-&gt;gerrit: 验证代码审核结果/代码合并 gerrit-&gt;gitlab: 合并的代码提交到gitlab gitlab-&gt;redmine: 自动更新redmine的缺陷 开发人员&lt;--gerrit: 通知开发人员审核结果  {% endplantuml %}\ngerrit代码审查流程 选择工具的思考 首先要明确一点：不论多么智能的工具，都是为我们程序员服务的，只是为我们提供一个更好工作的环境，让我们可以更愉快的coding。所以在选择一个项目的基础平台环境时，一定要考虑到项目团队的人员情况。\n* 平台工具集可以引导团队成员不断提高自己 * 方便团队任务分配、跟踪 * 团队成员可以随时随地，在自己想看代码的时候方便得到 * 代码质量可视化、可跟踪 * 一切和编码不相关的内容，尽量自动化 * 可持续集成 * 方便文档的编写  同时在项目中哪些方面是需要引入工具的呢？这个答案在每一个团队都会不一样，这里写一些我自己的想法：\n* 代码管理环境 * 任务/缺陷管理环境 * 自动化测试/持续集成环境 * 代码质量监控环境 * 文档编辑环境 * 协作/沟通环境 * 集成开发环境  下面我会对这几方面的工具进行一个简单的考量，说明我自己在这方面的考虑点，但是不会做非常细致的比较，原因有2个： 1. 有很多工具我自己也没有亲身使用过； 2. 每个人或团队对工具的思考都会不同，同时网上有很多的关于它们比拼的文章，最重要的是自己的使用感受和思考\n代码管理环境 代码版本库的管理我相信这个大家都会用工具来管理（如果你还没有使用版本库管理或者还在自己手动管理，我只能呵呵。。。了）。对于不同的版本控制需求，我们需要不同的管理策略，当然这个和团队的协作方式有很大的关系。同时现在的代码版本管理工具也很多：VSS、SVN、GIT、CVS(完全可以用SVN代替)、ClearCase等。那对于代码管理环境需要考虑那些因素： * 安全性(如果你是开源的忠诚粉丝，可以完全忽略这个) * 易用性 * 总体成本 * 技术支持 * 周边产品（衍生工具/其他产品集成工具） * 是否离线操作（这个这里作为考虑条件是因为网络有时确实是一个坑,不解释） * 支持代码审查\n这里我主要比较了git和svn。VSS支持平台有限（感觉只有win）果断干掉（我不好意思让兄弟们把mac换成win吧，呵呵。。。）；ClearCase看到网上介绍感觉功能很强大的，但是看了一下价格果断干掉（原因不要深究。。。）。\nGIT git这个现在很火，用的人很多，包括我自己现在也是完全使用这个。\n 安全性\n 使用这个可以说你的代码都没有什么安全性了(一些专业的git服务器除外)，他对安全性的控制你完全可以忽略。这个也没有办法，谁让他的作者就是开源狂热份子呢 由于他们分布式管理方式，任何一个开发人员本地都有一份完整的代码库克隆，所以任何一个人员或服务器损坏了，也不会对开发有任何影响，同时找回来也是非常方便的，基本不用成本  易用性\n 这个可能就要因人而已了，如果之前对命令行的模式比较熟悉，那这个基本上就没有任何学习曲线了，只是自己的命令集合里面多了一个叫git的命令而已；但是对于之前比较习惯图形界面的童鞋就有学习成本了(实际上从我和兄弟们的使用情况来看，其实不是学习git命令花费时间，而是要让自己习惯命令行工作方式)，不过成本其实是很低的，比如我们团队的兄弟们在一周之内都实用的很溜了(这里给兄弟们赞一个)。 后面就是关于分支的管理、合并、冲突的解决等协作方面的问题，这个从我个人的使用来看问题基本不大，只要把网上的那本《pro git》跟着操作完成，你能需要遇到的问题基本OK了。 最后就是规划团队的代码管理流程了，让代码版本管理在团队不断扩大、项目越来越多的过程中不至于失控 还有一个不经常会用到的操作，就是迁移代码库。这个对于git来说就太容易了，就是2、3个命令的事  总体成本\n 因为是开源的，所以从软件费用来说是0成本 剩下的就是我们自己搭建服务器的成本了，如果感觉自己服务器也不想出，那就找网上的云服务就好了，所以这个成本也是相对叫低的了。这里列举几个我用过的：github、coding.net、Git@OSC具体谁更适合你，都去用一边就好了 最后就是团队的学习成本了，从我在易用性里面介绍，我感觉一个团队学习的成本不会超过1周 同时git的周边产品大多都是免费的或者提供免费版本，所以他的配套产品成本其实很低  技术支持\n 开源的东西就只有社区，这个不要想太多，任何东西都需要你自己去发现，当然如果你选择三方平台，他们会有服务器平台部分支持的  周边产品\n 现在基于git的衍生产品太多了，上面所列举的都是，随便baidu和google都是一大把 其他平台对于git的支持我个人感觉很不错，不论是IDE、持续集成环境、bug跟踪系统都有响应的插件支持git版本库  离线操作\n 这个离线操作也是我之前考虑使用它的一个重要原因，每个人只需要在本地编写好、提交好你的代码，然后找一个网络环境的地方，把代码同步一下就好了   SVN(有这个没有必要CVS了) svn现在用的团队很多，是一种集中式版本管理工具，我之前也是用这个很长一段时间。\n 安全性\n svn的目标就管理团队代码，所以可以很精确的控制每个人远能访问的权限，目录分支等 由于是集中式管理，所以svn服务器千万不能挂掉，如果挂了大家都不能工作了，同时找回代码也是一件费劲的事情  易用性\n svn提供图形化客户端(非linux系统)，所以大家看一下就可以使用了 svn分支、合并、冲突解决都是图形化操作，大家用起来问题不大 大家都习惯了图形操作的方式，所以学习很快 但是在团队不断变大、项目越来越多的时候，对svn的管理就需要有点技巧了  总体成本\n svn软件本身是免费的，所以软件本身费用是0成本 如果自己搭建服务器，那就需要服务器成本了，不过你可以选择网上云服务，如google代码库（国内的就别想了）、svn china、RiouxSVN等。因为我自己以前只使用过google，所以对这些云服务需要自己去体验了 团队学习我们忽略吧 svn的目标毕竟是代替老牌的cvs，周边产品的支持那是杠杠的，其他和软件开发相关的环境和平台，肯定都是支持svn的，如果你选择的基础环境工具中还有不支持svn的，那肯定是你出问题了。但是很多优秀svn的周边产品都是需要收费的  技术支持\n 社区绝对是一个神奇的存在，你遇到的问题，肯定有人解决了，至少我当时是这样的 同时可以买专业的svn产品，这样可以得到专业团队的技术支持，当然这个成本肯定是有的  周边产品\n 刚刚就说了它的目标是代替老牌的cvs，所以周边产品自然不用说，只是成本的问题  离线操作\n 这个是我当时最郁闷的一点，如果你没有网络，你就不能提交了。很不好做历史记录管理   git服务器 这里只介绍git版本库管理中其他的思考。只介绍git是因为我现在使用的git，其实是之前在使用svn的时候没有考虑那么多，自己也没有好好去研究svn的一套体系。\n要使用git作为团队代码管理，就需要git服务器（当然对那些单兵作战的兄弟们，最好也有一个git服务器，这样至少可以做到你在哪里都可以作战）。这里git服务器的选择就有两种方式了：1、使用三方托管平台；2、自己搭建git服务器。这里主要讨论第2种方式，自家搭建服务器。\ngit是基于ssh的，所以如果不要复杂功能只需要一个git-shell就可以是服务器了，不过我们可不想重复找轮子，别人已经弄好的工具，我们为什么不直接用呢！！！Gitosis、 Gitolite（这个东西的权限管理很不错）等。如果要高级功能的(如：web访问)，那gitlab和gerrit（下载需要翻墙）将是不二之选。这里我同时选用了2者，它们的不同在于gerrit是一个更偏向代码审查工具和权限控制。虽然gitlab也可以做代码审查，但是gerrit是做提交前审查，同时对代码权限的控制更细力度；而gitlab是代码提交后审查，同时必须有开发人员手动发起审查，不能自动发起审查操作。这导致他们两个的操作流程有很大区别。我个人更倾向于gerrit的方式，这样可以强迫大家把自己的代码质量提上去，所以我这里选择了两者结合，gerrit这里做权限和质量把控，gitlab做为集成测试和发布版本库。\n任务/缺陷管理环境 缺陷跟踪系统redmine、Bugzilla、BugZero、Trac、jira、trello、bugfree、禅道、coding.net等，现在不论是收费的还是免费的都有很多，我相信任何一个都能解决bug跟踪问题。从我的使用过程中发现这些系统都有各自的有点，同时也有很多不足的地方，最终一个工具是不是符合你们团队，只有试用过才知道。以下是我在使用过程中发现的一些特点，感觉如果从这些点出发去试用和思考一个系统或工具，可以很快判断这个系统或工具是否适合团队，里面有些特性是我使用过的工具里面都没有的，但是这些特点我感觉确实很有用：\n 跨平台客户端（现在大多是web，这个大部分都满足） 可以和其他种类系统集成（如：代码库，测试平台、持续集成环境等） 界面易操作性 多项目管理 自定义流程 当然成本决定算一个 系统更新速度 支持多种开发模式 分级统计功能 移动端支持  持续集成环境 持续集成环境对团队和项目的自动化有一定要求，同时可以也是对团队自动化的一种推进；同时对团队的开发流程和编码风格都会有推动作用。当然至于用什么工具那是其次的，总点是要让团队养成持续集成的习惯和节奏。\n持续集成至应该做到一下几点：\n 自动构建：要求无人值守，如果人工来操作，那就没有持续集成的必要了 发现版本库的变更：通过轮询或者定时，或者程序员使用命令，处罚持续集成发现版本库的变更 反馈机制：在出现问题时，能及时的把问题反馈给正确的人（提交者、测试者、管理者） 回滚：在出现问题后，拥有回滚到可交付的能力 纯净的构建环境：每一次都应该把之前的环境删除干净，让每一次构建都是一个新的构建 完善的集成功能：代码的测试，审查都应该做到完善。如果单纯的利用它做持续的编译，那就是大材小用了 为了避免每次过多出现问题的构建，开发者在提交代码的时候，最好在本地独立的构建一次。可以自行运行构建脚本，模拟构建 由于数据库与编码的分离，最好把数据库相关的DDL\\DML等脚本一起放入版本库中，这样CI进行构建的时候，可以连同数据库一起重新构建 能和我们的代码管理库、任务/缺陷跟踪等其他平台交互  推荐书籍《持续集成：软件质量改进和风险降低之道》\n集成工具：jenkins（前身是Hudson）、gitlab-ci、Apache Continuum、CruiseControl、Luntbuild、drone、shippable\n集成的配置是必不可少的，就是让你定义如何集成构建的构建脚本啦，如果没有一个可配置的构建过程，那持续集成从何说起呢。ant、maven、gradle、make、shell\n由于集成是基于测试之上的，所以一个好的测试工具比不可少，但是这个和团队使用的语言息息相关，每中语言都有自己的测试工具。简单举例已达到抛砖引玉的效果：各种Unit（Junit，HtmlUnit，cppUnit，SQLUnit等）、karma、mocha。。。（手软&gt;_&lt;）\n自动代码审查是提高代码质量，养成代码习惯比可少的，同时这些事情可以自动的做掉，可以让我们更加关注于我们的代码 checkstyle、javaNcss、PMD、siminan、jsHint、jsLint、Emma。。。\n集成反馈和报告这个可以让我们可以实时得到集成结果，失败快速找原因，成功我们就可以安心睡觉了。邮件通知、Jabber、JSCoverage、GCOV、python coverage、JCoverage、Cobertura。。。\n代码质量监控环境 代码质量监控平台其实就是让我们的代码质量可视化、可管理，让我们的代码质量形成历史记录。同时可以非常方便的工全部人员查看。\n 质量可视化 跟踪质量走向（需要历史记录） 可以自动从持续集成环境、代码审查中搜集质量信息 可以和代码管理环境打通，这个的目的是最好能看到每个人代码质量 可以和其他工程管理工具打通  SonarQube、前面介绍的自动代码审查工具\n文档编辑环境 我们的程序员往往都不喜欢写文档，你让他写文档，还不如让他写2倍的代码。但是文档确是我们项目中不可缺少的部分，那怎么让我们的程序员可以高效的写文档呢！其实我们程序员在写文档的时候，往往是被文档的格式所折磨，不能专心的写内容，从而出发对写文档的抵触情绪。所以结合以上我任务文档编写环境应该有一下几点：\n 不用关心格式，重点在内容，格式自动 能从代码中自动生成文档 文档能实时共享、自动共享，像现在用的邮件、QQ之类的其实很影响心情 文档格式足够简单，在写的时候要做到双手不脱离键盘最好  markdown、各种语言doc工具了（jsdoc、javadoc等）、wiki、shpinx\n沟通环境 上面所说的说有东西的最终目的其实都是为了解决我们协作的问题，至少是或多或少都会涉及到协作沟通问题。像现在大家用的最多的沟通工具应该变成QQ、微信之类的了吧，加上邮件、电话、各种协作平台或者其他通讯工具，但是这些工具都有一个特点：在使用的时候都会有一个长时间打断我们思维，或者需要我们专门准备一个时间去做；这些其实都会造成浪费。其实最有效的沟通就是面对面交流，所以构建一个良好的沟通环境，对我们的项目进度起着至关重要的作用：\n 沟通资源随手可得（易于获得），可以在30秒内获得 兄弟们可以采取自己认为高效的方式沟通，同时沟通方式的资源易于获得 沟通历史和结果易于记录，最好能在不察觉的情况下记录起来  项目开发环境 项目开发环境可以分为：工程管理工具和工程开发工具。项目开发环境每个团队都有差别，同时团队内部每个人肯定都有差异，因为它受到的影响因数最多，比如：使用语言，工作内容，个人习惯，操作系统，可能还和心情有关等。因此团队在选择项目开发环境的时候，既要根据团队的定位选定基础开发环境（工程管理工具），同时出一些选择辅助开发环境的选择指导规则；也要考虑每个成员的习惯，开放出来辅助开发环境，让每个成员可以根据自己的习惯，选择一套他自己最高效的项目开发环境集合。下面我列举我认为在选择工程管理工具和工程开发工具应该具备的几点特征：\n工程管理工具  可以和工程开发工具高效集成 可以测试 可以做质量检查 可以和质量管理系统集成  ant，maven，gradle，gulp，grunt，make，cmake。。。\n项目开发工具 项目开发工具也叫做集成开发环境，很多集成开发环境都带有自己的工程管理工具\n 可以和代码管理工具集成 测试必须 可以做本地质量检查 可以方便实现重构手法，关于重构推荐《重构：改变既有代码设计》 最好能和缺陷跟踪系统集成 可以和工程管理工具集成  eclipse、webstorm、vs、idea等\n需求/产品管理环境 对于需求/产品管理环境我自己现在还没有在具体项目中实践过，所以这里就不在阐述了，如果你有好的想法可以给我留言，或者给我连接地址，我连接过去\n测试管理环境 测试管理环境其实应该在持续集成环境里面，但是由于上面写持续集成环境的时候过于偏向开发人员的使用角度介绍了，并且这两套系统确实也是独立存在的。这个测试管理环境更多面向于测试人员，而我认为测试工具本身也是分为测试管理工具和测试执行工具两类别，所以我会从测试管理和测试执行两个方面来说我观点（这里的划分是按照工具的分类划分，并不是按照软件方法的方式划分），同时对于测试我想后面会有专门的一篇文章来介绍，所以这里就这样了，大家见谅我的不专业\n测试管理工具 测试管理我认为比较重要的是：测试计划，测试用例，测试跟踪，缺陷管理(这个和任务/缺陷管理环境一样)\n 可以管理测试计划 可以管理测试用例 可以跟踪每个测试用例的状态 可以和缺陷系统集成 可以和持续集成系统集成  QC(Quality Center)，TestLink，oKit，TD（TestDirector）上面提到的缺陷管理系统\n测试执行工具 测试执行的方式都很多了，并且测试执行种类也很多，比如：自动化测试，性能测试，安全测试，白盒测试等。这里面不同的测试方式所使用的工具都是不一样的：\nselenium，jmeter，jprofile，Wireshark，AppCan，Metasploit，Nmap，Acunetix，Burp Suite，apache ab，Gatling\n还是那句话工具只能给我们提供一个更专心、更快速做事的环境，但是最终这个事情能不能做成、能不能做好完全是取决我们自己。所以不论使用任何工具都行，前提是我们有自己提高的意识和习惯，比如：编码风格、编程习惯、测试习惯、重构习惯、沟通能力、协作能力等，这些才是真真决定项目成败的关键。\n", "content_s": "  每个 项目 管理 项目管理 中 都 有 自己 的 管理 理工 工具 管理工具 集合 ， 这里 分享 一下 我用 过 的 工具 集合 ， 这 里面 有些 工具 的 实践 时间 可能 并 不是 很 时间 长时间 ， 列 在 这里 意味 这下 一个 阶段 的 实践 计划 。 同时 也 分享 一下 我 自己 在 选择 工具 集合 的 时候 考虑 的 点 ( 关于 每 类 工具 如何 比较 它们 最后 做出 选择 我 后面 会 慢慢 补 上 ) 。 在 这里 不会 详细 介绍 每种 工具 的 安装 、 连接 和 使用 过程 ， 如果 后面 有 时间 我会 专门 写 这些 工具 的 安装 、 配置 和 配合 使用 。   O   首先 列出 我 认为 在 项目 管理 项目管理 中 比较 重要 的 工具 ， 同时 这些 也 是 我 实践 在实践中 用 得 比较 多 的 一套 工具 工具集 ： \n       工具   职责   描述           git     网上 有个 在线 教程 在线教程 很 好 《 pro   git 》 中文 文版 中文版       gerrit   代码 库 服务 务器 服务器 工具 / 代码 审核 工具   基于 git 的 在线 代码 审查 工具 ， 围绕 它 建立 代码 审核 平台 和 流程       gitlab   版本 库 展示 平台   gitlab 这里 只 作为 代码 展示 平台 和 最终 的 发布 代码 库       jenkins   自动 自动化 持续 集成 平台   jenkins 自动 测试 自动测试 / 集成 / 发布 ， 围绕 它 建立 可 持续 集成 平台       redmine   任务 管理 平台 / 缺陷 跟踪 平台         sonar   代码 质量 报告 聚合 工具   围绕 它 搭建 一个 代码 质量 监控 平台         关于 上面 工具 的 安装 过程 不 做 描述 ， 不过 个人 建议 可以 把 每个 服务 都 做成 docker 容器 ， 这样 如果 需要 再次 搭建 环境 就 方便 了 。 \n 下面 对 这套 工具 集合 的 流程 介绍   工具 流程   整理 流程   { %   plantuml   % }   ACTOR   开发 发人 人员 开发人员   control   gerrit   control   jenkins   ACTOR   审核 人员   database   sonar   database   gitlab   control   redmine \n 开发 发人 人员 开发人员 - & gt ; gerrit :   提交 代码 审核   gerrit - & gt ; jenkins :   触发 持续 集成 测试   jenkins - & gt ; jenkins :   执行 集成 测试   jenkins - & gt ; sonar :   收集 代码 质量 报告   gerrit & lt ; - - jenkins :   返回 测试 结果   gerrit - & gt ; 审核 人员 :   通知 人工 审核   gerrit & lt ; - - 审核 人员 :   人工 审核 反馈   gerrit - & gt ; gerrit :   验证 代码 审核 结果 / 代码 合并   gerrit - & gt ; gitlab :   合并 的 代码 提交 到 gitlab   gitlab - & gt ; redmine :   自动 更新 自动更新 redmine 的 缺陷   开发 发人 人员 开发人员 & lt ; - - gerrit :   通知 开发 发人 人员 开发人员 审核 结果     { %   endplantuml   % } \n gerrit 代码 审查 流程   选择 工具 的 思考   首先 要 明确 一点 ： 不论 多么 智能 的 工具 ， 都 是 为 我们 程序 程序员 服务 的 ， 只是 为 我们 提供 一个 更好 工作 的 环境 ， 让 我们 可以 更 愉快 的 coding 。 所以 在 选择 一个 项目 的 基础 平台 环境 时 ， 一定 要 考虑 到 项目 团队 的 人员 情况 。 \n *   平台 工具 工具集 可以 引导 团队 成员 不断 提高 自己   *   方便 团队 任务 分配 任务分配 、 跟踪   *   团队 成员 可以 随时 随地 随时随地 ， 在 自己 想 看 代码 的 时候 方便 得到   *   代码 质量 可视 可视化 、 可 跟踪   *   一切 和 编码 不 相关 的 内容 ， 尽量 自动 自动化   *   可 持续 集成   *   方便 文档 的 编写     同时 在 项目 中 哪些 方面 哪些方面 是 需要 引入 工具 的 呢 ？ 这个 答案 在 每 一个 团队 都 会 不 一样 ， 这里 写 一些 我 自己 的 想法 ： \n *   代码 管理 环境   *   任务 / 缺陷 管理 环境   *   自动 自动化 测试 / 持续 集成 环境   *   代码 质量 监控 环境   *   文档 编辑 环境   *   协作 / 沟通 环境   *   集成 开发 环境     下面 我会 对 这 几 方面 的 工具 进行 一个 简单 的 考量 ， 说明 我 自己 在 这方 方面 这方面 的 考虑 点 ， 但是 不会 做 非常 细致 的 比较 ， 原因 有 2 个 ：   1 .   有 很多 工具 我 自己 也 没有 亲身 使用 过 ；   2 .   每个 人 或 团队 对 工具 的 思考 都 会 不同 ， 同时 网上 有 很多 的 关于 它们 比拼 的 文章 ， 最 重要 的 是 自己 的 使用 感受 和 思考 \n 代码 管理 环境   代码 版本 库 的 管理 我 相信 这个 大家 都 会 用 工具 来 管理 （ 如果 你 还 没有 使用 版本 库 管理 或者 还 在 自己 手动 管理 ， 我 只能 呵呵 。 。 。 了 ） 。 对于 不同 的 版本 控制 版本控制 需求 ， 我们 需要 不同 的 管理 策略 管理策略 ， 当然 这个 和 团队 的 协作 方式 有 很大 的 关系 。 同时 现在 的 代码 版本 管理 理工 工具 管理工具 也 很多 ： VSS 、 SVN 、 GIT 、 CVS ( 完全 可以 用 SVN 代替 ) 、 ClearCase 等 。 那 对于 代码 管理 环境 需要 考虑 那些 因素 ：   *   安全 安全性 ( 如果 你 是 开源 的 忠诚 粉丝 ， 可以 完全 忽略 这个 )   *   易用 易用性   *   总体 成本   *   技术 支持 技术支持   *   周边 产品 周边产品 （ 衍生 工具 / 其他 产品 集成 工具 ）   *   是否 离线 操作 （ 这个 这里 作为 考虑 条件 因为 是因为 网络 有时 确实 是 一个 坑 , 不 解释 ）   *   支持 代码 审查 \n 这里 我 主要 比较 了 git 和 svn 。 VSS 支持 平台 有限 （ 感觉 只有 win ） 果断 干掉 （ 我 不好 好意 意思 好意思 不好意思 让 兄弟 们 把 mac 换成 win 吧 ， 呵呵 。 。 。 ） ； ClearCase 看到 网上 介绍 感觉 功能 很 强大 的 ， 但是 看 了 一下 价格 果断 干掉 （ 原因 不要 深究 。 。 。 ） 。 \n GIT   git 这个 现在 很火 ， 用 的 人 很多 ， 包括 我 自己 现在 也 是 完全 使用 这个 。 \n   安全 安全性 \n   使用 这个 可以 说 你 的 代码 都 没有 什么 安全 安全性 了 ( 一些 专业 的 git 服务 务器 服务器 除外 ) ， 他 对 安全 安全性 的 控制 你 完全 可以 忽略 。 这个 也 没有 办法 ， 谁 让 他 的 作者 就是 开源 狂热 份子 呢   由于 他们 分布 布式 分布式 管理 方式 ， 任何 一个 开发 发人 人员 开发人员 本地 都 有 一份 完整 的 代码 库 克隆 ， 所以 任何 一个 人员 或 服务 务器 服务器 损坏 了 ， 也 不会 对 开发 有 任何 影响 ， 同时 找 回来 也 是 非常 方便 的 ， 基本 不用 成本     易用 易用性 \n   这个 可能 就要 因 人 而已 了 ， 如果 之前 对 命令 命令行 的 模式 比较 熟悉 ， 那 这个 基本 基本上 就 没有 任何 学习 曲线 学习曲线 了 ， 只是 自己 的 命令 集合 里面 多 了 一个 叫 git 的 命令 而已 ； 但是 对于 之前 比较 习惯 图形 界面 图形界面 的 童鞋 就 有 学习 成本 了 ( 实际 实际上 从 我 和 兄弟 们 的 使用 情况 来看 ， 其实 不是 学习 git 命令 花费 时间 ， 而是 要 让 自己 习惯 命令 命令行 工作 方式 ) ， 不过 成本 其实 是 很 低 的 ， 比如 我们 团队 的 兄弟 们 在 一周 之内 都 实用 的 很 溜 了 ( 这里 给 兄弟 们 赞 一个 ) 。   后面 就是 关于 分支 的 管理 、 合并 、 冲突 的 解决 等 协作 方面 的 问题 ， 这个 从 我 个人 的 使用 来看 问题 基本 不 大 ， 只要 把 网上 的 那本 《 pro   git 》 跟着 操作 完成 ， 你 能 需要 遇到 的 问题 基本 OK 了 。   最后 就是 规划 团队 的 代码 管理 流程 了 ， 让 代码 版本 管理 在 团队 不断 扩大 不断扩大 、 项目 越来 越来越 多 的 过程 中 至于 不至于 失控   还有 一个 不 经常 会 用到 的 操作 ， 就是 迁移 代码 库 。 这个 对于 git 来说 就 太 容易 了 ， 就是 2 、 3 个 命令 的 事     总体 成本 \n   因为 是 开源 的 ， 所以 从 软件 费用 来说 是 0 成本   剩下 的 就是 我们 自己 搭建 服务 务器 服务器 的 成本 了 ， 如果 感觉 自己 服务 务器 服务器 也 不想 出 ， 那 就 找 网上 的 云 服务 就 好 了 ， 所以 这个 成本 也 是 相对 叫 低 的 了 。 这里 列举 几个 我用 过 的 ： github 、 coding . net 、 Git @ OSC 具体 谁 更 适合 你 ， 都 去 用 一边 就 好 了   最后 就是 团队 的 学习 成本 了 ， 从 我 在 易用 易用性 里面 介绍 ， 我 感觉 一个 团队 学习 的 成本 不会 超过 1 周   同时 git 的 周边 产品 周边产品 大多 都 是 免费 的 或者 提供 免费 版本 ， 所以 他 的 配套 产品 成本 产品成本 其实 很 低     技术 支持 技术支持 \n   开源 的 东西 就 只有 社区 ， 这个 不要 太多 想太多 ， 任何 东西 都 需要 你 自己 去 发现 ， 当然 如果 你 选择 三方 平台 ， 他们 会 有 服务 务器 服务器 平台 部分 支持 的     周边 产品 周边产品 \n   现在 基于 git 的 衍生 产品 太多 了 ， 上面 所 列举 的 都 是 ， 随便 baidu 和 google 都 是 一大 把   其他 平台 对于 git 的 支持 我 个人 感觉 个人感觉 很 不错 ， 不论 不论是 IDE 、 持续 集成 环境 、 bug 跟踪 系统 都 有 响应 的 插件 支持 git 版本 库     离线 操作 \n   这个 离线 操作 也 是 我 之前 考虑 使用 它 的 一个 重要 原因 ， 每个 人 只 需要 在 本地 编写 好 、 提交 好 你 的 代码 ， 然后 找 一个 网络 环境 的 地方 ， 把 代码 同步 一下 就 好 了       SVN ( 有 这个 没有 必要 CVS 了 )   svn 现在 用 的 团队 很多 ， 是 一种 集中 中式 集中式 版本 管理 理工 工具 管理工具 ， 我 之前 也 是 用 这个 很长 一段 时间 段时间 一段时间 。 \n   安全 安全性 \n   svn 的 目标 就 管理 团队 代码 ， 所以 可以 很 精确 的 控制 每个 人远能 访问 的 权限 ， 目录 分支 等   由于 是 集中 中式 集中式 管理 ， 所以 svn 服务 务器 服务器 千万 不能 挂掉 ， 如果 挂 了 大家 都 不能 工作 了 ， 同时 找回 代码 也 是 一件 费劲 的 事情     易用 易用性 \n   svn 提供 图形 图形化 客户 客户端 ( 非 linux 系统 ) ， 所以 大家 看 一下 就 可以 使用 了   svn 分支 、 合并 、 冲突 解决 都 是 图形 图形化 操作 ， 大家 用 起来 问题 不 大   大家 都 习惯 了 图形 操作 图形操作 的 方式 ， 所以 学习 很快   但是 在 团队 不断 变 大 、 项目 越来 越来越 多 的 时候 ， 对 svn 的 管理 就 需要 有点 技巧 了     总体 成本 \n   svn 软件 本身 是 免费 的 ， 所以 软件 本身 费用 是 0 成本   如果 自己 搭建 服务 务器 服务器 ， 那 就 需要 服务 务器 服务器 成本 了 ， 不过 你 可以 选择 网上 云 服务 ， 如 google 代码 库 （ 国内 的 就 别 想 了 ） 、 svn   china 、 RiouxSVN 等 。 因为 我 自己 以前 只 使用 过 google ， 所以 对 这些 云 服务 需要 自己 去 体验 了   团队 学习 我们 忽略 吧   svn 的 目标 毕竟 是 代替 老牌 的 cvs ， 周边 产品 周边产品 的 支持 那 是 杠杠 的 ， 其他 和 软件 开发 软件开发 相关 的 环境 和 平台 ， 肯定 都 是 支持 svn 的 ， 如果 你 选择 的 基础 环境 工具 中 还有 不 支持 svn 的 ， 那 肯定 是 你 出 问题 了 。 但是 很多 优秀 svn 的 周边 产品 周边产品 都 是 需要 收费 的     技术 支持 技术支持 \n   社区 绝对 是 一个 神奇 的 存在 ， 你 遇到 的 问题 ， 肯定 有人 解决 了 ， 至少 我 当时 是 这样 的   同时 可以 买 专业 的 svn 产品 ， 这样 可以 得到 专业 团队 的 技术 支持 技术支持 ， 当然 这个 成本 肯定 是 有 的     周边 产品 周边产品 \n   刚刚 就 说 了 它 的 目标 是 代替 老牌 的 cvs ， 所以 周边 产品 周边产品 自然 不用 不用说 ， 只是 成本 的 问题     离线 操作 \n   这个 是 我 当时 最 郁闷 的 一点 ， 如果 你 没有 网络 ， 你 就 不能 提交 了 。 很 不好 做 历史 史记 记录 历史记录 管理       git 服务 务器 服务器   这里 只 介绍 git 版本 库 管理 中 其他 的 思考 。 只 介绍 git 因为 是因为 我 现在 使用 的 git ， 其实 是 之前 在 使用 svn 的 时候 没有 考虑 那么 多 ， 自己 也 没有 好好 去 研究 svn 的 一套 体系 。 \n 要 使用 git 作为 团队 代码 管理 ， 就 需要 git 服务 务器 服务器 （ 当然 对 那些 单兵 作战 单兵作战 的 兄弟 们 ， 最好 也 有 一个 git 服务 务器 服务器 ， 这样 至少 可以 做到 你 在 哪里 都 可以 作战 ） 。 这里 git 服务 务器 服务器 的 选择 就 有 两种 方式 了 ： 1 、 使用 三方 托管 平台 ； 2 、 自己 搭建 git 服务 务器 服务器 。 这里 主要 讨论 第 2 种 方式 ， 自家 搭建 服务 务器 服务器 。 \n git 是 基于 ssh 的 ， 所以 如果 不要 复杂 功能 只 需要 一个 git - shell 就 可以 是 服务 务器 服务器 了 ， 不过 我们 可 不想 重复 找 轮子 ， 别人 已经 弄 好 的 工具 ， 我们 什么 为什么 不 直接 用 呢 ！ ！ ！ Gitosis 、   Gitolite （ 这个 东西 的 权限 管理 很 不错 ） 等 。 如果 要 高级 功能 的 ( 如 ： web 访问 ) ， 那 gitlab 和 gerrit （ 下载 需要 翻墙 ） 将 是 不二 之选 。 这里 我 同时 选用 了 2 者 ， 它们 的 不同 在于 gerrit 是 一个 更 偏向 代码 审查 工具 和 权限 控制 。 虽然 gitlab 也 可以 做 代码 审查 ， 但是 gerrit 是 做 提交 前 审查 ， 同时 对 代码 权限 的 控制 更细 力度 ； 而 gitlab 是 代码 提交 后 审查 ， 同时 必须 有 开发 发人 人员 开发人员 手动 发起 审查 ， 不能 自动 发起 审查 操作 。 这 导致 他们 两个 的 操作 流程 有 很大 区别 。 我 个人 更 倾向 于 gerrit 的 方式 ， 这样 可以 强迫 大家 把 自己 的 代码 质量 提上 上去 提上去 ， 所以 我 这里 选择 了 两者 结合 ， gerrit 这里 做 权限 和 质量 把 控 ， gitlab 做 为 集成 测试 和 发布 版本 库 。 \n 任务 / 缺陷 管理 环境   缺陷 跟踪 系统 redmine 、 Bugzilla 、 BugZero 、 Trac 、 jira 、 trello 、 bugfree 、 禅道 、 coding . net 等 ， 现在 不论 不论是 收费 的 还是 免费 的 都 有 很多 ， 我 相信 任何 一个 都 能 解决 bug 跟踪 问题 。 从 我 的 使用 过程 中 发现 这些 系统 都 有 各自 的 有点 ， 同时 也 有 很多 不足 的 地方 ， 最终 一个 工具 不是 是不是 符合 你们 团队 ， 只有 试用 过才 知道 。 以下 是 我 在 使用 过程 中 发现 的 一些 特点 ， 感觉 如果 从 这些 点 出发 去 试用 和 思考 一个 系统 或 工具 ， 可以 很快 判断 这个 系统 或 工具 是否 适合 团队 ， 里面 有些 特性 是 我 使用 过 的 工具 里面 都 没有 的 ， 但是 这些 特点 我 感觉 确实 很 有用 ： \n   平台 跨平台 客户 客户端 （ 现在 大多 是 web ， 这个 大部 部分 大部分 都 满足 ）   可以 和 其他 种类 系统 集成 系统集成 （ 如 ： 代码 库 ， 测试 平台 、 持续 集成 环境 等 ）   界面 易 操作 操作性   多 项目 管理 项目管理   自定 定义 自定义 流程   当然 成本 决定 算 一个   系统 更新 速度   支持 多种 开发 模式   分级 统计 功能   移动 端 支持     持续 集成 环境   持续 集成 环境 对 团队 和 项目 的 自动 自动化 有 一定 要求 ， 同时 可以 也 是 对 团队 自动 自动化 的 一种 推进 ； 同时 对 团队 的 开发 流程 和 编码 风格 都 会 有 推动 作用 。 当然 至于 用 什么 工具 那 是 其次 的 ， 总点 是 要 让 团队 养成 持续 集成 的 习惯 和 节奏 。 \n 持续 集成 至 应该 做到 一下 几点 ： \n   自动 构建 ： 要求 无人 值守 ， 如果 人工 来 操作 ， 那 就 没有 持续 集成 的 必要 了   发现 版本 库 的 变更 ： 通过 轮询 或者 定时 ， 或者 程序 程序员 使用 命令 ， 处罚 持续 集成 发现 版本 库 的 变更   反馈 机制 ： 在 出现 问题 时 ， 能 及时 的 把 问题 反馈 给 正确 的 人 （ 提交 提交者 、 测试 测试者 、 管理 管理者 ）   回滚 ： 在 出现 问题 后 ， 拥有 回滚 到 可 交付 的 能力   纯净 的 构建 环境 ： 每 一次 都 应该 把 之前 的 环境 删除 干净 ， 让 每 一次 构建 都 是 一个 新 的 构建   完善 的 集成 功能 ： 代码 的 测试 ， 审查 都 应该 做到 完善 。 如果 单纯 的 利用 它 做 持续 的 编译 ， 那 就是 大材小用 了   为了 避免 每次 过多 出现 问题 的 构建 ， 开发 开发者 在 提交 代码 的 时候 ， 最好 在 本地 独立 的 构建 一次 。 可以 自行 运行 构建 脚本 ， 模拟 构建   由于 数据 据库 数据库 与 编码 的 分离 ， 最好 把 数据 据库 数据库 相关 的 DDL \\ DML 等 脚本 一起 放入 版本 库中 ， 这样 CI 进行 构建 的 时候 ， 可以 连同 数据 据库 数据库 一起 重新 构建   能 和 我们 的 代码 管理 库 、 任务 / 缺陷 跟踪 等 其他 平台 交互     推荐 书籍 《 持续 集成 ： 软件 质量 改进 和 风险 降低 之道 》 \n 集成 工具 ： jenkins （ 前身 是 Hudson ） 、 gitlab - ci 、 Apache   Continuum 、 CruiseControl 、 Luntbuild 、 drone 、 shippable \n 集成 的 配置 是 不可 必不可少 的 ， 就是 让 你 定义 如何 集成 构建 的 构建 脚本 啦 ， 如果 没有 一个 可 配置 的 构建 过程 ， 那 持续 集成 说起 从何说起 呢 。 ant 、 maven 、 gradle 、 make 、 shell \n 由于 集成 是 基于 测试 之上 的 ， 所以 一个 好 的 测试 试工 工具 测试工具 比 不可 少 ， 但是 这个 和 团队 使用 的 语言 相关 息息相关 ， 每中 语言 都 有 自己 的 测试 试工 工具 测试工具 。 简单 举例 已 达到 抛砖 抛砖引玉 的 效果 ： 各种 Unit （ Junit ， HtmlUnit ， cppUnit ， SQLUnit 等 ） 、 karma 、 mocha 。 。 。 （ 手软 & gt ; _& lt ; ） \n 自动 代码 审查 是 提高 代码 质量 ， 养成 代码 习惯 比可少 的 ， 同时 这些 事情 可以 自动 的 做 掉 ， 可以 让 我们 更加 关注 于 我们 的 代码   checkstyle 、 javaNcss 、 PMD 、 siminan 、 jsHint 、 jsLint 、 Emma 。 。 。 \n 集成 反馈 和 报告 这个 可以 让 我们 可以 实时 得到 集成 结果 ， 失败 快速 找 原因 ， 成功 我们 就 可以 安心 睡觉 了 。 邮件 通知 、 Jabber 、 JSCoverage 、 GCOV 、 python   coverage 、 JCoverage 、 Cobertura 。 。 。 \n 代码 质量 监控 环境   代码 质量 监控 平台 其实 就是 让 我们 的 代码 质量 可视 可视化 、 可 管理 ， 让 我们 的 代码 质量 形成 历史 史记 记录 历史记录 。 同时 可以 非常 方便 的 工 全部 人员 查看 。 \n   质量 可视 可视化   跟踪 质量 走向 （ 需要 历史 史记 记录 历史记录 ）   可以 自动 从 持续 集成 环境 、 代码 审查 中 搜集 质量 信息   可以 和 代码 管理 环境 打通 ， 这个 的 目的 是 最好 能 看到 每个 人 代码 质量   可以 和 其他 工程 管理 理工 工具 管理工具 打通     SonarQube 、 前面 介绍 的 自动 代码 审查 工具 \n 文档 编辑 环境   我们 的 程序 程序员 往往 都 不 喜欢 写 文档 ， 你 让 他 写 文档 ， 还 不如 让 他 写 2 倍 的 代码 。 但是 文档 确是 我们 项目 中 不可 缺少 的 部分 ， 那 怎么 让 我们 的 程序 程序员 可以 高效 的 写 文档 呢 ！ 其实 我们 程序 程序员 在 写 文档 的 时候 ， 往往 是 被 文档 的 格式 所 折磨 ， 不能 专心 的 写 内容 ， 从而 出发 对 写 文档 的 抵触 情绪 抵触情绪 。 所以 结合 以上 我 任务 文档 编写 环境 应该 有 一下 几点 ： \n   不用 关心 格式 ， 重点 在 内容 ， 格式 自动   能 从 代码 中 自动 生成 文档   文档 能 实时 共享 、 自动 共享 ， 像 现在 用 的 邮件 、 QQ 之类 的 其实 很 影响 心情   文档 格式 足够 简单 ， 在 写 的 时候 要 做到 双手 不 脱离 键盘 最好     markdown 、 各种 语言 doc 工具 了 （ jsdoc 、 javadoc 等 ） 、 wiki 、 shpinx \n 沟通 环境   上面 所说 的 说 有 东西 的 最终 目的 其实 都 是 为了 解决 我们 协作 的 问题 ， 至少 是 或多或少 都 会 涉及 到 协作 沟通 问题 。 像 现在 大家 用 的 最 多 的 沟通 工具 应该 变成 QQ 、 微信 之类 的 了 吧 ， 加上 邮件 、 电话 、 各种 协作 平台 或者 其他 通讯 工具 ， 但是 这些 工具 都 有 一个 特点 ： 在 使用 的 时候 都 会 有 一个 时间 长时间 打断 我们 思维 ， 或者 需要 我们 专门 准备 一个 时间 去 做 ； 这些 其实 都 会 造成 浪费 。 其实 最 有效 的 沟通 就是 面对 对面 面对面 交流 ， 所以 构建 一个 良好 的 沟通 环境 ， 对 我们 的 项目 进度 起着 至关 重要 至关重要 的 作用 ： \n   沟通 资源 随手 可 得 （ 易于 获得 ） ， 可以 在 30 秒 内 获得   兄弟 们 可以 采取 自己 认为 高效 的 方式 沟通 ， 同时 沟通 方式 的 资源 易于 获得   沟通 历史 和 结果 易于 记录 ， 最好 能 在 不 察觉 的 情况 下 记录 起来     项目 开发 环境   项目 开发 环境 可以 分为 ： 工程 管理 理工 工具 管理工具 和 工程 开发 工具 开发工具 。 项目 开发 环境 每个 团队 都 有 差别 ， 同时 团队 内部 每个 人 肯定 都 有 差异 ， 因为 它 受到 的 影响 因 最多 数最多 ， 比如 ： 使用 语言 ， 工作 内容 ， 个人 习惯 ， 操作 系统 操作系统 ， 可能 还 和 心情 有关 等 。 因此 团队 在 选择 项目 开发 环境 的 时候 ， 既 要 根据 团队 的 定位 选定 基础 开发 环境 （ 工程 管理 理工 工具 管理工具 ） ， 同时 出 一些 选择 辅助 开发 环境 的 选择 指导 规则 ； 也 要 考虑 每个 成员 的 习惯 ， 开放 出来 辅助 开发 环境 ， 让 每个 成员 可以 根据 自己 的 习惯 ， 选择 一套 他 自己 最 高效 的 项目 开发 环境 集合 。 下面 我 列举 我 认为 在 选择 工程 管理 理工 工具 管理工具 和 工程 开发 工具 开发工具 应该 具备 的 几点 特征 ： \n 工程 管理 理工 工具 管理工具     可以 和 工程 开发 工具 开发工具 高效 集成   可以 测试   可以 做 质量 检查 质量检查   可以 和 质量 管理 系统 管理系 管理系统 集成     ant ， maven ， gradle ， gulp ， grunt ， make ， cmake 。 。 。 \n 项目 开发 工具 开发工具   项目 开发 工具 开发工具 也 叫做 集成 开发 环境 ， 很多 集成 开发 环境 都 带有 自己 的 工程 管理 理工 工具 管理工具 \n   可以 和 代码 管理 理工 工具 管理工具 集成   测试 必须   可以 做 本地 质量 检查 质量检查   可以 方便 实现 重构 手法 ， 关于 重构 推荐 《 重构 ： 改变 既有 代码 设计 》   最好 能 和 缺陷 跟踪 系统 集成 系统集成   可以 和 工程 管理 理工 工具 管理工具 集成     eclipse 、 webstorm 、 vs 、 idea 等 \n 需求 / 产品 管理 环境   对于 需求 / 产品 管理 环境 我 自己 现在 还 没有 在 具体 项目 中 实践 过 ， 所以 这里 就 不 在 阐述 了 ， 如果 你 有 好 的 想法 可以 给 我 留言 ， 或者 给 我 连接 地址 ， 我 连接 过去 \n 测试 管理 环境   测试 管理 环境 其实 应该 在 持续 集成 环境 里面 ， 但是 由于 上面 写 持续 集成 环境 的 时候 过于 偏向 开发 发人 人员 开发人员 的 使用 角度 介绍 了 ， 并且 这 两套 系统 确实 也 是 独立 存在 的 。 这个 测试 管理 环境 更 多 面向 于 测试 人员 测试人员 ， 而 我 认为 测试 试工 工具 测试工具 本身 也 是 分为 测试 管理 理工 工具 管理工具 和 测试 执行 工具 两 类别 ， 所以 我会 从 测试 管理 和 测试 执行 两个 方面 来说 我 观点 （ 这里 的 划分 是 按照 工具 的 分类 划分 ， 并 不是 按照 软件 方法 的 方式 划分 ） ， 同时 对于 测试 我 想 后面 会 有 专门 的 一篇 文章 来 介绍 ， 所以 这里 就 这样 了 ， 大家 见谅 我 的 不 专业 \n 测试 管理 理工 工具 管理工具   测试 管理 我 认为 比较 重要 的 是 ： 测试 计划 测试计划 ， 测试 试用 测试用例 ， 测试 跟踪 ， 缺陷 管理 ( 这个 和 任务 / 缺陷 管理 环境 一样 ) \n   可以 管理 测试 计划 测试计划   可以 管理 测试 试用 测试用例   可以 跟踪 每个 测试 试用 测试用例 的 状态   可以 和 缺陷 系统 集成 系统集成   可以 和 持续 集成 系统 集成 系统集成     QC ( Quality   Center ) ， TestLink ， oKit ， TD （ TestDirector ） 上面 提到 的 缺陷 管理 系统 管理系 管理系统 \n 测试 执行 工具   测试 执行 的 方式 都 很多 了 ， 并且 测试 执行 种类 也 很多 ， 比如 ： 自动 自动化 测试 ， 性能 测试 ， 安全 测试 ， 白盒 测试 等 。 这 里面 不同 的 测试 方式 所 使用 的 工具 都 是 不 一样 的 ： \n selenium ， jmeter ， jprofile ， Wireshark ， AppCan ， Metasploit ， Nmap ， Acunetix ， Burp   Suite ， apache   ab ， Gatling \n 还是 那句话 工具 只能 给 我们 提供 一个 更 专心 、 更 快速 做事 的 环境 ， 但是 最终 这个 事情 能 不能 做成 、 能 不能 做好 完全 是 取决 我们 自己 。 所以 不论 使用 任何 工具 都行 ， 前提 是 我们 有 自己 提高 的 意识 和 习惯 ， 比如 ： 编码 风格 、 编程 习惯 、 测试 习惯 、 重构 习惯 、 沟通 能力 、 协作 能力 等 ， 这些 才 是 真真 决定 项目 成败 的 关键 。 \n", "title_s": "项目 持续 集成 工具"}, {"description": "", "objectID": "https://blog.threeq.me/post/web/css3-added-selector/", "tags": ["css3"], "title": "CSS3 新增选择器", "uri": "https://blog.threeq.me/post/web/css3-added-selector/", "content": "现代前端开发中css3已经是不可其他的一部分，早已成为每个web开发人员必备技能之一。 而选择器又是css中最基础、最重要的知识点，对于我们页面结构和代码接口都有着举足轻重的作用。 今天我们就来看看css3所支持的和新增的选择器。\n\n1. CSS1定义的选择器    选择器 类型 说明     E 类型选择器 选择指定类型的元素   E#id ID选择器 选择匹配E的元素，且匹配元素的id为“id”，E选择符可以省略。   E.class 类选择器 选择匹配E的元素，且匹配元素的class属性值为“class”，E选择符可以省略。   E F 包含选择器 选择匹配F的元素，且该元素被包含在匹配E的元素内。   E:link 链接伪类选择器 选择匹配E的元素，且匹配元素被定义了超链接并未被访问。例：a:link、#a_id:link   E:visited 链接伪类选择器 选择匹配E的元素，且匹配元素被定义了超链接并已被访问。例：a:visited   E:active 用户操作伪类选择器 选择匹配E的元素，且匹配元素被激活   E:hover 用户操作伪类选择器 选择匹配E的元素，且匹配元素正被鼠标经过   E:focus 用户操作伪类选择器 选择匹配E的元素，且匹配元素获取了焦点   E:first-line 伪元素选择器 选择匹配E元素内的第一行文本   E:first-letter 伪元素选择器 选择匹配E元素内的第一个字符    2. CSS2定义的选择器    选择器 类型 说明     * 通配选择器 选择文档中所有元素   E[foo] 属性选择器 选择匹配E的元素，且该元素定义了foo属性。E选择符可以省略，表示选择定义了foo属性的任意类型的元素。   E[foo=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素foo属性值为“bar”   E[foo~=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个以空格符分隔的列表，其中一个列表的值为“bar”，E选择符可以省略。   E[foo!=&ldquo;en&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个用连字符（-）分隔的列表，值以“en”开头。   E:first-child 结构伪类选择器 选择匹配E的元素，且该元素为父元素的第一个子元素   E:before 伪元素选择器 在匹配E的元素前面插入内容   E:after 伪元素选择器 在匹配E的元素后面插入内容   E &gt; F 子包含选择器 选择匹配F的元素，且该元素为所匹配E元素的子元素。   E + F 相邻兄弟选择器 选择匹配F的元素，且该元素为所匹配E元素后面相邻的位置。   E:lang(language) 语言选择器 例如：p:lang(it) 选择带有以 &ldquo;it&rdquo; 开头的 lang 属性值的每个  元素。    3. CSS3新增属性选择器    选择器 类型 说明     E[foo^=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”开始。E选择符可以省略，表示可匹配任意类型的元素。   E[foo$=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”结束。E选择符可以省略，表示可匹配任意类型的元素。   E[foo*=&ldquo;bar&rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值包含“bar”。E选择符可以省略，表示可匹配任意类型的元素。   E:root 结构伪类选择器 选择匹配E所在文档的根元素。在（X）HTML文档中，根元素就是html元素，此时该选择器与html类型选择器匹配的内容相同。   E:nth-child(n) 结构伪类选择器 选择所有在其父元素中第n个位置的匹配E的子元素。\n注意，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始。\ntr:nth-child(3)匹配所有表格中第3排的tr；\ntr:nth-child(2n+1)匹配所有表格的奇数行；\ntr:nth-child(2n)匹配所有表格的偶数行；\ntr:nth-child(odd)匹配所有表格的奇数行；\ntr:nth-child(even)匹配所有表格的偶数行；   E:nth-last-child(n) 结构伪类选择器 选择所有在其父元素中倒数第n个位置的匹配E的子元素   E:nth-of-type(n) 结构伪类选择器 选择父元素中第n个位置，且匹配E的子元素。\n注意，所有匹配E的子元素被分离出来单独排序。非E的子元素不参与排序。参数n可以是数字，关键字、公式。\n例：p:nth-of-type(1)   E:nth-last-of-type(n) 结构伪类选择器 选择父元素中倒数第n个位置，且匹配E的子元素。   E:last-child 结构伪类选择器 选择位于其父元素中最后一个位置，且匹配E的子元素。   E:first-of-type 结构伪类选择器 选择位于其父元素中且匹配E的第一个同类型的子元素。\n该选择器的功能类似于 E:nth-of-type(1)   E:last-of-type 结构伪类选择器 选择位于其父元素中且匹配E的最后第一个同类型的子元素。\n该选择器的功能类似于 E:nth-last-of-type(1)   E:only-child 结构伪类选择器 选择其父元素只包含一个子元素，且该子元素匹配E。   E:only-of-type 结构伪类选择器 选择其父元素只包含一个同类型的子元素，且该子元素匹配E。   E:empty 结构伪类选择器 选择匹配E的元素，且该元素不包含子节点   E:enabled UI状态伪类选择器 选择匹配E的所有可用UI元素。   E:disabled UI状态伪类选择器 选择匹配E的所有不可用UI元素。   E:checked UI状态伪类选择器 选择匹配E的所有可用UI元素。\n例：input:checked匹配input type为radio及checkbox元素   ::selection UI状态伪类选择器 选择被用户选取的元素部分。   E ~ F 相邻兄弟选择器 选择匹配F的所有元素，且匹配元素位于匹配E的元素后面。在DOM结构树中，E和F所匹配的元素应该在同一级结构上。   E:not(s) 否定伪类选择器 选择匹配E的所有元素，且过滤掉匹配s选择符的任意元素。s是一个简单结构的选择器，不能使用符合选择器，   E:target 目标伪类选择器 选择匹配E的所有元素，且匹配元素被相关URL指向。\n注意：该选择器是动态选择器，只有存在URL指向该匹配元素时，样式才起效果。\n例：demo.html#id    参考：http://www.w3school.com.cn/cssref/css_selectors.asp\n", "content_s": "现代 前端 开发 前端开发 中 css3 已经 是 不可 其他 的 一部 部分 一部分 ， 早已 成为 每个 web 开发 发人 人员 开发人员 必备 技能 之一 。   而 选择 选择器 又 是 css 中 最 基础 、 最 重要 的 知识 知识点 ， 对于 我们 页面 结构 和 代码 接口 都 有着 举足 足轻 轻重 举足轻重 的 作用 。   今天 我们 就 来 看看 css3 所 支持 的 和 新增 的 选择 选择器 。 \n \n 1 .   CSS1 定义 的 选择 选择器         选择 选择器   类型   说明           E   类型 选择 选择器   选择 指定 类型 的 元素       E # id   ID 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 的 id 为 “ id ” ， E 选择 选择符 可以 省略 。       E . class   类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 的 class 属性 值为 “ class ” ， E 选择 选择符 可以 省略 。       E   F   包含 选择 选择器   选择 匹配 F 的 元素 ， 且 该 元素 被 包含 在 匹配 E 的 元素 内 。       E : link   链接 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 定义 了 链接 超链接 并未 被 访问 。 例 ： a : link 、 # a _ id : link       E : visited   链接 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 定义 了 链接 超链接 并 已 被 访问 。 例 ： a : visited       E : active   用户 操作 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 激活       E : hover   用户 操作 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 正 被 鼠标 经过       E : focus   用户 操作 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 获取 了 焦点       E : first - line   伪 元素 选择 选择器   选择 匹配 E 元素 内 的 第一 一行 第一行 文本       E : first - letter   伪 元素 选择 选择器   选择 匹配 E 元素 内 的 第一 一个 第一个 字符         2 .   CSS2 定义 的 选择 选择器         选择 选择器   类型   说明           *   通配 选择 选择器   选择 文档 中 所有 元素       E [ foo ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 。 E 选择 选择符 可以 省略 ， 表示 选择 定义 了 foo 属性 的 任意 类型 的 元素 。       E [ foo = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 foo 属性 值为 “ bar ”       E [ foo ~ = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 是 一个 以 空格 空格符 分隔 的 列表 ， 其中 一个 列表 的 值 为 “ bar ” ， E 选择 选择符 可以 省略 。       E [ foo ! = & ldquo ; en & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 是 一个 用 连 字符 （ - ） 分隔 的 列表 ， 值以 “ en ” 开头 。       E : first - child   结构 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 为父 元素 的 第一 一个 第一个 子 元素       E : before   伪 元素 选择 选择器   在 匹配 E 的 元素 前面 插入 内容       E : after   伪 元素 选择 选择器   在 匹配 E 的 元素 后面 插入 内容       E   & gt ;   F   子 包含 选择 选择器   选择 匹配 F 的 元素 ， 且 该 元素 为 所 匹配 E 元素 的 子 元素 。       E   +   F   相邻 兄弟 选择 选择器   选择 匹配 F 的 元素 ， 且 该 元素 为 所 匹配 E 元素 后面 相邻 的 位置 。       E : lang ( language )   语言 选择 选择器   例如 ： p : lang ( it )   选择 带有 以   & ldquo ; it & rdquo ;   开头 的   lang   属性 值 的 每个     元素 。         3 .   CSS3 新增 属性 选择 选择器         选择 选择器   类型   说明           E [ foo ^ = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值以 “ bar ” 开始 。 E 选择 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E [ foo $ = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值以 “ bar ” 结束 。 E 选择 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E [ foo * = & ldquo ; bar & rdquo ; ]   属性 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 包含 “ bar ” 。 E 选择 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E : root   结构 伪类 选择 选择器   选择 匹配 E 所在 文档 的 根 元素 。 在 （ X ） HTML 文档 中 ， 根 元素 就是 html 元素 ， 此时 该 选择 选择器 与 html 类型 选择 选择器 匹配 的 内容 相同 。       E : nth - child ( n )   结构 伪类 选择 选择器   选择 所有 在 其父 元素 中 第 n 个 位置 的 匹配 E 的 子 元素 。 \n 注意 ， 参数 n 可以 是 数字 （ 1 、 2 、 3 ） 、 关键 关键字 （ odd 、 even ） 、 公式 （ 2n 、 2n + 3 ） 参数 的 索引 从 1 开始 。 \n tr : nth - child ( 3 ) 匹配 所有 表格 中 第 3 排 的 tr ； \n tr : nth - child ( 2n + 1 ) 匹配 所有 表格 的 奇数 行 ； \n tr : nth - child ( 2n ) 匹配 所有 表格 的 偶数 行 ； \n tr : nth - child ( odd ) 匹配 所有 表格 的 奇数 行 ； \n tr : nth - child ( even ) 匹配 所有 表格 的 偶数 行 ；       E : nth - last - child ( n )   结构 伪类 选择 选择器   选择 所有 在 其父 元素 中 倒数 倒数第 n 个 位置 的 匹配 E 的 子 元素       E : nth - of - type ( n )   结构 伪类 选择 选择器   选择 父 元素 中 第 n 个 位置 ， 且 匹配 E 的 子 元素 。 \n 注意 ， 所有 匹配 E 的 子 元素 被 分离 出来 分离出来 单独 排序 。 非 E 的 子 元素 不 参与 排序 。 参数 n 可以 是 数字 ， 关键 关键字 、 公式 。 \n 例 ： p : nth - of - type ( 1 )       E : nth - last - of - type ( n )   结构 伪类 选择 选择器   选择 父 元素 中 倒数 倒数第 n 个 位置 ， 且 匹配 E 的 子 元素 。       E : last - child   结构 伪类 选择 选择器   选择 位于 其父 元素 中 最后 一个 位置 ， 且 匹配 E 的 子 元素 。       E : first - of - type   结构 伪类 选择 选择器   选择 位于 其父 元素 中且 匹配 E 的 第一 一个 第一个 同 类型 的 子 元素 。 \n 该 选择 选择器 的 功能 类似 于   E : nth - of - type ( 1 )       E : last - of - type   结构 伪类 选择 选择器   选择 位于 其父 元素 中且 匹配 E 的 最后 第一 一个 第一个 同 类型 的 子 元素 。 \n 该 选择 选择器 的 功能 类似 于   E : nth - last - of - type ( 1 )       E : only - child   结构 伪类 选择 选择器   选择 其父 元素 只 包含 一个 子 元素 ， 且 该子 元素 匹配 E 。       E : only - of - type   结构 伪类 选择 选择器   选择 其父 元素 只 包含 一个 同 类型 的 子 元素 ， 且 该子 元素 匹配 E 。       E : empty   结构 伪类 选择 选择器   选择 匹配 E 的 元素 ， 且 该 元素 不 包含 子 节点       E : enabled   UI 状态 伪类 选择 选择器   选择 匹配 E 的 所有 可用 UI 元素 。       E : disabled   UI 状态 伪类 选择 选择器   选择 匹配 E 的 所有 不可 用 UI 元素 。       E : checked   UI 状态 伪类 选择 选择器   选择 匹配 E 的 所有 可用 UI 元素 。 \n 例 ： input : checked 匹配 input   type 为 radio 及 checkbox 元素       : : selection   UI 状态 伪类 选择 选择器   选择 被 用户 选取 的 元素 部分 。       E   ~   F   相邻 兄弟 选择 选择器   选择 匹配 F 的 所有 元素 ， 且 匹配 元素 位于 匹配 E 的 元素 后面 。 在 DOM 结构 树中 ， E 和 F 所 匹配 的 元素 应该 在 同 一级 结构 上 。       E : not ( s )   否定 伪类 选择 选择器   选择 匹配 E 的 所有 元素 ， 且 过滤 掉 匹配 s 选择 选择符 的 任意 元素 。 s 是 一个 简单 结构 的 选择 选择器 ， 不能 使用 符合 选择 选择器 ，       E : target   目标 伪类 选择 选择器   选择 匹配 E 的 所有 元素 ， 且 匹配 元素 被 相关 URL 指向 。 \n 注意 ： 该 选择 选择器 是 动态 选择 选择器 ， 只有 存在 URL 指向 该 匹配 元素 时 ， 样式 才 起 效果 。 \n 例 ： demo . html # id         参考 ： http : / / www . w3school . com . cn / cssref / css _ selectors . asp \n", "title_s": "CSS3   新增 选择 选择器"}, {"description": "Threeq - 出井的青蛙介绍", "objectID": "https://blog.threeq.me/about/", "tags": [], "title": "关于 Threeq - 出井的青蛙", "uri": "https://blog.threeq.me/about/", "content": " Threeq - 出井的青蛙  快乐的程序员、老司机。\n喜欢专研、思考和专研遇到的难题，不论是技术上还是团队管理上。\n对新技术保持好奇、热爱和谨慎的态度。坚信技术能让明天更美好。\n喜欢分享，开源追随者，崇尚敏捷开发实践。\n常用语言 Java、Python、Golang、Javascript\n目前正在实践 Scrum + 看板 + 领域驱动设计（DDD） + 微服务\n目前正在学 习机器学习（ML）、分布式系统架构设计、k8s 技术栈\n欢迎一起交流学习（非诚勿扰）    扫码关注订阅号    联系我    ", "content_s": "  Threeq   -   出井 的 青蛙     快乐 的 程序 程序员 、 老 司机 。 \n 喜欢 专研 、 思考 和 专研 遇到 的 难题 ， 不论 不论是 技术 上 还是 团队 管理 上 。 \n 对 新 技术 保持 好奇 、 热爱 和 谨慎 的 态度 。 坚信 技术 能 让 明天 更 美好 。 \n 喜欢 分享 ， 开源 追随 追随者 ， 崇尚 敏捷 开发 实践 。 \n 常用 语言   Java 、 Python 、 Golang 、 Javascript \n 目前 正在 实践   Scrum   +   看 板   +   领域 驱动 设计 （ DDD ）   +   微 服务 \n 目前 正在 学   习 机器 学习 （ ML ） 、 分布 布式 系统 分布式 分布式系统 架构 构设 设计 架构设计 、 k8s   技术 栈 \n 欢迎 一起 交流 学习 交流学习 （ 非诚 勿扰 ）         扫码 关注 订阅 号         联系 我        ", "title_s": "关于   Threeq   -   出井 的 青蛙"}, {"description": "", "objectID": "https://blog.threeq.me/categories/", "tags": [], "title": "Categories", "uri": "https://blog.threeq.me/categories/", "content": "", "content_s": "", "title_s": "Categories"}, {"description": "", "objectID": "https://blog.threeq.me/tags/ci/cd/", "tags": [], "title": "Ci/Cd", "uri": "https://blog.threeq.me/tags/ci/cd/", "content": "", "content_s": "", "title_s": "Ci / Cd"}, {"description": "", "objectID": "https://blog.threeq.me/tags/css3/", "tags": [], "title": "Css3", "uri": "https://blog.threeq.me/tags/css3/", "content": "", "content_s": "", "title_s": "Css3"}, {"description": "", "objectID": "https://blog.threeq.me/tags/gerrit/", "tags": [], "title": "Gerrit", "uri": "https://blog.threeq.me/tags/gerrit/", "content": "", "content_s": "", "title_s": "Gerrit"}, {"description": "", "objectID": "https://blog.threeq.me/tags/git/", "tags": [], "title": "Git", "uri": "https://blog.threeq.me/tags/git/", "content": "", "content_s": "", "title_s": "Git"}, {"description": "", "objectID": "https://blog.threeq.me/tags/gitlab/", "tags": [], "title": "Gitlab", "uri": "https://blog.threeq.me/tags/gitlab/", "content": "", "content_s": "", "title_s": "Gitlab"}, {"description": "", "objectID": "https://blog.threeq.me/tags/gtd/", "tags": [], "title": "Gtd", "uri": "https://blog.threeq.me/tags/gtd/", "content": "", "content_s": "", "title_s": "Gtd"}, {"description": "", "objectID": "https://blog.threeq.me/tags/hugo/", "tags": [], "title": "Hugo", "uri": "https://blog.threeq.me/tags/hugo/", "content": "", "content_s": "", "title_s": "Hugo"}, {"description": "", "objectID": "https://blog.threeq.me/tags/jenkins/", "tags": [], "title": "Jenkins", "uri": "https://blog.threeq.me/tags/jenkins/", "content": "", "content_s": "", "title_s": "Jenkins"}, {"description": "", "objectID": "https://blog.threeq.me/tags/mysql/", "tags": [], "title": "Mysql", "uri": "https://blog.threeq.me/tags/mysql/", "content": "", "content_s": "", "title_s": "Mysql"}, {"description": "", "objectID": "https://blog.threeq.me/tags/percona/", "tags": [], "title": "Percona", "uri": "https://blog.threeq.me/tags/percona/", "content": "", "content_s": "", "title_s": "Percona"}, {"description": "", "objectID": "https://blog.threeq.me/post/", "tags": [], "title": "Posts", "uri": "https://blog.threeq.me/post/", "content": "", "content_s": "", "title_s": "Posts"}, {"description": "", "objectID": "https://blog.threeq.me/tags/pt-query-digest/", "tags": [], "title": "Pt Query Digest", "uri": "https://blog.threeq.me/tags/pt-query-digest/", "content": "", "content_s": "", "title_s": "Pt   Query   Digest"}, {"description": "", "objectID": "https://blog.threeq.me/tags/redmine/", "tags": [], "title": "Redmine", "uri": "https://blog.threeq.me/tags/redmine/", "content": "", "content_s": "", "title_s": "Redmine"}, {"description": "", "objectID": "https://blog.threeq.me/tags/scrum/", "tags": [], "title": "Scrum", "uri": "https://blog.threeq.me/tags/scrum/", "content": "", "content_s": "", "title_s": "Scrum"}, {"description": "", "objectID": "https://blog.threeq.me/tags/sql/", "tags": [], "title": "Sql", "uri": "https://blog.threeq.me/tags/sql/", "content": "", "content_s": "", "title_s": "Sql"}, {"description": "", "objectID": "https://blog.threeq.me/tags/", "tags": [], "title": "Tags", "uri": "https://blog.threeq.me/tags/", "content": "", "content_s": "", "title_s": "Tags"}, {"description": "", "objectID": "https://blog.threeq.me/", "tags": [], "title": "Threeq - 出井的青蛙", "uri": "https://blog.threeq.me/", "content": "", "content_s": "", "title_s": "Threeq   -   出井 的 青蛙"}, {"description": "", "objectID": "https://blog.threeq.me/categories/web/", "tags": [], "title": "Web", "uri": "https://blog.threeq.me/categories/web/", "content": "", "content_s": "", "title_s": "Web"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/", "tags": [], "title": "个人管理", "uri": "https://blog.threeq.me/categories/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/", "content": "", "content_s": "", "title_s": "个人 管理"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/", "tags": [], "title": "团队管理", "uri": "https://blog.threeq.me/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/", "content": "", "content_s": "", "title_s": "团队 管理"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E5%B7%A5%E5%85%B7/", "tags": [], "title": "工具", "uri": "https://blog.threeq.me/categories/%E5%B7%A5%E5%85%B7/", "content": "", "content_s": "", "title_s": "工具"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "tags": [], "title": "敏捷开发", "uri": "https://blog.threeq.me/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "content": "", "content_s": "", "title_s": "敏捷 开发"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "tags": [], "title": "敏捷开发", "uri": "https://blog.threeq.me/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/", "content": "", "content_s": "", "title_s": "敏捷 开发"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/", "tags": [], "title": "数据库", "uri": "https://blog.threeq.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/", "content": "", "content_s": "", "title_s": "数据 据库 数据库"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/", "tags": [], "title": "数据库", "uri": "https://blog.threeq.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/", "content": "", "content_s": "", "title_s": "数据 据库 数据库"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/", "tags": [], "title": "时间管理", "uri": "https://blog.threeq.me/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/", "content": "", "content_s": "", "title_s": "时间 管理"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/", "tags": [], "title": "查询优化", "uri": "https://blog.threeq.me/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/", "content": "", "content_s": "", "title_s": "查询 优化"}, {"description": "", "objectID": "https://blog.threeq.me/tags/%E7%9C%8B%E6%9D%BF/", "tags": [], "title": "看板", "uri": "https://blog.threeq.me/tags/%E7%9C%8B%E6%9D%BF/", "content": "", "content_s": "", "title_s": "看 板"}, {"description": "", "objectID": "https://blog.threeq.me/categories/%E7%AC%94%E8%AE%B0/", "tags": [], "title": "笔记", "uri": "https://blog.threeq.me/categories/%E7%AC%94%E8%AE%B0/", "content": "", "content_s": "", "title_s": "笔记"}]