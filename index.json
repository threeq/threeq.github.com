[{"content": "在 系统 刚 上线 的 时候 ， 经常 会 出现 慢   SQL   的 情况 ， 并且 有时候 系统 会 在 特定 的 时间 点 变慢 。 这个 时候 的 慢   SQL   查询 语句 往往 是 大量 出现 ， MySQL   的 慢 查询 日志 文件 也 会 比较 大 。 这个 时候 我们 往往 需要 从 哪些 查询 最 多 、 耗时 最长 的   sql   开始 优化 ， 以 提升 我们 的 处理 效益 。 这个 时候 就 需要 我们 能 对 慢 日志 进行 统计分析 ， 在 上   M   ， 甚至   几十   M   的 日志 文件 里面 使用 手工 的 方式 明显 是 不 可能 的 ， 这个 时候 就 需要 有 专门 的 统计分析 工具 来 帮 我们 做 统计 、 分析 哪些 慢 查询 日志 。 percona - toolkit   就是 一个 提供 统计 和 分析 的 工具集 ， 这里 重点 介绍 里面 的   pt - query - digest   工具 。 \n \n percona - toolkit   安装   percona - toolkit   首页   文档   下载 地址 \n mac   安装   可以 使用   brew   直接 安装 \n brew   install   percona - toolkit     Linux   安装   详细信息 参考   官方 安装 文档 \n 源码 安装   #   下载 源码   wget   https : / / www . percona . com / downloads / percona - toolkit / 3.0 . 8 / source / tarball / percona - toolkit - 3.0 . 8 . tar . gz   #   解压   tar   xf   percona - toolkit - 3.0 . 8 . tar . gz   # 进入 目录 安装   cd   percona - toolkit - 3.0 . 8   # 开始 编译 安装   perl   Makefile . PL   make   make   install   # 安装 完 了 就 有 命令 了   ll   / usr / local / bin / pt - *     pt - query - digest   基本 使用   在 使用   pt - query - digest   前 需要 有   MySQL   慢 查询 日志 文件 ， 这里 为了 大家 方便 实验 提供 了 一份   MySQL   慢 查询 日 实验 数据   供 大家 下载 测试 （ slow - sql - test . sql . zip   点击 我 下载 ， 里面 包含 2018.04 . 01 ～ 2018.04 . 04   和   2018.04 . 06   的 日志 数据 ） 。 \n   查看 使用 帮助     & gt ;   pt - query - digest   - - help       默认 分析 参数     & gt ;   pt - query - digest   slow - sql - test . sql       总体 概要 信息 ： \n       信息 字 段   说明           Exec   Time   执行 时间       Lock   Time   锁 时间       Row   sent   发送 行 大小       Row   examine   检查 行 大小       Query   size   查询 大小       Rank   SQL   编号       Query   ID   查询   id       Response   time   sql   总共 执行 时间   和   时间 比例       Calls   sql   执行 次数       R / Call   sql   平均 每次 执行 时间       V / M         Item   sql   类型 和 涉及 到 的 表         单个   SQL   信息 ： \n   ​   分析 结果 说明 ： \n   分析 最近 一段时间 内 的 慢 查询     & gt ;   pt - query - digest   - - since = 12h   slow - sql - test . sql   #   最近   12   小时 的 慢 查询       分析 指定 时间段 内 的 慢 查询     & gt ;   pt - query - digest   slow - sql - test . sql   - - since   ' 2018 - 04 - 01   09 : 30 : 00 '   - - until   ' 2018 - 04 - 02   10 : 00 : 00 '       分析 还有 指定 特征 的 慢 查询   SQL     & gt ;   pt - query - digest   - - filter   ' $ event - & gt ; { fingerprint }   = ~   m / ^ select / i '   slow - sql - test . sql       分析 针对 某个 用户 的 慢 查询     & gt ;   pt - query - digest   - - filter   ' ( $ event - & gt ; { member }   | |   & quot ; & quot ; )   = ~   m / ^ root / i '   slow - sql - test . sql       ​     pt - query - digest 进阶 使用   有时候 我们 会 遇到 针对 慢   SQL   进行 长期 的 跟踪 分析 ， 这个 时候 我们 就 需要 将 我们 的 每次 的 分析 结果 进行 汇总 、 对比 分析 。 同时 对于 部分 环境 我们 是 不能 直接 得到 慢   SQL   日志 的 ， 这个 时候 我们 可以 通过 抓取   TCP   协议 数据 或   binlog   进行 分析 \n   将 分析 结果 保存 到 数据库     & gt ;   pt - query - digest   - - user = root   – password = abc123   - - review   h = localhost , D = test , t = query _ review - - create - review - table   slow - sql - test . sql       通过 抓取   TCP   协议 数据分析     & gt ;   tcpdump   - s   65535   - x   - nn   - q   - tttt   - i   any   - c   1000   port   3306   & gt ;   mysql . tcp . txt   & gt ;   pt - query - digest   - - type   tcpdump   mysql . tcp . txt & gt ;   slow _ report9 . log       通过   binlog   日志 分析     & gt ;   mysqlbinlog   mysql - bin.000093   & gt ;   mysql - bin000093 . sql   & gt ;   pt - query - digest   - - type = binlog   mysql - bin000093 . sql   & gt ;   slow _ report10 . log     单条   SQL   优化 基本 分析   通过 上面 的 方法 就 可以 找出 系统 里面 所有 的 慢   SQL   语句 了 ， 并且 在 分析 报告 里面 会排 好序 ， 剩下 的 就是 我们 针对 每条   SQL   语句 的 分析 调优 工作 了 。 针对   SQL   的 具体 优化 方式 内容 很多 ， 建议 大家 系统 的 学习 ， 后面 我 也 会 写 一些 我 常用 的 方法 。 这里 说 一下 单条   SQL   的 基础 分析方法 ， 好 让 大家 有个 开头 。 \n   查看   SQL   执行 计划     EXPLAIN   select   ep _ name   as   ' 企业 名称 ' ,   count ( * )   as   ' 企业 人数 ' ,   FROM _ UNIXTIME ( ep _ created / 1000 ,   GET _ FORMAT ( DATE , ' ISO ' ) )   as   ' 注册 时间 '   from   uc _ member   u   left   join   uc _ enterprise   e   on   u . ep _ id = e . ep _ id   where   ep _ domain = ' yq . vchangyi . com '   and   mem _ status & lt ; 3   group   by   u . ep _ id   order   by   企业 人数   desc ; \t   对于 上面 每 一列 的 的 意义 这里 不再 详细 介绍 ， 有 兴趣 的 同学 可以 查看   MySQL   文档 ， 或者 关注 我 后续 的 文章 ， 会 有 专门 介绍 。 \n   查询   SQL   执行 信息     查看   MySQL   语句 执行 信息 需要 首先 开启   profiling   选线 \n set   profiling   =   1 ;     然后 执行 完   SQL   过后 使用   show   profiles ;   语句 查看 执行   SQL   的 记录 id \n select   ep _ name   as   ' 企业 名称 ' ,   count ( * )   as   ' 企业 人数 ' ,   FROM _ UNIXTIME ( ep _ created / 1000 ,   GET _ FORMAT ( DATE , ' ISO ' ) )   as   ' 注册 时间 '   from   uc _ member   u   left   join   uc _ enterprise   e   on   u . ep _ id = e . ep _ id   where   ep _ domain = ' yq . vchangyi . com '   and   mem _ status & lt ; 3   group   by   u . ep _ id   order   by   企业 人数   desc ;   show   profiles ;     使用   show   profile   查看   SQL   的 执行 信息 \n show   profile   ALL   for   query   3 ;     语法 格式 ： \n show   profile   [ type ]   for   query   & lt ; query _ id & gt ; ;     如果 没有 指定   FOR   QUERY   则 显示 最近 一条 查询 的 详细信息 。 type   是 可选 的 ， 有 以下 几个 选项 ： \n   ALL   显示 所有 性能 信息   BLOCK   IO   显示 块 IO 操作 的 次数   CONTEXT   SWITCHES   显示 上下文 切换 次数 ， 不管 是 主动 还是 被动   CPU   显示 用户 CPU 时间 、 系统 CPU 时间   IPC   显示 发送 和 接收 的 消息 数量   MEMORY   [ 暂未 实现 ]   PAGE   FAULTS   显示 页 错误 数量   SOURCE   显示 源码 中 的 函数 名称 与 位置   SWAPS   显示 SWAP 的 次数  ", "description": "", "tags": ["Mysql", "数据库", "查询优化", "percona", "pt-query-digest"], "uri": "/post/db/mysql-slow-query-analyse/", "title": "mysql   查询 优化 ： 慢 查询 分析 工具   pt - query - digest"}, {"content": "我们 在 产品 中 使用   MySQL   数据库 的 时候 ， 肯定 会 用到 索引 的 ， 或是 在 前期 建立 一些 初始 索引 ， 或是 在 后期   SQL   优化 的 时候 根据 系统 运行 状态 逐渐 增加 索引 。 不论是 以 什么 方式 建立 的 索引 ， 他们 都 会 影响 我们 对 数据库 做 的 操作 ， 并且 是 对 我们 所有 的 数据 操作 都 有 影响 ， 包括   增加 、 删除 、 修改 、 查询 、 统计   操作 。 这时 如果 线上 有 部分 索引 在 系统升级 已经 失效 了 ， 我们 怎么 知道 ， 怎么 及时 的 排查 和 删除 ， 需要 我们 持续 的 跟踪 和 分析 。 今天 我 就 介绍 几款 针对 线上 数据库 索引 的 分析 工具 。 \n   pt - index - usage   userstat   check - unused - keys     \n 1 .   pt - index - usage   pt - index - usage   从 日志 里面 读取 查询 ， 并且 分析 它们 是 如何 使用 索引 的 。 它 需要   MySQL   的 慢 查询 日志 ， 在 实际 分析 中 我们 可以 讲   MySQL   的 慢 查询 参数设置 为   0   ， 这样 就 可以 得到 所有 的 执行   SQL 。 \n pt - index - uage   的 安装 请 参考   [ mysql   查询 优化 ： 慢 查询 分析 工具   pt - query - digest ] \n 使用 ： \n & gt ;   pt - index - usage   [ OPTIONS ]   [ FILES ]     分析   slow . log   的 所有 查询 语句 ， 并打印 报告 \n & gt ;   pt - index - usage   / path / to / slow . log   - - host   localhost     不 打印 报告 ， 同时 把 分析 后 的 结果 存入   percona   数据库 \n & gt ;   pt - index - usage   slow . log   - - no - report   - - save - results - database   percona     详情 参考   pt - index - uage   官方 文档   和   使用手册   [ pt - index - uage   - - help ] \n 2 .   userstat   MySQL   设置 ： \n mysql & gt ;   SET   GLOBAL   userstat = ON ;   mysql & gt ;   SET   GLOBAL   ` thread _ statistics ` = 1 ;   mysql & gt ;   SHOW   GLOBAL   VARIABLES   LIKE   & quot ; userstat & quot ; ;   + - - - - - - - - - - - - - - - + - - - - - - - +   |   Variable _ name   |   Value   |   + - - - - - - - - - - - - - - - + - - - - - - - +   |   userstat   |   ON   |   + - - - - - - - - - - - - - - - + - - - - - - - +   1   row   in   set   ( 0.00   sec )     查询 客户端 连接 信息 \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . CLIENT _ STATISTICS \\ G   * * * * * * * * * * * * * * * * * * * * * * * * * * *   1 .   row   * * * * * * * * * * * * * * * * * * * * * * * * * * *   CLIENT :   10.1 . 12.30   TOTAL _ CONNECTIONS :   20   CONCURRENT _ CONNECTIONS :   0   CONNECTED _ TIME :   0   BUSY _ TIME :   93   CPU _ TIME :   48   BYTES _ RECEIVED :   5031   BYTES _ SENT :   276926   BINLOG _ BYTES _ WRITTEN :   217   ROWS _ FETCHED :   81   ROWS _ UPDATED :   0   TABLE _ ROWS _ READ :   52836023   SELECT _ COMMANDS :   26   UPDATE _ COMMANDS :   1   OTHER _ COMMANDS :   145   COMMIT _ TRANSACTIONS :   1   ROLLBACK _ TRANSACTIONS :   0   DENIED _ CONNECTIONS :   0   LOST _ CONNECTIONS :   0   ACCESS _ DENIED :   0   EMPTY _ QUERIES :   0   TOTAL _ SSL _ CONNECTIONS :   0     查询 索引 使用 信息 ： \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . INDEX _ STATISTICS   WHERE   TABLE _ NAME = ' tables _ priv ' ;   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +   |   TABLE _ SCHEMA   |   TABLE _ NAME   |   INDEX _ NAME   |   ROWS _ READ   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +   |   mysql   |   tables _ priv   |   PRIMARY   |   2   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - +     查询 表 的 使用 信息 ： \n mysql & gt ;   SELECT   *   FROM   INFORMATION _ SCHEMA . TABLE _ STATISTICS   WHERE   TABLE _ NAME = ` ` tables _ priv ` ` ;   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +   |   TABLE _ SCHEMA   |   TABLE _ NAME   |   ROWS _ READ   |   ROWS _ CHANGED   |   ROWS _ CHANGED _ X _ INDEXES   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +   |   mysql   |   tables _ priv   |   2   |   0   |   0   |   + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + - - - - - - - - - - - + - - - - - - - - - - - - - - + - - - - - - - - - - - - - - - - - - - - - - - - +     具体 详情请 参考 文档 ： https : / / www . percona . com / doc / percona - server / 5.7 / diagnostics / user _ stats . html \n 3 .   check - unused - keys   check - unused - keys   是   Ryan   Lowe   编写 的 基于   userstat   的 一个   perl   脚本 。 能够 比较 方便 输出 需要 删除 的 索引 。 \n 下载 地址 ： https : / / code . google . com / archive / p / check - unused - keys / downloads   /   备份 地址 \n MySQL   设置 ： \n mysql & gt ;   SET   GLOBAL   userstat = ON ;   mysql & gt ;   SET   GLOBAL   ` thread _ statistics ` = 1 ;   mysql & gt ;   SHOW   GLOBAL   VARIABLES   LIKE   & quot ; userstat & quot ; ;   + - - - - - - - - - - - - - - - + - - - - - - - +   |   Variable _ name   |   Value   |   + - - - - - - - - - - - - - - - + - - - - - - - +   |   userstat   |   ON   |   + - - - - - - - - - - - - - - - + - - - - - - - +   1   row   in   set   ( 0.00   sec )     语法 ： \n & gt ;   . / check - unused - keys   - - help     使用 ： \n . / check - unused - keys   - - host = 127.0 . 0.1   - - username = root   - - password = toor   - - port = 3306   - - create - alter     参考 ： \n https : / / www . percona . com / blog / 2009 / 06 / 26 / check - unused - keys - a - tool - to - interact - with - index _ statistics / \n https : / / www . percona . com / blog / 2008 / 09 / 12 / googles - user _ statistics - v2 - port - and - changes / \n https : / / code . google . com / archive / p / check - unused - keys / \n https : / / www . percona . com / blog / 2012 / 12 / 05 / quickly - finding - unused - indexes - and - estimating - their - size / \n https : / / yq . aliyun . com / articles / 308518 \n", "description": "", "tags": ["Mysql", "数据库", "查询优化"], "uri": "/post/db/mysql-sql-index-analyse-tool/", "title": "mysql   查询 优化 ： 索引 优化"}, {"content": "代码 版本 库 使用 git 管理 ， 以下 是 git 版本 使用 规范 \n 流程图 说明   \n 分支 使用 说明         分支 名称   名字   说明   实例           master   线上 分支   不 用于 开发 ， 使用 tag 功能 标记 版本 。 只能 由 beta 和 hotfix 合并 ， 合并 同时 打 上 发布 版本 tag   v1.0 . 2       beta   灰度 分支 组   灰度 分 之 只能 由 test 合并 master 产生 ， 在 测试通过 后 进入 灰度 阶段 产生 ； 灰度 通过 后 合并 进入 master   beta / sign       test ( release )   测试 分支 组   只能 用于 测试 和 修改 bug ， 只能 由 由 master 合并 进 feature 产生 。 对于 测试通过 的 test ， 使用 merge 合并 方式 合并 master 产生 beta 分 之 ； 合并 后 的 release 需要 删除   test / sign ;   release / active       feature   功能 分支 组   从 最新 master 检出 用于 开发 一个 新 功能 ， 一旦 完成 开发 ， 合并 master 进入 下 一个 test ， 删除 本次 feature 分支 ； 负责 开发 中多 开发者 代码 同步 使用   feature / news ;   feature / vote       topic   本地 开发 分支 组   开发人员 基于 feature / release / hotfix 检出 自己 本地 开发 ( 或 修改 bug ) 分支 ， 在 开发 ( 或 修改 bug ) 中 使用 rebase 合并 方式 和 feature / release / hotfix 进行 同步 。 原则上 一个 feature / release / hotfix 分支 对应 一个 topic 分支 ， 开发 完成 的 feature / release / hotfix 删除 对应 的 topic 分支   topic / feature - news - wlp ;   topic / release - new - wlp ;   topic / hotfix - news - wlp       hotfix   修补 分支 组   对于 线上 紧急 bug 修改 ， 产生 一个 hotfix 分支 ， 只能 由 master 上 的 tag 标签 签出 。 修改 完成 的 hotfix 合并 回 master ， 并且 必须 删除   hotfix / v1.0 . 2           注意 ：   1 .   个人 开发 分支 除 特殊 情况 ， 不 允许 提交 到 远程 服务器 中 。 \n   代码 提交 / 合并 说明   这个 是 开发 人 在 日常 开发 中 使用 最多 的 操作 。 \n 获取 代码 库   $   git   clone   & lt ; 版本 库 地址 & gt ;   $   cd   & lt ; 代码 目录 & gt ;   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;     建立 自己 的 本地 开发 分支   $   git   checkout   feature / & lt ; 功能 分支 & gt ;   $   git   checkout   - b   topic / & lt ; 功能 分支 & gt ; - & lt ; 你 的 标识 & gt ;     提交 修改   $   git   status   $   git   add   .   $   git   commit   - am   ' 修改 描述 '     发布 你 的 修改   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;   $   git   rebase   feature / & lt ; 功能 分支 & gt ;   #   这里 可能 会 产生 合并 操作   $   git   push   origin   topic / & lt ; 功能 分支 & gt ; - & lt ; 你 的 标识 & gt ; : feature / & lt ; 功能 分支 & gt ;     代码 发布 说明   发布 代码 是 针对 功能 发布 而定 的 ， 发布 又 分为 测试 发布 和 上线 发布 。 对于 发布 操作 ， 必须 是 先到 测试环境 ( test ) ， 再 从 测试环境 ( test ) 到 灰度 环境 ( beta ) ， 最后 从 灰度 环境 ( beta ) 到 生产 环境 ( master ) ， 对于 线上 每次 发布 都 必须 有 标签 记录 ， 可以 回退 。   原则上 从 beta 到 master 只会 产生   fast - forward   类型 操作 。 以下 所有 操作 都 在 自己 的 开发 分支 中 完成 。 \n 发布 到 测试环境   #   合并 feature 分支   $   git   fetch   origin   master : master   $   git   fetch   origin   feature / & lt ; 功能 分支 & gt ; : feature / & lt ; 功能 分支 & gt ;   $   git   checkout   feature / & lt ; 功能 分支 & gt ;   $   git   merge   master   ~ ~ 解决 冲突 ~ ~   #   生产 test 分支   $   git   checkout   - b   test / & lt ; 功能 分支 & gt ;   $   git   push   origin   test / & lt ; 功能 分支 & gt ; :   test / & lt ; 功能 分支 & gt ;   #   清理 feature 分支   $   git   push   origin   : feature / & lt ; 功能 分支 & gt ;   $   git   branch   - D   feature / & lt ; 功能 分支 & gt ;     发布 到 灰度 环境   #   合并 master 到 测试   $   git   fetch   origin   test / & lt ; 功能 分支 & gt ; : test / & lt ; 功能 分支 & gt ;   $   git   fetch   origin   master : master   $   git   checkout   test / & lt ; 功能 分支 & gt ;   $   git   merge   master   ~ ~ 解决 冲突 ~ ~   #   生成 beta 分支   $   git   checkout   - b   beta / & lt ; 功能 分支 & gt ;   $   git   push   origin   beta / & lt ; 功能 分支 & gt ; : beta / & lt ; 功能 名称 & gt ;   #   清理   test   $   git   push   origin   : test / & lt ; 版本 & gt ;   $   git   branch   - D   test / & lt ; 版本 & gt ;     发布 到 生产 环境   #   合并 到 master   $   git   fetch   origin   beta / & lt ; 版本 & gt ; : beta / & lt ; 版本 & gt ;   $   git   fetch   origin   master : master   $   git   checkout   master   $   git   merge   beta / & lt ; 版本 & gt ;   $   git   tag   - a   & lt ; 发布 版本号 & gt ;   - m   & quot ; 发布 功能 描述 & quot ;   $   git   push   origin   - - tags   $   git   push   origin   master : master   #   清理   beta   $   git   push   origin   : beta / & lt ; 版本 & gt ;   $   git   branch   - D   beta / & lt ; 版本 & gt ;     修改 生产 环境 bug   #   创建 补丁 版本 ， 进行 修改   $   git   fetch   origin   - - tag   $   git   checkout   - b   hotfix / & lt ; 版本号 & gt ;   & lt ; 版本号 & gt ;   #   修改 完成 发布   #   1 .   合并 到 master   $   git   fetch   origin   master : master   $   git   checkout   master   $   git   merge   hotfix / & lt ; 版本号 & gt ;   $   git   tag   - a   & lt ; 发布 版本号 & gt ;   - m   & quot ; 发布 功能 描述 & quot ;   $   git   push   origin   - - tag   $   git   push   origin   master : master   #   清理   hotfix   $   git   push   origin   : hotfix / & lt ; 版本号 & gt ;   $   git   branch   - D   hotfix / & lt ; 版本号 & gt ;  ", "description": "", "tags": ["git"], "uri": "/post/git-branch-flow/", "title": "Git   代码 库分 之 管理"}, {"content": "你 每天 早上 一 醒来 有没有 立即 想 拿 起 手机 赶紧 看 一下 （ facebook 、 twitter 、 微信 ） ， 无论 里面 有没有 信息 都 要 打开 一下 才 安心 ？ 并且 在 上班 之前 还要 想 办法 挤出 时间 看 一下 各大 新闻 网站 ， 查收 邮件 在 各种 邮件 信息 中 找出 今天 需要 处理 的 事情 。 并且 在 工作 的 时候 ， 一 出现 一个 消息 弹框 马上 点击 进去 看 ， 害怕 自己 遗漏 哪怕 一次 消息 。 \n 这些 在 一个 信息 爆炸 的 时代 是 正常 的 ， 被 称为 信息 饥渴 。 其实 出现 这个 情况 是 由于 我们 没有 很 好 获取信息 方式 和 管理 信息 方法 。 这 篇文章 就 介绍 如何 更好 的 利用 网络工具 来 为 我们 管理 信息 。   这里 我 先 把 这些 网络工具 分为 ： \n   信息 产生 工具 \n github 、 facebook 、 twitter 、 rss 博客 、 linkedin 、 微信 服务 号     信息 收集 转换器 \n zapier 、 ifttt 、 smooch 、 feedly 、 pocket 、 buffer     时间 / 任务 / 信息管理 工具 （ GTD ） \n Evernote 、 todoist 、 kanbanflow 、 自己 博客 、 bearychat 、 slack         作为 一个 有 态度 的 程序员 肯定 是从 我 最 爱 的 github 开始 了 ， 我们 在 github 上面 肯定 少不了 有 自己 的 开 源代码 ， 当 有人 给 我们 提交 一个 issue 、 发起 一个 pull   request 等 信息 时 我们 \n github   - - & gt ;   kanbanflow     我 把 看书 作为 一项 任务 来 对待 ， 在 我 看 完一 本书 的 时候 自动 在   Evernote   里面 创建 一个 书评 的 待 完成 的 笔记 ， 并 在   todolist   中 建立 一个 任务 放入 到 待 计划 中 \n kanbanflow   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 facebook 、 twitter 等 社交 工具 中有 新 信息 的 时候 ， 全部 集中 到   slack \n facebook / twitter   - - & gt ;   slack     对于 各种 新闻 信息 进行 快速 过滤 ， 对于 感兴趣 的 放入 到 pocket , 同时 建立 阅读 任务 ； 后面 在 整理 pocket 的 时候 需要 整理 笔记 的 时候 自动 在 Evernote 中 建立 需要 完善 的 整理 笔记 和 相关 todolit 任务 。 \n pocket   - - & gt ;   todoist   pocket   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 自己 关注 的 新闻 、 博客 、 论坛 等 信息 ， 订阅 rss 信息 到 feedly ， 如果 有 信息 时自 在 todolist 建立 阅读 任务 ； 在 阅读 过程 中 需要 整理 笔记 的 时候 自动 在 Evernote 中 建立 需要 完善 的 整理 笔记 和 相关 todolit 任务 。 \n rss / feedly   - - & gt ;   kanbanflow   rss / feedly   - - & gt ;   Evernote   - - & gt ;   kanbanflow     对于 自己 博客 更新 ， 会 自动 同步 到 twitter 、 facebook 等 账户 中 ， 并且 保存 到   Evernote \n 自己 博客   - - & gt ;   facebook   - - & gt ;   twitter   - - & gt ;   Evernote     在 工作 中 我们 会 用到   gitlab 、 jenkins   等 工具 ， 我 把 这些 信息 全都 收集 到   bearychat   中 \n gitlab / jenkins   - - & gt ;   bearychat    ", "description": "", "tags": ["GTD", "时间管理"], "uri": "/post/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/gtd-flow/", "title": "让 网络 更好 为 我们 服务"}, {"content": "  每个 项目管理 中 都 有 自己 的 管理工具 集合 ， 这里 分享 一下 我用 过 的 工具 集合 ， 这 里面 有些 工具 的 实践 时间 可能 并 不是 很 长时间 ， 列 在 这里 意味 这下 一个 阶段 的 实践 计划 。 同时 也 分享 一下 我 自己 在 选择 工具 集合 的 时候 考虑 的 点 ( 关于 每 类 工具 如何 比较 它们 最后 做出 选择 我 后面 会 慢慢 补 上 ) 。 在 这里 不会 详细 介绍 每种 工具 的 安装 、 连接 和 使用 过程 ， 如果 后面 有 时间 我会 专门 写 这些 工具 的 安装 、 配置 和 配合 使用 。   O   首先 列出 我 认为 在 项目管理 中 比较 重要 的 工具 ， 同时 这些 也 是 我 在实践中 用 得 比较 多 的 一套 工具集 ： \n       工具   职责   描述           git     网上 有个 在线教程 很 好 《 pro   git 》 中文版       gerrit   代码 库 服务器 工具 / 代码 审核 工具   基于 git 的 在线 代码 审查 工具 ， 围绕 它 建立 代码 审核 平台 和 流程       gitlab   版本 库 展示 平台   gitlab 这里 只 作为 代码 展示 平台 和 最终 的 发布 代码 库       jenkins   自动化 持续 集成 平台   jenkins 自动测试 / 集成 / 发布 ， 围绕 它 建立 可 持续 集成 平台       redmine   任务 管理 平台 / 缺陷 跟踪 平台         sonar   代码 质量 报告 聚合 工具   围绕 它 搭建 一个 代码 质量 监控 平台         关于 上面 工具 的 安装 过程 不 做 描述 ， 不过 个人 建议 可以 把 每个 服务 都 做成 docker 容器 ， 这样 如果 需要 再次 搭建 环境 就 方便 了 。 \n 下面 对 这套 工具 集合 的 流程 介绍   工具 流程   整理 流程   { %   plantuml   % }   ACTOR   开发人员   control   gerrit   control   jenkins   ACTOR   审核 人员   database   sonar   database   gitlab   control   redmine \n 开发人员 - & gt ; gerrit :   提交 代码 审核   gerrit - & gt ; jenkins :   触发 持续 集成 测试   jenkins - & gt ; jenkins :   执行 集成 测试   jenkins - & gt ; sonar :   收集 代码 质量 报告   gerrit & lt ; - - jenkins :   返回 测试 结果   gerrit - & gt ; 审核 人员 :   通知 人工 审核   gerrit & lt ; - - 审核 人员 :   人工 审核 反馈   gerrit - & gt ; gerrit :   验证 代码 审核 结果 / 代码 合并   gerrit - & gt ; gitlab :   合并 的 代码 提交 到 gitlab   gitlab - & gt ; redmine :   自动更新 redmine 的 缺陷   开发人员 & lt ; - - gerrit :   通知 开发人员 审核 结果     { %   endplantuml   % } \n gerrit 代码 审查 流程   选择 工具 的 思考   首先 要 明确 一点 ： 不论 多么 智能 的 工具 ， 都 是 为 我们 程序员 服务 的 ， 只是 为 我们 提供 一个 更好 工作 的 环境 ， 让 我们 可以 更 愉快 的 coding 。 所以 在 选择 一个 项目 的 基础 平台 环境 时 ， 一定 要 考虑 到 项目 团队 的 人员 情况 。 \n *   平台 工具集 可以 引导 团队 成员 不断 提高 自己   *   方便 团队 任务分配 、 跟踪   *   团队 成员 可以 随时随地 ， 在 自己 想 看 代码 的 时候 方便 得到   *   代码 质量 可视化 、 可 跟踪   *   一切 和 编码 不 相关 的 内容 ， 尽量 自动化   *   可 持续 集成   *   方便 文档 的 编写     同时 在 项目 中 哪些方面 是 需要 引入 工具 的 呢 ？ 这个 答案 在 每 一个 团队 都 会 不 一样 ， 这里 写 一些 我 自己 的 想法 ： \n *   代码 管理 环境   *   任务 / 缺陷 管理 环境   *   自动化 测试 / 持续 集成 环境   *   代码 质量 监控 环境   *   文档 编辑 环境   *   协作 / 沟通 环境   *   集成 开发 环境     下面 我会 对 这 几 方面 的 工具 进行 一个 简单 的 考量 ， 说明 我 自己 在 这方面 的 考虑 点 ， 但是 不会 做 非常 细致 的 比较 ， 原因 有 2 个 ：   1 .   有 很多 工具 我 自己 也 没有 亲身 使用 过 ；   2 .   每个 人 或 团队 对 工具 的 思考 都 会 不同 ， 同时 网上 有 很多 的 关于 它们 比拼 的 文章 ， 最 重要 的 是 自己 的 使用 感受 和 思考 \n 代码 管理 环境   代码 版本 库 的 管理 我 相信 这个 大家 都 会 用 工具 来 管理 （ 如果 你 还 没有 使用 版本 库 管理 或者 还 在 自己 手动 管理 ， 我 只能 呵呵 。 。 。 了 ） 。 对于 不同 的 版本控制 需求 ， 我们 需要 不同 的 管理策略 ， 当然 这个 和 团队 的 协作 方式 有 很大 的 关系 。 同时 现在 的 代码 版本 管理工具 也 很多 ： VSS 、 SVN 、 GIT 、 CVS ( 完全 可以 用 SVN 代替 ) 、 ClearCase 等 。 那 对于 代码 管理 环境 需要 考虑 那些 因素 ：   *   安全性 ( 如果 你 是 开源 的 忠诚 粉丝 ， 可以 完全 忽略 这个 )   *   易用性   *   总体 成本   *   技术支持   *   周边产品 （ 衍生 工具 / 其他 产品 集成 工具 ）   *   是否 离线 操作 （ 这个 这里 作为 考虑 条件 是因为 网络 有时 确实 是 一个 坑 , 不 解释 ）   *   支持 代码 审查 \n 这里 我 主要 比较 了 git 和 svn 。 VSS 支持 平台 有限 （ 感觉 只有 win ） 果断 干掉 （ 我 不好意思 让 兄弟 们 把 mac 换成 win 吧 ， 呵呵 。 。 。 ） ； ClearCase 看到 网上 介绍 感觉 功能 很 强大 的 ， 但是 看 了 一下 价格 果断 干掉 （ 原因 不要 深究 。 。 。 ） 。 \n GIT   git 这个 现在 很火 ， 用 的 人 很多 ， 包括 我 自己 现在 也 是 完全 使用 这个 。 \n   安全性 \n   使用 这个 可以 说 你 的 代码 都 没有 什么 安全性 了 ( 一些 专业 的 git 服务器 除外 ) ， 他 对 安全性 的 控制 你 完全 可以 忽略 。 这个 也 没有 办法 ， 谁 让 他 的 作者 就是 开源 狂热 份子 呢   由于 他们 分布式 管理 方式 ， 任何 一个 开发人员 本地 都 有 一份 完整 的 代码 库 克隆 ， 所以 任何 一个 人员 或 服务器 损坏 了 ， 也 不会 对 开发 有 任何 影响 ， 同时 找 回来 也 是 非常 方便 的 ， 基本 不用 成本     易用性 \n   这个 可能 就要 因 人 而已 了 ， 如果 之前 对 命令行 的 模式 比较 熟悉 ， 那 这个 基本上 就 没有 任何 学习曲线 了 ， 只是 自己 的 命令 集合 里面 多 了 一个 叫 git 的 命令 而已 ； 但是 对于 之前 比较 习惯 图形界面 的 童鞋 就 有 学习 成本 了 ( 实际上 从 我 和 兄弟 们 的 使用 情况 来看 ， 其实 不是 学习 git 命令 花费 时间 ， 而是 要 让 自己 习惯 命令行 工作 方式 ) ， 不过 成本 其实 是 很 低 的 ， 比如 我们 团队 的 兄弟 们 在 一周 之内 都 实用 的 很 溜 了 ( 这里 给 兄弟 们 赞 一个 ) 。   后面 就是 关于 分支 的 管理 、 合并 、 冲突 的 解决 等 协作 方面 的 问题 ， 这个 从 我 个人 的 使用 来看 问题 基本 不 大 ， 只要 把 网上 的 那本 《 pro   git 》 跟着 操作 完成 ， 你 能 需要 遇到 的 问题 基本 OK 了 。   最后 就是 规划 团队 的 代码 管理 流程 了 ， 让 代码 版本 管理 在 团队 不断扩大 、 项目 越来越 多 的 过程 中 不至于 失控   还有 一个 不 经常 会 用到 的 操作 ， 就是 迁移 代码 库 。 这个 对于 git 来说 就 太 容易 了 ， 就是 2 、 3 个 命令 的 事     总体 成本 \n   因为 是 开源 的 ， 所以 从 软件 费用 来说 是 0 成本   剩下 的 就是 我们 自己 搭建 服务器 的 成本 了 ， 如果 感觉 自己 服务器 也 不想 出 ， 那 就 找 网上 的 云 服务 就 好 了 ， 所以 这个 成本 也 是 相对 叫 低 的 了 。 这里 列举 几个 我用 过 的 ： github 、 coding . net 、 Git @ OSC 具体 谁 更 适合 你 ， 都 去 用 一边 就 好 了   最后 就是 团队 的 学习 成本 了 ， 从 我 在 易用性 里面 介绍 ， 我 感觉 一个 团队 学习 的 成本 不会 超过 1 周   同时 git 的 周边产品 大多 都 是 免费 的 或者 提供 免费 版本 ， 所以 他 的 配套 产品成本 其实 很 低     技术支持 \n   开源 的 东西 就 只有 社区 ， 这个 不要 想太多 ， 任何 东西 都 需要 你 自己 去 发现 ， 当然 如果 你 选择 三方 平台 ， 他们 会 有 服务器 平台 部分 支持 的     周边产品 \n   现在 基于 git 的 衍生 产品 太多 了 ， 上面 所 列举 的 都 是 ， 随便 baidu 和 google 都 是 一大 把   其他 平台 对于 git 的 支持 我 个人感觉 很 不错 ， 不论是 IDE 、 持续 集成 环境 、 bug 跟踪 系统 都 有 响应 的 插件 支持 git 版本 库     离线 操作 \n   这个 离线 操作 也 是 我 之前 考虑 使用 它 的 一个 重要 原因 ， 每个 人 只 需要 在 本地 编写 好 、 提交 好 你 的 代码 ， 然后 找 一个 网络 环境 的 地方 ， 把 代码 同步 一下 就 好 了       SVN ( 有 这个 没有 必要 CVS 了 )   svn 现在 用 的 团队 很多 ， 是 一种 集中式 版本 管理工具 ， 我 之前 也 是 用 这个 很长 一段时间 。 \n   安全性 \n   svn 的 目标 就 管理 团队 代码 ， 所以 可以 很 精确 的 控制 每个 人远能 访问 的 权限 ， 目录 分支 等   由于 是 集中式 管理 ， 所以 svn 服务器 千万 不能 挂掉 ， 如果 挂 了 大家 都 不能 工作 了 ， 同时 找回 代码 也 是 一件 费劲 的 事情     易用性 \n   svn 提供 图形化 客户端 ( 非 linux 系统 ) ， 所以 大家 看 一下 就 可以 使用 了   svn 分支 、 合并 、 冲突 解决 都 是 图形化 操作 ， 大家 用 起来 问题 不 大   大家 都 习惯 了 图形操作 的 方式 ， 所以 学习 很快   但是 在 团队 不断 变 大 、 项目 越来越 多 的 时候 ， 对 svn 的 管理 就 需要 有点 技巧 了     总体 成本 \n   svn 软件 本身 是 免费 的 ， 所以 软件 本身 费用 是 0 成本   如果 自己 搭建 服务器 ， 那 就 需要 服务器 成本 了 ， 不过 你 可以 选择 网上 云 服务 ， 如 google 代码 库 （ 国内 的 就 别 想 了 ） 、 svn   china 、 RiouxSVN 等 。 因为 我 自己 以前 只 使用 过 google ， 所以 对 这些 云 服务 需要 自己 去 体验 了   团队 学习 我们 忽略 吧   svn 的 目标 毕竟 是 代替 老牌 的 cvs ， 周边产品 的 支持 那 是 杠杠 的 ， 其他 和 软件开发 相关 的 环境 和 平台 ， 肯定 都 是 支持 svn 的 ， 如果 你 选择 的 基础 环境 工具 中 还有 不 支持 svn 的 ， 那 肯定 是 你 出 问题 了 。 但是 很多 优秀 svn 的 周边产品 都 是 需要 收费 的     技术支持 \n   社区 绝对 是 一个 神奇 的 存在 ， 你 遇到 的 问题 ， 肯定 有人 解决 了 ， 至少 我 当时 是 这样 的   同时 可以 买 专业 的 svn 产品 ， 这样 可以 得到 专业 团队 的 技术支持 ， 当然 这个 成本 肯定 是 有 的     周边产品 \n   刚刚 就 说 了 它 的 目标 是 代替 老牌 的 cvs ， 所以 周边产品 自然 不用说 ， 只是 成本 的 问题     离线 操作 \n   这个 是 我 当时 最 郁闷 的 一点 ， 如果 你 没有 网络 ， 你 就 不能 提交 了 。 很 不好 做 历史记录 管理       git 服务器   这里 只 介绍 git 版本 库 管理 中 其他 的 思考 。 只 介绍 git 是因为 我 现在 使用 的 git ， 其实 是 之前 在 使用 svn 的 时候 没有 考虑 那么 多 ， 自己 也 没有 好好 去 研究 svn 的 一套 体系 。 \n 要 使用 git 作为 团队 代码 管理 ， 就 需要 git 服务器 （ 当然 对 那些 单兵作战 的 兄弟 们 ， 最好 也 有 一个 git 服务器 ， 这样 至少 可以 做到 你 在 哪里 都 可以 作战 ） 。 这里 git 服务器 的 选择 就 有 两种 方式 了 ： 1 、 使用 三方 托管 平台 ； 2 、 自己 搭建 git 服务器 。 这里 主要 讨论 第 2 种 方式 ， 自家 搭建 服务器 。 \n git 是 基于 ssh 的 ， 所以 如果 不要 复杂 功能 只 需要 一个 git - shell 就 可以 是 服务器 了 ， 不过 我们 可 不想 重复 找 轮子 ， 别人 已经 弄 好 的 工具 ， 我们 为什么 不 直接 用 呢 ！ ！ ！ Gitosis 、   Gitolite （ 这个 东西 的 权限 管理 很 不错 ） 等 。 如果 要 高级 功能 的 ( 如 ： web 访问 ) ， 那 gitlab 和 gerrit （ 下载 需要 翻墙 ） 将 是 不二 之选 。 这里 我 同时 选用 了 2 者 ， 它们 的 不同 在于 gerrit 是 一个 更 偏向 代码 审查 工具 和 权限 控制 。 虽然 gitlab 也 可以 做 代码 审查 ， 但是 gerrit 是 做 提交 前 审查 ， 同时 对 代码 权限 的 控制 更细 力度 ； 而 gitlab 是 代码 提交 后 审查 ， 同时 必须 有 开发人员 手动 发起 审查 ， 不能 自动 发起 审查 操作 。 这 导致 他们 两个 的 操作 流程 有 很大 区别 。 我 个人 更 倾向 于 gerrit 的 方式 ， 这样 可以 强迫 大家 把 自己 的 代码 质量 提上去 ， 所以 我 这里 选择 了 两者 结合 ， gerrit 这里 做 权限 和 质量 把 控 ， gitlab 做 为 集成 测试 和 发布 版本 库 。 \n 任务 / 缺陷 管理 环境   缺陷 跟踪 系统 redmine 、 Bugzilla 、 BugZero 、 Trac 、 jira 、 trello 、 bugfree 、 禅道 、 coding . net 等 ， 现在 不论是 收费 的 还是 免费 的 都 有 很多 ， 我 相信 任何 一个 都 能 解决 bug 跟踪 问题 。 从 我 的 使用 过程 中 发现 这些 系统 都 有 各自 的 有点 ， 同时 也 有 很多 不足 的 地方 ， 最终 一个 工具 是不是 符合 你们 团队 ， 只有 试用 过才 知道 。 以下 是 我 在 使用 过程 中 发现 的 一些 特点 ， 感觉 如果 从 这些 点 出发 去 试用 和 思考 一个 系统 或 工具 ， 可以 很快 判断 这个 系统 或 工具 是否 适合 团队 ， 里面 有些 特性 是 我 使用 过 的 工具 里面 都 没有 的 ， 但是 这些 特点 我 感觉 确实 很 有用 ： \n   跨平台 客户端 （ 现在 大多 是 web ， 这个 大部分 都 满足 ）   可以 和 其他 种类 系统集成 （ 如 ： 代码 库 ， 测试 平台 、 持续 集成 环境 等 ）   界面 易 操作性   多 项目管理   自定义 流程   当然 成本 决定 算 一个   系统 更新 速度   支持 多种 开发 模式   分级 统计 功能   移动 端 支持     持续 集成 环境   持续 集成 环境 对 团队 和 项目 的 自动化 有 一定 要求 ， 同时 可以 也 是 对 团队 自动化 的 一种 推进 ； 同时 对 团队 的 开发 流程 和 编码 风格 都 会 有 推动 作用 。 当然 至于 用 什么 工具 那 是 其次 的 ， 总点 是 要 让 团队 养成 持续 集成 的 习惯 和 节奏 。 \n 持续 集成 至 应该 做到 一下 几点 ： \n   自动 构建 ： 要求 无人 值守 ， 如果 人工 来 操作 ， 那 就 没有 持续 集成 的 必要 了   发现 版本 库 的 变更 ： 通过 轮询 或者 定时 ， 或者 程序员 使用 命令 ， 处罚 持续 集成 发现 版本 库 的 变更   反馈 机制 ： 在 出现 问题 时 ， 能 及时 的 把 问题 反馈 给 正确 的 人 （ 提交者 、 测试者 、 管理者 ）   回滚 ： 在 出现 问题 后 ， 拥有 回滚 到 可 交付 的 能力   纯净 的 构建 环境 ： 每 一次 都 应该 把 之前 的 环境 删除 干净 ， 让 每 一次 构建 都 是 一个 新 的 构建   完善 的 集成 功能 ： 代码 的 测试 ， 审查 都 应该 做到 完善 。 如果 单纯 的 利用 它 做 持续 的 编译 ， 那 就是 大材小用 了   为了 避免 每次 过多 出现 问题 的 构建 ， 开发者 在 提交 代码 的 时候 ， 最好 在 本地 独立 的 构建 一次 。 可以 自行 运行 构建 脚本 ， 模拟 构建   由于 数据库 与 编码 的 分离 ， 最好 把 数据库 相关 的 DDL \\ DML 等 脚本 一起 放入 版本 库中 ， 这样 CI 进行 构建 的 时候 ， 可以 连同 数据库 一起 重新 构建   能 和 我们 的 代码 管理 库 、 任务 / 缺陷 跟踪 等 其他 平台 交互     推荐 书籍 《 持续 集成 ： 软件 质量 改进 和 风险 降低 之道 》 \n 集成 工具 ： jenkins （ 前身 是 Hudson ） 、 gitlab - ci 、 Apache   Continuum 、 CruiseControl 、 Luntbuild 、 drone 、 shippable \n 集成 的 配置 是 必不可少 的 ， 就是 让 你 定义 如何 集成 构建 的 构建 脚本 啦 ， 如果 没有 一个 可 配置 的 构建 过程 ， 那 持续 集成 从何说起 呢 。 ant 、 maven 、 gradle 、 make 、 shell \n 由于 集成 是 基于 测试 之上 的 ， 所以 一个 好 的 测试工具 比 不可 少 ， 但是 这个 和 团队 使用 的 语言 息息相关 ， 每中 语言 都 有 自己 的 测试工具 。 简单 举例 已 达到 抛砖引玉 的 效果 ： 各种 Unit （ Junit ， HtmlUnit ， cppUnit ， SQLUnit 等 ） 、 karma 、 mocha 。 。 。 （ 手软 & gt ; _& lt ; ） \n 自动 代码 审查 是 提高 代码 质量 ， 养成 代码 习惯 比可少 的 ， 同时 这些 事情 可以 自动 的 做 掉 ， 可以 让 我们 更加 关注 于 我们 的 代码   checkstyle 、 javaNcss 、 PMD 、 siminan 、 jsHint 、 jsLint 、 Emma 。 。 。 \n 集成 反馈 和 报告 这个 可以 让 我们 可以 实时 得到 集成 结果 ， 失败 快速 找 原因 ， 成功 我们 就 可以 安心 睡觉 了 。 邮件 通知 、 Jabber 、 JSCoverage 、 GCOV 、 python   coverage 、 JCoverage 、 Cobertura 。 。 。 \n 代码 质量 监控 环境   代码 质量 监控 平台 其实 就是 让 我们 的 代码 质量 可视化 、 可 管理 ， 让 我们 的 代码 质量 形成 历史记录 。 同时 可以 非常 方便 的 工 全部 人员 查看 。 \n   质量 可视化   跟踪 质量 走向 （ 需要 历史记录 ）   可以 自动 从 持续 集成 环境 、 代码 审查 中 搜集 质量 信息   可以 和 代码 管理 环境 打通 ， 这个 的 目的 是 最好 能 看到 每个 人 代码 质量   可以 和 其他 工程 管理工具 打通     SonarQube 、 前面 介绍 的 自动 代码 审查 工具 \n 文档 编辑 环境   我们 的 程序员 往往 都 不 喜欢 写 文档 ， 你 让 他 写 文档 ， 还 不如 让 他 写 2 倍 的 代码 。 但是 文档 确是 我们 项目 中 不可 缺少 的 部分 ， 那 怎么 让 我们 的 程序员 可以 高效 的 写 文档 呢 ！ 其实 我们 程序员 在 写 文档 的 时候 ， 往往 是 被 文档 的 格式 所 折磨 ， 不能 专心 的 写 内容 ， 从而 出发 对 写 文档 的 抵触情绪 。 所以 结合 以上 我 任务 文档 编写 环境 应该 有 一下 几点 ： \n   不用 关心 格式 ， 重点 在 内容 ， 格式 自动   能 从 代码 中 自动 生成 文档   文档 能 实时 共享 、 自动 共享 ， 像 现在 用 的 邮件 、 QQ 之类 的 其实 很 影响 心情   文档 格式 足够 简单 ， 在 写 的 时候 要 做到 双手 不 脱离 键盘 最好     markdown 、 各种 语言 doc 工具 了 （ jsdoc 、 javadoc 等 ） 、 wiki 、 shpinx \n 沟通 环境   上面 所说 的 说 有 东西 的 最终 目的 其实 都 是 为了 解决 我们 协作 的 问题 ， 至少 是 或多或少 都 会 涉及 到 协作 沟通 问题 。 像 现在 大家 用 的 最 多 的 沟通 工具 应该 变成 QQ 、 微信 之类 的 了 吧 ， 加上 邮件 、 电话 、 各种 协作 平台 或者 其他 通讯 工具 ， 但是 这些 工具 都 有 一个 特点 ： 在 使用 的 时候 都 会 有 一个 长时间 打断 我们 思维 ， 或者 需要 我们 专门 准备 一个 时间 去 做 ； 这些 其实 都 会 造成 浪费 。 其实 最 有效 的 沟通 就是 面对面 交流 ， 所以 构建 一个 良好 的 沟通 环境 ， 对 我们 的 项目 进度 起着 至关重要 的 作用 ： \n   沟通 资源 随手 可 得 （ 易于 获得 ） ， 可以 在 30 秒 内 获得   兄弟 们 可以 采取 自己 认为 高效 的 方式 沟通 ， 同时 沟通 方式 的 资源 易于 获得   沟通 历史 和 结果 易于 记录 ， 最好 能 在 不 察觉 的 情况 下 记录 起来     项目 开发 环境   项目 开发 环境 可以 分为 ： 工程 管理工具 和 工程 开发工具 。 项目 开发 环境 每个 团队 都 有 差别 ， 同时 团队 内部 每个 人 肯定 都 有 差异 ， 因为 它 受到 的 影响 因 数最多 ， 比如 ： 使用 语言 ， 工作 内容 ， 个人 习惯 ， 操作系统 ， 可能 还 和 心情 有关 等 。 因此 团队 在 选择 项目 开发 环境 的 时候 ， 既 要 根据 团队 的 定位 选定 基础 开发 环境 （ 工程 管理工具 ） ， 同时 出 一些 选择 辅助 开发 环境 的 选择 指导 规则 ； 也 要 考虑 每个 成员 的 习惯 ， 开放 出来 辅助 开发 环境 ， 让 每个 成员 可以 根据 自己 的 习惯 ， 选择 一套 他 自己 最 高效 的 项目 开发 环境 集合 。 下面 我 列举 我 认为 在 选择 工程 管理工具 和 工程 开发工具 应该 具备 的 几点 特征 ： \n 工程 管理工具     可以 和 工程 开发工具 高效 集成   可以 测试   可以 做 质量检查   可以 和 质量 管理系统 集成     ant ， maven ， gradle ， gulp ， grunt ， make ， cmake 。 。 。 \n 项目 开发工具   项目 开发工具 也 叫做 集成 开发 环境 ， 很多 集成 开发 环境 都 带有 自己 的 工程 管理工具 \n   可以 和 代码 管理工具 集成   测试 必须   可以 做 本地 质量检查   可以 方便 实现 重构 手法 ， 关于 重构 推荐 《 重构 ： 改变 既有 代码 设计 》   最好 能 和 缺陷 跟踪 系统集成   可以 和 工程 管理工具 集成     eclipse 、 webstorm 、 vs 、 idea 等 \n 需求 / 产品 管理 环境   对于 需求 / 产品 管理 环境 我 自己 现在 还 没有 在 具体 项目 中 实践 过 ， 所以 这里 就 不 在 阐述 了 ， 如果 你 有 好 的 想法 可以 给 我 留言 ， 或者 给 我 连接 地址 ， 我 连接 过去 \n 测试 管理 环境   测试 管理 环境 其实 应该 在 持续 集成 环境 里面 ， 但是 由于 上面 写 持续 集成 环境 的 时候 过于 偏向 开发人员 的 使用 角度 介绍 了 ， 并且 这 两套 系统 确实 也 是 独立 存在 的 。 这个 测试 管理 环境 更 多 面向 于 测试人员 ， 而 我 认为 测试工具 本身 也 是 分为 测试 管理工具 和 测试 执行 工具 两 类别 ， 所以 我会 从 测试 管理 和 测试 执行 两个 方面 来说 我 观点 （ 这里 的 划分 是 按照 工具 的 分类 划分 ， 并 不是 按照 软件 方法 的 方式 划分 ） ， 同时 对于 测试 我 想 后面 会 有 专门 的 一篇 文章 来 介绍 ， 所以 这里 就 这样 了 ， 大家 见谅 我 的 不 专业 \n 测试 管理工具   测试 管理 我 认为 比较 重要 的 是 ： 测试计划 ， 测试用例 ， 测试 跟踪 ， 缺陷 管理 ( 这个 和 任务 / 缺陷 管理 环境 一样 ) \n   可以 管理 测试计划   可以 管理 测试用例   可以 跟踪 每个 测试用例 的 状态   可以 和 缺陷 系统集成   可以 和 持续 集成 系统集成     QC ( Quality   Center ) ， TestLink ， oKit ， TD （ TestDirector ） 上面 提到 的 缺陷 管理系统 \n 测试 执行 工具   测试 执行 的 方式 都 很多 了 ， 并且 测试 执行 种类 也 很多 ， 比如 ： 自动化 测试 ， 性能 测试 ， 安全 测试 ， 白盒 测试 等 。 这 里面 不同 的 测试 方式 所 使用 的 工具 都 是 不 一样 的 ： \n selenium ， jmeter ， jprofile ， Wireshark ， AppCan ， Metasploit ， Nmap ， Acunetix ， Burp   Suite ， apache   ab ， Gatling \n 还是 那句话 工具 只能 给 我们 提供 一个 更 专心 、 更 快速 做事 的 环境 ， 但是 最终 这个 事情 能 不能 做成 、 能 不能 做好 完全 是 取决 我们 自己 。 所以 不论 使用 任何 工具 都行 ， 前提 是 我们 有 自己 提高 的 意识 和 习惯 ， 比如 ： 编码 风格 、 编程 习惯 、 测试 习惯 、 重构 习惯 、 沟通 能力 、 协作 能力 等 ， 这些 才 是 真真 决定 项目 成败 的 关键 。 \n", "description": "", "tags": ["jenkins", "gerrit", "gitlab", "redmine", "CI/CD"], "uri": "/post/ci-cd-tool/", "title": "项目 持续 集成 工具"}, {"content": "现代 前端开发 中 css3 已经 是 不可 其他 的 一部分 ， 早已 成为 每个 web 开发人员 必备 技能 之一 。   而 选择器 又 是 css 中 最 基础 、 最 重要 的 知识点 ， 对于 我们 页面 结构 和 代码 接口 都 有着 举足轻重 的 作用 。   今天 我们 就 来 看看 css3 所 支持 的 和 新增 的 选择器 。 \n \n 1 .   CSS1 定义 的 选择器         选择器   类型   说明           E   类型 选择器   选择 指定 类型 的 元素       E # id   ID 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 的 id 为 “ id ” ， E 选择符 可以 省略 。       E . class   类 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 的 class 属性 值为 “ class ” ， E 选择符 可以 省略 。       E   F   包含 选择器   选择 匹配 F 的 元素 ， 且 该 元素 被 包含 在 匹配 E 的 元素 内 。       E : link   链接 伪类 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 定义 了 超链接 并未 被 访问 。 例 ： a : link 、 # a _ id : link       E : visited   链接 伪类 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 定义 了 超链接 并 已 被 访问 。 例 ： a : visited       E : active   用户 操作 伪类 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 被 激活       E : hover   用户 操作 伪类 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 正 被 鼠标 经过       E : focus   用户 操作 伪类 选择器   选择 匹配 E 的 元素 ， 且 匹配 元素 获取 了 焦点       E : first - line   伪 元素 选择器   选择 匹配 E 元素 内 的 第一行 文本       E : first - letter   伪 元素 选择器   选择 匹配 E 元素 内 的 第一个 字符         2 .   CSS2 定义 的 选择器         选择器   类型   说明           *   通配 选择器   选择 文档 中 所有 元素       E [ foo ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 。 E 选择符 可以 省略 ， 表示 选择 定义 了 foo 属性 的 任意 类型 的 元素 。       E [ foo = & ldquo ; bar & rdquo ; ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 foo 属性 值为 “ bar ”       E [ foo ~ = & ldquo ; bar & rdquo ; ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 是 一个 以 空格符 分隔 的 列表 ， 其中 一个 列表 的 值 为 “ bar ” ， E 选择符 可以 省略 。       E [ foo ! = & ldquo ; en & rdquo ; ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 是 一个 用 连 字符 （ - ） 分隔 的 列表 ， 值以 “ en ” 开头 。       E : first - child   结构 伪类 选择器   选择 匹配 E 的 元素 ， 且 该 元素 为父 元素 的 第一个 子 元素       E : before   伪 元素 选择器   在 匹配 E 的 元素 前面 插入 内容       E : after   伪 元素 选择器   在 匹配 E 的 元素 后面 插入 内容       E   & gt ;   F   子 包含 选择器   选择 匹配 F 的 元素 ， 且 该 元素 为 所 匹配 E 元素 的 子 元素 。       E   +   F   相邻 兄弟 选择器   选择 匹配 F 的 元素 ， 且 该 元素 为 所 匹配 E 元素 后面 相邻 的 位置 。       E : lang ( language )   语言 选择器   例如 ： p : lang ( it )   选择 带有 以   & ldquo ; it & rdquo ;   开头 的   lang   属性 值 的 每个     元素 。         3 .   CSS3 新增 属性 选择器         选择器   类型   说明           E [ foo ^ = & ldquo ; bar & rdquo ; ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值以 “ bar ” 开始 。 E 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E [ foo $ = & ldquo ; bar & rdquo ; ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值以 “ bar ” 结束 。 E 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E [ foo * = & ldquo ; bar & rdquo ; ]   属性 选择器   选择 匹配 E 的 元素 ， 且 该 元素 定义 了 foo 属性 ， foo 属性 值 包含 “ bar ” 。 E 选择符 可以 省略 ， 表示 可 匹配 任意 类型 的 元素 。       E : root   结构 伪类 选择器   选择 匹配 E 所在 文档 的 根 元素 。 在 （ X ） HTML 文档 中 ， 根 元素 就是 html 元素 ， 此时 该 选择器 与 html 类型 选择器 匹配 的 内容 相同 。       E : nth - child ( n )   结构 伪类 选择器   选择 所有 在 其父 元素 中 第 n 个 位置 的 匹配 E 的 子 元素 。 \n 注意 ， 参数 n 可以 是 数字 （ 1 、 2 、 3 ） 、 关键字 （ odd 、 even ） 、 公式 （ 2n 、 2n + 3 ） 参数 的 索引 从 1 开始 。 \n tr : nth - child ( 3 ) 匹配 所有 表格 中 第 3 排 的 tr ； \n tr : nth - child ( 2n + 1 ) 匹配 所有 表格 的 奇数 行 ； \n tr : nth - child ( 2n ) 匹配 所有 表格 的 偶数 行 ； \n tr : nth - child ( odd ) 匹配 所有 表格 的 奇数 行 ； \n tr : nth - child ( even ) 匹配 所有 表格 的 偶数 行 ；       E : nth - last - child ( n )   结构 伪类 选择器   选择 所有 在 其父 元素 中 倒数第 n 个 位置 的 匹配 E 的 子 元素       E : nth - of - type ( n )   结构 伪类 选择器   选择 父 元素 中 第 n 个 位置 ， 且 匹配 E 的 子 元素 。 \n 注意 ， 所有 匹配 E 的 子 元素 被 分离出来 单独 排序 。 非 E 的 子 元素 不 参与 排序 。 参数 n 可以 是 数字 ， 关键字 、 公式 。 \n 例 ： p : nth - of - type ( 1 )       E : nth - last - of - type ( n )   结构 伪类 选择器   选择 父 元素 中 倒数第 n 个 位置 ， 且 匹配 E 的 子 元素 。       E : last - child   结构 伪类 选择器   选择 位于 其父 元素 中 最后 一个 位置 ， 且 匹配 E 的 子 元素 。       E : first - of - type   结构 伪类 选择器   选择 位于 其父 元素 中且 匹配 E 的 第一个 同 类型 的 子 元素 。 \n 该 选择器 的 功能 类似 于   E : nth - of - type ( 1 )       E : last - of - type   结构 伪类 选择器   选择 位于 其父 元素 中且 匹配 E 的 最后 第一个 同 类型 的 子 元素 。 \n 该 选择器 的 功能 类似 于   E : nth - last - of - type ( 1 )       E : only - child   结构 伪类 选择器   选择 其父 元素 只 包含 一个 子 元素 ， 且 该子 元素 匹配 E 。       E : only - of - type   结构 伪类 选择器   选择 其父 元素 只 包含 一个 同 类型 的 子 元素 ， 且 该子 元素 匹配 E 。       E : empty   结构 伪类 选择器   选择 匹配 E 的 元素 ， 且 该 元素 不 包含 子 节点       E : enabled   UI 状态 伪类 选择器   选择 匹配 E 的 所有 可用 UI 元素 。       E : disabled   UI 状态 伪类 选择器   选择 匹配 E 的 所有 不可 用 UI 元素 。       E : checked   UI 状态 伪类 选择器   选择 匹配 E 的 所有 可用 UI 元素 。 \n 例 ： input : checked 匹配 input   type 为 radio 及 checkbox 元素       : : selection   UI 状态 伪类 选择器   选择 被 用户 选取 的 元素 部分 。       E   ~   F   相邻 兄弟 选择器   选择 匹配 F 的 所有 元素 ， 且 匹配 元素 位于 匹配 E 的 元素 后面 。 在 DOM 结构 树中 ， E 和 F 所 匹配 的 元素 应该 在 同 一级 结构 上 。       E : not ( s )   否定 伪类 选择器   选择 匹配 E 的 所有 元素 ， 且 过滤 掉 匹配 s 选择符 的 任意 元素 。 s 是 一个 简单 结构 的 选择器 ， 不能 使用 符合 选择器 ，       E : target   目标 伪类 选择器   选择 匹配 E 的 所有 元素 ， 且 匹配 元素 被 相关 URL 指向 。 \n 注意 ： 该 选择器 是 动态 选择器 ， 只有 存在 URL 指向 该 匹配 元素 时 ， 样式 才 起 效果 。 \n 例 ： demo . html # id         参考 ： http : / / www . w3school . com . cn / cssref / css _ selectors . asp \n", "description": "", "tags": ["css3"], "uri": "/post/web/css3-added-selector/", "title": "CSS3   新增 选择器"}, {"content": "  Threeq   -   出井 的 青蛙  ", "description": "不能 再 简单 的 介绍", "tags": [], "uri": "/about/", "title": "关于   Threeq   -   出井 的 青蛙"}, {"content": "", "description": "", "tags": [], "uri": "/categories/", "title": "Categories"}, {"content": "", "description": "", "tags": [], "uri": "/tags/ci/cd/", "title": "Ci / Cd"}, {"content": "", "description": "", "tags": [], "uri": "/tags/css3/", "title": "Css3"}, {"content": "", "description": "", "tags": [], "uri": "/tags/gerrit/", "title": "Gerrit"}, {"content": "", "description": "", "tags": [], "uri": "/tags/git/", "title": "Git"}, {"content": "", "description": "", "tags": [], "uri": "/tags/gitlab/", "title": "Gitlab"}, {"content": "", "description": "", "tags": [], "uri": "/tags/gtd/", "title": "Gtd"}, {"content": "", "description": "", "tags": [], "uri": "/tags/jenkins/", "title": "Jenkins"}, {"content": "", "description": "", "tags": [], "uri": "/tags/mysql/", "title": "Mysql"}, {"content": "", "description": "", "tags": [], "uri": "/tags/percona/", "title": "Percona"}, {"content": "", "description": "", "tags": [], "uri": "/post/", "title": "Posts"}, {"content": "", "description": "", "tags": [], "uri": "/tags/pt-query-digest/", "title": "Pt   Query   Digest"}, {"content": "", "description": "", "tags": [], "uri": "/tags/redmine/", "title": "Redmine"}, {"content": "", "description": "", "tags": [], "uri": "/tags/", "title": "Tags"}, {"content": "", "description": "", "tags": [], "uri": "/", "title": "Threeq   -   出井 的 青蛙"}, {"content": "", "description": "", "tags": [], "uri": "/categories/web/", "title": "Web"}, {"content": "", "description": "", "tags": [], "uri": "/categories/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/", "title": "个人 管理"}, {"content": "", "description": "", "tags": [], "uri": "/categories/%E5%B7%A5%E5%85%B7/", "title": "工具"}, {"content": "", "description": "", "tags": [], "uri": "/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/", "title": "数据库"}, {"content": "", "description": "", "tags": [], "uri": "/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/", "title": "数据库"}, {"content": "", "description": "", "tags": [], "uri": "/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/", "title": "时间 管理"}, {"content": "", "description": "", "tags": [], "uri": "/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/", "title": "查询 优化"}]