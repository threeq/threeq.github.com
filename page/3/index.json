[
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/09-exception/",
	"title": "Python学习 09：异常处理",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "这次学习 python 中函数的基础知识\n 标准异常 异常不做 手动抛出异常 自定义异常  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。\n 异常处理: 本站Python教程会具体介绍。 断言(Assertions):本站Python教程会具体介绍。  什么是异常？ 其实已经在前面遇见过异常了，比如：使用一个没有定义的变量，就会产生一个名字错误的异常；将一个字符串对象和数值对象相加，就会产生类型错误异常。\n什么是异常？异常是程序在执行时发生的事件，它会打断指令的正常流程。 发生一个异常时，表示发生了一个 python 自身无法处理的一个错误。\n异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。\n一般情况下，在Python无法正常处理程序时就会发生一个异常。\n异常是Python对象，表示一个错误。\n当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。\n简单理解就是程序发生了我们意料之外的错误，发生异常的情况很多，比如网络失败、磁盘文件失败、使用了2个不同类型的对象做运算等。并且大部分是编码时不可预知是否会发生，这和代码当时运行环境有很大关联，有可能发生，也有可能不会发生。\npython标准异常 python 已经内置了很多标准的异常类。\n   异常名称 描述         BaseException 所有异常的基类   SystemExit 解释器请求退出   KeyboardInterrupt 用户中断执行(通常是输入^C)   Exception 常规错误的基类   StopIteration 迭代器没有更多的值   GeneratorExit 生成器(generator)发生异常来通知退出   StandardError 所有的内建标准异常的基类   ArithmeticError 所有数值计算错误的基类   FloatingPointError 浮点计算错误   OverflowError 数值运算超出最大限制   ZeroDivisionError 除(或取模)零 (所有数据类型)   AssertionError 断言语句失败   AttributeError 对象没有这个属性   EOFError 没有内建输入,到达EOF 标记   EnvironmentError 操作系统错误的基类   IOError 输入/输出操作失败   OSError 操作系统错误   WindowsError 系统调用失败   ImportError 导入模块/对象失败   LookupError 无效数据查询的基类   IndexError 序列中没有此索引(index)   KeyError 映射中没有这个键   MemoryError 内存溢出错误(对于Python 解释器不是致命的)   NameError 未声明/初始化对象 (没有属性)   UnboundLocalError 访问未初始化的本地变量   ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象   RuntimeError 一般的运行时错误   NotImplementedError 尚未实现的方法   SyntaxError Python 语法错误   IndentationError 缩进错误   TabError Tab 和空格混用   SystemError 一般的解释器系统错误   TypeError 对类型无效的操作   ValueError 传入无效的参数   UnicodeError Unicode 相关的错误   UnicodeDecodeError Unicode 解码时的错误   UnicodeEncodeError Unicode 编码时错误   UnicodeTranslateError Unicode 转换时错误   Warning 警告的基类   DeprecationWarning 关于被弃用的特征的警告   FutureWarning 关于构造将来语义会有改变的警告   OverflowWarning 旧的关于自动提升为长整型(long)的警告   PendingDeprecationWarning 关于特性将会被废弃的警告   RuntimeWarning 可疑的运行时行为(runtime behavior)的警告   SyntaxWarning 可疑的语法的警告   UserWarning 用户代码生成的警告    异常捕捉 捕捉异常可以使用try/except语句。\ntry/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。\n如果你不想在异常发生时结束你的程序，只需在try里捕获它。\n语法：\ntry: \u0026lt;语句\u0026gt; #运行别的代码 except \u0026lt;名字\u0026gt;： \u0026lt;语句\u0026gt; #如果在try部份引发了'name'异常 except \u0026lt;名字\u0026gt;，\u0026lt;数据\u0026gt;: \u0026lt;语句\u0026gt; #如果引发了'name'异常，获得附加的数据 else: \u0026lt;语句\u0026gt; #如果没有异常发生  try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。\n 如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。 如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。 如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。  实例：\nIn[1]: \u0026nbsp;  \u0026quot;a\u0026quot;+1    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-1-e29823995ef5\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0;34m\u0026#34;a\u0026#34;\u001b[0m\u001b[0;34m\u0026#43;\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: must be str, not int   In[2]: \u0026nbsp;  # 处理异常 try: \u0026quot;a\u0026quot;+1 except NameError: print(\u0026quot;未定义变量处理\u0026quot;) print(e) except TypeError as e: print(\u0026quot;类型错误\u0026quot;) print(e)    执行结果： 类型错误 must be str, not int    语法错误 Python 的语法错误或者称之为解析错，是初学者经常碰到的，如下实例 In[3]: \u0026nbsp;  while True print('Hello world')    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-3-2b688bc740d7\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m1\u001b[0m \u001b[0;31m while True print(\u0026#39;Hello world\u0026#39;)\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax    使用except而不带任何异常类型 你可以不带任何异常类型使用except，如下实例：\ntry: 正常的操作 ...................... except: 发生异常，执行这块代码 ...................... else: 如果没有异常执行这块代码 以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。  使用except而带多种异常类型 你也可以使用相同的except语句来处理多个异常信息，如下所示：\ntry: 正常的操作 ...................... except(Exception1[, Exception2[,...ExceptionN]]]): 发生以上多个异常中的一个，执行这块代码 ...................... else: 如果没有异常执行这块代码  try-finally 语句 try-finally 语句无论是否发生异常都将执行最后的代码。\ntry: \u0026lt;语句\u0026gt; finally: \u0026lt;语句\u0026gt; #退出try时总会执行  In[4]: \u0026nbsp;  try: fh = open(\u0026quot;testfile\u0026quot;, \u0026quot;w\u0026quot;) fh.write(\u0026quot;这是一个测试文件，用于测试异常!!\u0026quot;) finally: print(\u0026quot;Error: 没有找到文件或读取文件失败\u0026quot;)    执行结果： Error: 没有找到文件或读取文件失败    In[5]: \u0026nbsp;  try: fh = open(\u0026quot;testfile\u0026quot;, \u0026quot;w\u0026quot;) try: fh.write(\u0026quot;这是一个测试文件，用于测试异常!!\u0026quot;) finally: print (\u0026quot;关闭文件\u0026quot;) fh.close() except IOError: print (\u0026quot;Error: 没有找到文件或读取文件失败\u0026quot;)    执行结果： 关闭文件    当在try块中抛出一个异常，立即执行finally块代码。\nfinally块中的所有语句执行后，异常被再次触发，并执行except块代码。\n参数的内容不同于异常。\nIn[6]: \u0026nbsp;  try: f = open('myfile.txt') s = f.readline() i = int(s.strip()) except OSError as err: print(\u0026quot;OS error: {0}\u0026quot;.format(err)) except ValueError: print(\u0026quot;Could not convert data to an integer.\u0026quot;) except: print(\u0026quot;Unexpected error:\u0026quot;, sys.exc_info()[0]) raise    执行结果： OS error: [Errno 2] No such file or directory: \u0026#39;myfile.txt\u0026#39;    raise 触发异常 可以使用raise语句自己触发异常 In[7]: \u0026nbsp;  raise Exception(\u0026quot;Invalid level!\u0026quot;)    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mException\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-7-4b6d1cc080ee\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0;32mraise\u001b[0m \u001b[0mException\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#34;Invalid level!\u0026#34;\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mException\u001b[0m: Invalid level!   自定义异常 通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。\n以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。\n在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。\nIn[13]: \u0026nbsp;  # 自定义异常 class Networkerror(RuntimeError): def __init__(self, arg): print(\u0026quot;arg: \u0026quot;+ arg) self.args = arg # 使用异常 try: raise Networkerror(\u0026quot;Bad hostname\u0026quot;) except Networkerror as e: print(e.args)    执行结果： arg: Bad hostname (\u0026#39;B\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;)    默认异常处理\n处理后始终执行操作\nIn[14]: \u0026nbsp;  try: raise Networkerror(\u0026quot;Bad hostname\u0026quot;) except Networkerror as e: print(e.args) except: print(\u0026quot;default process\u0026quot;) finally: print(\u0026quot;almost execute\u0026quot;) print(\u0026quot;almost execute2\u0026quot;)    执行结果： arg: Bad hostname (\u0026#39;B\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;e\u0026#39;) almost execute almost execute2    预定义的清理行为 一些对象定义了标准的清理行为，无论系统是否成功的使用了它，一旦不需要它了，那么这个标准的清理行为就会执行。\n这面这个例子展示了尝试打开一个文件，然后把内容打印到屏幕上:\nfor line in open(\u0026quot;myfile.txt\u0026quot;): print(line, end=\u0026quot;\u0026quot;)  以上这段代码的问题是，当执行完毕后，文件会保持打开状态，并没有被关闭。\n关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行他的清理方法:\nwith open(\u0026quot;myfile.txt\u0026quot;) as f: for line in f: print(line, end=\u0026quot;\u0026quot;)  以上这段代码执行完毕后，就算在处理过程中出问题了，文件 f 总是会关闭。\n$(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/08-class/",
	"title": "Python学习 08：面向对象编程",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "这次学习 python 中函数的基础知识\n 类 方法和属性 继承和多重继承 运算符重载  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本节我们将介绍Python的面向对象编程。\n如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。\n接下来我们先来简单的了解下面向对象的一些基本特征。\n面向对象技术简介  类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 方法：类中定义的函数。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟\u0026rdquo;是一个（is-a）\u0026rdquo;关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。  和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。\nPython中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。\n对象可以包含任意数量和类型的数据。\n类定义 语法格式如下：\nclass ClassName: \u0026lt;statement-1\u0026gt; . . . \u0026lt;statement-N\u0026gt;  类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。\n类对象 类对象支持两种操作：属性引用和实例化。\n属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。\n类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:\nIn[14]: \u0026nbsp;  class MyClass: \u0026quot;\u0026quot;\u0026quot;一个简单的类实例\u0026quot;\u0026quot;\u0026quot; i = 12345 # 所有实例共享数据 def f(self): self.j = 54321 return 'hello world' # 每个实例数据 # 实例化类 x = MyClass() # 访问类的属性和方法 print(\u0026quot;MyClass 类的属性 i 为：\u0026quot;, x.i) print(\u0026quot;MyClass 类的方法 f 输出为：\u0026quot;, x.f())    执行结果： MyClass 类的属性 i 为： 12345 MyClass 类的方法 f 输出为： hello world    In[3]: \u0026nbsp;  class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) print(x.r, x.i) # 输出结果：3.0 -4.5    执行结果： 3.0 -4.5    In[4]: \u0026nbsp;  class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt()    执行结果： \u0026lt;__main__.Test object at 0x7f3b644556a0\u0026gt; \u0026lt;class \u0026#39;__main__.Test\u0026#39;\u0026gt;    In[5]: \u0026nbsp;  class Test: def prt(runoob): print(runoob) print(runoob.__class__) t = Test() t.prt()    执行结果： \u0026lt;__main__.Test object at 0x7f3b64455a90\u0026gt; \u0026lt;class \u0026#39;__main__.Test\u0026#39;\u0026gt;    In[6]: \u0026nbsp;  #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\u0026quot;%s 说: 我 %d 岁。\u0026quot; %(self.name,self.age)) # 实例化类 p = people('runoob',10,30) p.speak()    执行结果： runoob 说: 我 10 岁。    继承 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:\nclass DerivedClassName(BaseClassName1): \u0026lt;statement-1\u0026gt; . . . \u0026lt;statement-N\u0026gt;  需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。\nBaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:\nIn[7]: \u0026nbsp;  #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\u0026quot;%s 说: 我 %d 岁。\u0026quot; %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\u0026quot;%s 说: 我 %d 岁了，我在读 %d 年级\u0026quot;%(self.name,self.age,self.grade)) s = student('ken',10,60,3) s.speak()    执行结果： ken 说: 我 10 岁了，我在读 3 年级    多重继承 Python同样有限的支持多继承形式。多继承的类定义形如下例:\nclass DerivedClassName(Base1, Base2, Base3): \u0026lt;statement-1\u0026gt; . . . \u0026lt;statement-N\u0026gt;  需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。\nIn[8]: \u0026nbsp;  #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\u0026quot;%s 说: 我 %d 岁。\u0026quot; %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\u0026quot;%s 说: 我 %d 岁了，我在读 %d 年级\u0026quot;%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备 class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\u0026quot;我叫 %s，我是一个演说家，我演讲的主题是 %s\u0026quot;%(self.name,self.topic)) #多重继承 class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\u0026quot;Tim\u0026quot;,25,80,4,\u0026quot;Python\u0026quot;) test.speak() #方法名同，默认调用的是在括号中排前地父类的方法    执行结果： 我叫 Tim，我是一个演说家，我演讲的主题是 Python    方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： In[9]: \u0026nbsp;  class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法    执行结果： 调用子类方法 调用父类方法    super() 函数是用于调用父类(超类)的一个方法。 类属性与方法 类的私有属性 private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.private_attrs。\n类的方法 在类地内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。\nself 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。\n类的私有方法 private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类地外部调用。self.private_methods。\n实例 类的私有属性实例如下：\nIn[11]: \u0026nbsp;  class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount) counter = JustCounter() counter.count() counter.count() print (counter.publicCount) print (counter.__secretCount) # 报错，实例不能访问私有变量    执行结果： 1 2 2 \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mAttributeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-11-eb413b755b77\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 12\u001b[0m \u001b[0mcounter\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcount\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 13\u001b[0m \u001b[0mprint\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mcounter\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpublicCount\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m---\u0026gt; 14\u001b[0;31m \u001b[0mprint\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mcounter\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__secretCount\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# 报错，实例不能访问私有变量\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mAttributeError\u001b[0m: \u0026#39;JustCounter\u0026#39; object has no attribute \u0026#39;__secretCount\u0026#39;   In[12]: \u0026nbsp;  class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print('name : ', self.name) print('url : ', self.__url) def __foo(self): # 私有方法 print('这是私有方法') def foo(self): # 公共方法 print('这是公共方法') self.__foo() x = Site('菜鸟教程', 'www.runoob.com') x.who() # 正常输出 x.foo() # 正常输出 x.__foo() # 报错    执行结果： name : 菜鸟教程 url : www.runoob.com 这是公共方法 这是私有方法 \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mAttributeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-12-9d93b50ee324\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 18\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mwho\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# 正常输出\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 19\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfoo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# 正常输出\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m---\u0026gt; 20\u001b[0;31m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m__foo\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# 报错\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mAttributeError\u001b[0m: \u0026#39;Site\u0026#39; object has no attribute \u0026#39;__foo\u0026#39;   类的专有方法：\n __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __div__: 除运算 __mod__: 求余运算 __pow__: 乘方   运算符重载 Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下：\nIn[13]: \u0026nbsp;  class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print (v1 + v2)    执行结果： Vector (7, 8)    $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/07-function-lambda/",
	"title": "Python学习 07：函数",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "这次学习 python 中函数的基础知识\n 函数定义 函数参数 匿名函数 生产函数 变量作用域 等  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  在上一次最后留给思考：给定三条线段的长度，判断是否能组成三角形，如果能输出三角形：普通三角形、等腰三角形、等边三角形或直角三角形。不知道大家有没有写出求解程序，如果没有写出来也没有关系，今天会给出一种解决方案。如果大家去写了就会发现，我们在求解三角形类型的时候，每次需要判断新给定的三条边时，都需要重复输入一遍求解代码，这样就会出现很多代码的重复输入，有没有什么办法能让我们不必重复输入相同逻辑代码呢？这个是肯定有的，其中一种解决方案就是今天讲解的 函数。在介绍函数之前，先来整体了解一下为什么需要使用函数？\n 就像上面介绍的：最大化代码重用，最小化代码冗余。冗余就是指代码重复 程序分解。在代码量越来越大后，就需要我们将大的程序进行分解，且有效的组织代码结构，函数就是分解和组织代码的最基础手段之一。  函数定义 def fun_name(arg1, arg2,... argN): statements  函数常常包含有返回值，这个时候函数至少包含一个 return语句。包含有返回语句的函数\ndef fun_name(arg1, arg2,... argN): ... return value  简单的规则：\n 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。 函数内容以冒号起始，并且缩进。 return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。  下面是一个输出 “你好” 的函数定义\nIn[2]: \u0026nbsp;  def hello(): print(\u0026quot;你好！\u0026quot;)     再看一个复杂点的函数定义 In[18]: \u0026nbsp;  # 打印一个加法口诀表 def tab(x): for i in range(x+1): for j in range(1, i+1): print('%d+%d=%d' %(j,i,i+j), end='\\t') print()     函数调用 函数定义完成后，使用如下格式调用\n 无参数函数调用：func_name() 有参数函数调用：func_name(arg1,arg2,\u0026hellip;)  In[6]: \u0026nbsp;  hello()    执行结果： 你好！    In[19]: \u0026nbsp;  tab(9)    执行结果： 1\u0026#43;1=2\t1\u0026#43;2=3\t2\u0026#43;2=4\t1\u0026#43;3=4\t2\u0026#43;3=5\t3\u0026#43;3=6\t1\u0026#43;4=5\t2\u0026#43;4=6\t3\u0026#43;4=7\t4\u0026#43;4=8\t1\u0026#43;5=6\t2\u0026#43;5=7\t3\u0026#43;5=8\t4\u0026#43;5=9\t5\u0026#43;5=10\t1\u0026#43;6=7\t2\u0026#43;6=8\t3\u0026#43;6=9\t4\u0026#43;6=10\t5\u0026#43;6=11\t6\u0026#43;6=12\t1\u0026#43;7=8\t2\u0026#43;7=9\t3\u0026#43;7=10\t4\u0026#43;7=11\t5\u0026#43;7=12\t6\u0026#43;7=13\t7\u0026#43;7=14\t1\u0026#43;8=9\t2\u0026#43;8=10\t3\u0026#43;8=11\t4\u0026#43;8=12\t5\u0026#43;8=13\t6\u0026#43;8=14\t7\u0026#43;8=15\t8\u0026#43;8=16\t1\u0026#43;9=10\t2\u0026#43;9=11\t3\u0026#43;9=12\t4\u0026#43;9=13\t5\u0026#43;9=14\t6\u0026#43;9=15\t7\u0026#43;9=16\t8\u0026#43;9=17\t9\u0026#43;9=18\t   In[21]: \u0026nbsp;  tab(7)    执行结果： 1\u0026#43;1=2\t1\u0026#43;2=3\t2\u0026#43;2=4\t1\u0026#43;3=4\t2\u0026#43;3=5\t3\u0026#43;3=6\t1\u0026#43;4=5\t2\u0026#43;4=6\t3\u0026#43;4=7\t4\u0026#43;4=8\t1\u0026#43;5=6\t2\u0026#43;5=7\t3\u0026#43;5=8\t4\u0026#43;5=9\t5\u0026#43;5=10\t1\u0026#43;6=7\t2\u0026#43;6=8\t3\u0026#43;6=9\t4\u0026#43;6=10\t5\u0026#43;6=11\t6\u0026#43;6=12\t1\u0026#43;7=8\t2\u0026#43;7=9\t3\u0026#43;7=10\t4\u0026#43;7=11\t5\u0026#43;7=12\t6\u0026#43;7=13\t7\u0026#43;7=14\t   再看一个有返回值的函数定义和调用。求两个数的和。 In[23]: \u0026nbsp;  # 定义 add 函数，并返回 2 个数的和 def add(x,y): return x+y # 调用 add 函数 print(\u0026quot;直接使用调用结果：\u0026quot;, add(3,4)) # 保存函数调用结果 result = add(5,6) print(\u0026quot;保存使用调用结果：\u0026quot;, add(3,4))    执行结果： 直接使用调用结果： 7 保存使用调用结果： 7    函数参数 由于 python 动态类型域名，在使用到变量的时候才会动态计算类型， 每一个函数都有自己处理和使用参数的方式，这也决定了调用时传入的参数必须符合函数处理时对变量使用的规范。 所以在函数调用的时候需要注意，传入的参数类型。\n比如上线定义的 add 函数，虽然本意是计算两个数的和。但是它的实际语义是：将 + 运算符作用到变量 x 引用的对象和变量 y 引用的对象上，所以只要 x 引用对象和 y 引用对象符合 + 运算符定义，都可以正常调用 add 函数。比如下面的调用：\nIn[26]: \u0026nbsp;  print(add('aa', 'b')) print(add([1,2],[3,4,5]))    执行结果： aab [1, 2, 3, 4, 5]    但是下面的调用将会出现错误，因为 + 运算符不能同时应用到 2 个不同类型的对象 In[34]: \u0026nbsp;  # error add('aa',4)    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-34-7f8ab9385845\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0;31m# error\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 2\u001b[0;31m \u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#39;aa\u0026#39;\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;32m\u0026lt;ipython-input-23-a620d74bd031\u0026gt;\u001b[0m in \u001b[0;36madd\u001b[0;34m(x, y)\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0;31m# 定义 add 函数，并返回 2 个数的和\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 2\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 3\u001b[0;31m \u001b[0;32mreturn\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m\u0026#43;\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[1;32m 4\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 5\u001b[0m \u001b[0;31m# 调用 add 函数\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;31mTypeError\u001b[0m: must be str, not int   参数传递 python 中一切数据都是对象。在定义时定义的参数只是一个变量，在函数调用时传入的参数才是对象，并将响应的参数变量引用到传入的对象。 比如上面的 add 方法定义和调用，在定义时定义了 x 和 y 两个参数变量，调用 add(3,4) 时，传入了 3 和 4 两个对象，这时变量 x 引用到 3 这个对象，变量 y 引用到 4 这个对象。请看下面的例子： In[8]: \u0026nbsp;  a=\u0026quot;99\u0026quot; b=[1,2,3] def f(x, y): print(\u0026quot;x 参数传入:\u0026quot;) print(\u0026quot; \u0026quot;, x==a) print(\u0026quot; \u0026quot;, id(x), id(a)) # 返回对象的唯一标识符 print(\u0026quot; \u0026quot;, x is a) print(\u0026quot;y 参数传入:\u0026quot;) print(\u0026quot; \u0026quot;, y==b) print(\u0026quot; \u0026quot;, id(y), id(b)) # 返回对象的唯一标识符 print(\u0026quot; \u0026quot;, y is b) f(a,b) print(\u0026quot;=================\u0026quot;) a=1 b=(1,2,2) f(a,b)    执行结果： x 参数传入: True 139675229648744 139675229648744 True y 参数传入: True 139675167007112 139675167007112 True ================= x 参数传入: True 139675395447968 139675395447968 True y 参数传入: True 139675166995008 139675166995008 True    从上面的实例可以看到不论传入的何种参数类型（简单对象或复杂对象、可变对象或不可变对象），函数的参数变量引用的对象都是原始对象，这里和其他语言里面种传值调用和传引用调用是不一样的。此时变量 a 和 参数变量 x 引用的是同一个对象，变量 b 和参数变量 y引用的同一个对象，所以在参数里面对 x 或 y 进行修改会影响 a 或 b 的访问结果；但是对 a 和 b 进行赋值不会影响 a 或 b 的访问结果，因为赋值只是将 a 或 b 引用到新的对象，并没有改变原有对象。请看下面例子： In[14]: \u0026nbsp;  a = [1] b = [1] print(\u0026quot;a=\u0026quot;,a,\u0026quot; b=\u0026quot;,b) def change(x,y): x.append([1,2]) y = y+[1,2] print(\u0026quot;x=\u0026quot;,x,\u0026quot; y=\u0026quot;,y) change(a,b) print(\u0026quot;a=\u0026quot;,a,\u0026quot; b=\u0026quot;,b)    执行结果： a= [1] b= [1] x= [1, [1, 2]] y= [1, 1, 2] a= [1, [1, 2]] b= [1]    参数修改影响传入对象，只发生在 可变对象 上，因为试着修改不可变对象将会报错， 所以对于传入不可变对象只能对参数变量做赋值或取值操作，不能修改操作。\n见下面例子：\nIn[17]: \u0026nbsp;  a = (1,1) b = [1] change(a,b)    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mAttributeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-17-25239a894afa\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0ma\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 2\u001b[0m \u001b[0mb\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 3\u001b[0;31m \u001b[0mchange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;32m\u0026lt;ipython-input-14-f7db784409a1\u0026gt;\u001b[0m in \u001b[0;36mchange\u001b[0;34m(x, y)\u001b[0m \u001b[1;32m 3\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#34;a=\u0026#34;\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u0026#34; b=\u0026#34;\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mb\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 4\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mchange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 5\u001b[0;31m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[1;32m 6\u001b[0m \u001b[0my\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0my\u001b[0m\u001b[0;34m\u0026#43;\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 7\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#34;x=\u0026#34;\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mx\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u0026#34; y=\u0026#34;\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0my\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;31mAttributeError\u001b[0m: \u0026#39;tuple\u0026#39; object has no attribute \u0026#39;append\u0026#39;   参数 调用函数时可使用的正式参数类型：\n 必需参数 关键字参数 默认参数 不定长参数 命名参数 不定长命名参数  他们的区别主要主要体现在 声明方式、调用解析 的不同。\n必需参数 必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。\n 声明方式：正常的参数变量 调用解析：严格位置前后顺序解析  比如上面的 change 函数的参数都是必要参数。\nIn[21]: \u0026nbsp;  def change(x,y): x.append([1,2]) y = y+[1,2] print(\u0026quot;x=\u0026quot;,x,\u0026quot; y=\u0026quot;,y) a = [1] b = [2] change(a,b) print(\u0026quot;a=\u0026quot;,a,\u0026quot; b=\u0026quot;,b)    执行结果： x= [1, [1, 2]] y= [2, 1, 2] a= [1, [1, 2]] b= [2]    关键字参数 关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。\n 声明方式：正常的参数变量，和必需参数相同 调用解析：在调用是具体指定传入的参数变量，不受前后顺序限制，关键字必须是声明的参数变量  由于声明方式和必须参数相同，还是以上面的 change 函数为例（不需重新声明）看调用方式\nIn[27]: \u0026nbsp;  a = [1] b = [2] change(y=a,x=b) # 指定传入特定的参数变量关键字 print(\u0026quot;a=\u0026quot;,a,\u0026quot; b=\u0026quot;,b)    执行结果： x= [2, [1, 2]] y= [1, 1, 2] a= [1] b= [2, [1, 2]]    默认参数 在函数定义声明参数时，可以给参数一个默认值，在函数调用时如果没有传入这个参数，就会使用默认值。\n 声明方式：正常的参数变量，在声明是赋值一个默认值。默认参数的声明一定要在必要参数之后。 调用解析：没有传入时解析到默认值，传入参数时解析到传入值。传入值调用方式可以是 必要参数 或 关键字参数 形式   注意：不是默认参数，在调用时必须参数值\n In[32]: \u0026nbsp;  def add(a,b=2): return a+b print(\u0026quot;正常参数调用：\u0026quot;,add(1)) print(\u0026quot;默认参数调用：\u0026quot;,add(1,4))    执行结果： 正常参数调用： 3 默认参数调用： 5    以下声明方式是错误的： In[33]: \u0026nbsp;  def add(a=1,b): return a+b    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-33-70d1e75f5033\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m1\u001b[0m \u001b[0;31m def add(a=1,b):\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m non-default argument follows default argument    不定长参数 上面 add 实现了求 2 个数的和，如果我们需要同时求多个数的和呢？ 并且数的数量还不是确定的，总不能每次调用都修改一遍函数定义吧！ 这个时候就需要使用不定长参数。\n不定长参数接受在函数调用时传入任意多个参数。\n 声明方式：前面带有 * 的参数就是不定长参数。不定长参数的声明一定要在必要参数或默认参数之后。 调用解析：没有传入时解析到默认值，传入参数时解析到传入值。传入值调用方式可以是 必要参数 或 关键字参数 形式   注意：\n 一个函数里面只能有一个不定长参数 不定长参数类型是 tuple，就意味着不定长参数本身是不可改变的，但是传入的可变数据是可以改变的   In[43]: \u0026nbsp;  def add(a,b=2, *other): print(\u0026quot;[other] 参数类型:\u0026quot;, type(other),other) return a+b+sum(other) print(add(1)) print(add(1,2)) print(add(1,2,3,4))    执行结果： [other] 参数类型: \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; () 3 [other] 参数类型: \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; () 3 [other] 参数类型: \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; (3, 4) 10    命名参数 在不定长参数后面声明的参数就是命名参数。命名参数的调用必须使用关键字参数的调用方式调用。\n 声明方式：参数名字和必须参数一样，只是位置在不定参数之后 调用解析：调用时必须使用使用关键字参数调用方式   注意： * 命名参数尽量为其声明默认值 * 不定长参数的名字可以省略，只保留 *。这个时候只是表示后面的参数是命名参数，不再接受不定长参数\n In[53]: \u0026nbsp;  def add(a,b=2, *other, c): print(\u0026quot;[other] 参数类型:\u0026quot;, type(other),other) return a+b+sum(other)+c print(add(1,2,3,4,c=5))    执行结果： [other] 参数类型: \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; (3, 4) 15    当不接受不定长参数的例子： In[59]: \u0026nbsp;  def add_3(a,b=2, *, c): return a+b+c print(add_3(1,2, c=3))    执行结果： 6    但是下面的调用时错误的，因为参数个数不匹配 In[61]: \u0026nbsp;  print(add_3(1,2,3,4,c=5))    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-61-5b2ac4a65da2\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0madd_3\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m3\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mc\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m5\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: add_3() takes from 1 to 2 positional arguments but 4 positional arguments (and 1 keyword-only argument) were given   不定长命名参数 在函数调用时接受传入任意多个命名参数。\n 声明方式：前面带有 ** 的参数。不定长参数的声明一定要在必要参数、默认参数或命名参数之后。 调用解析：以关键字参数形式调用，对于不能匹配的的必要参数或关键字参数，都将放入这个参数中  In[67]: \u0026nbsp;  def named_p(a=1, **args): print(a) print(\u0026quot;named p:\u0026quot;, args) named_p(1,b=2,c=3) named_p(a=1,b=2,c=3)    执行结果： 1 named p: {\u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 1 named p: {\u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3}    以下调用会出现错误 In[209]: \u0026nbsp;  named_p(a=1,3,4)    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-209-5ace63a7163f\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m1\u001b[0m \u001b[0;31m named_p(a=1,3,4)\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m positional argument follows keyword argument    现在针对上片的练习可以使用函数实现了：判断三角形形状 In[223]: \u0026nbsp;  def shape(a,b,c): \u0026quot;\u0026quot;\u0026quot; 判断三角形形状 a、b、c 给定三角形三条边长度 \u0026quot;\u0026quot;\u0026quot; ms,md,mx = sorted([a,b,c]) if ms \u0026lt;= mx-md: print(\u0026quot;不能组成三角形\u0026quot;) elif ms==md and md==mx: print(\u0026quot;等边三角形\u0026quot;) elif ms==md or md==mx: if ms**2 + md**2 == mx**2: print(\u0026quot;等腰直角三角形\u0026quot;) else: print(\u0026quot;等腰三角形\u0026quot;) elif ms**2 + md**2 == mx**2: print(\u0026quot;直角三角形\u0026quot;) else: print(\u0026quot;普通三角形\u0026quot;) return shape(1,3,2) shape(1,2,2) shape(3,3,3) shape(3,4,5)    执行结果： 不能组成三角形 等腰三角形 等边三角形 直角三角形    函数注解 In[55]: \u0026nbsp;  def func1(a,b,c): return a+b+c func1(1,2,3)    执行结果： 6   In[62]: \u0026nbsp;  def func2(a:'spam', b:(1,10), c:float)-\u0026gt;int: return a+b+c func2(1,2,3)    执行结果： 6   In[60]: \u0026nbsp;  func2.__annotations__    执行结果： {\u0026#39;a\u0026#39;: \u0026#39;spam\u0026#39;, \u0026#39;b\u0026#39;: (1, 10), \u0026#39;c\u0026#39;: float, \u0026#39;return\u0026#39;: int}   In[63]: \u0026nbsp;  def func2(a:'spam'=4, b:(1,10)=5, c:float=6)-\u0026gt;int: return a+b+c func2()    执行结果： 15   匿名函数：lambda python 使用 lambda 来创建匿名函数。\n所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。\n lambda 只是一个表达式，函数体比 def 简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。  In[69]: \u0026nbsp;  # 可写函数说明 sum = lambda a, b: a + b # 调用sum函数 print (\u0026quot;相加后的值为 : \u0026quot;, sum( 10, 20 )) print (\u0026quot;相加后的值为 : \u0026quot;, sum( 20, 20 ))    执行结果： 相加后的值为 : 30 相加后的值为 : 40    变量作用域 Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。\n变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：\n L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域  以 L –\u0026gt; E –\u0026gt; G –\u0026gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。\nIn[71]: \u0026nbsp;  x = int(2.9) # 内建作用域 g_count = 0 # 全局作用域 def outer(): o_count = 1 # 闭包函数外的函数中 def inner(): i_count = 2 # 局部作用域     Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码： In[76]: \u0026nbsp;  if True: a = 1 print(\u0026quot;可以访问 a：\u0026quot;, a) def scope1(): inner_a = 2 scope1() print(inner_a) # inner_a 在这里不可访问    执行结果： 可以访问 a： 1 \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mNameError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-76-212c676a7b89\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 7\u001b[0m \u001b[0minner_a\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m2\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 8\u001b[0m \u001b[0mscope1\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 9\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0minner_a\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# inner_a 在这里不可访问\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mNameError\u001b[0m: name \u0026#39;inner_a\u0026#39; is not defined   global 和 nonlocal关键字 ** 全局变量和局部变量 **\n定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。\n局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：\nIn[79]: \u0026nbsp;  total = 0 # 这是一个全局变量 # 可写函数说明 def sum( arg1, arg2 ): #返回2个参数的和.\u0026quot; total = arg1 + arg2 # total在这里是局部变量. print (\u0026quot;函数内是局部变量 : \u0026quot;, total) return total #调用sum函数 sum( 10, 20 ) print (\u0026quot;函数外是全局变量 : \u0026quot;, total)    执行结果： 函数内是局部变量 : 30 函数外是全局变量 : 0    当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字 In[81]: \u0026nbsp;  total = 0 # 这是一个全局变量 # 可写函数说明 def sum2( arg1, arg2 ): #返回2个参数的和.\u0026quot; global total total = arg1 + arg2 # total在这里是局部变量. print (\u0026quot;函数内是局部变量 : \u0026quot;, total) return total #调用sum函数 sum2( 10, 20 ) print (\u0026quot;函数外是全局变量 : \u0026quot;, total)    执行结果： 函数内是局部变量 : 30 函数外是全局变量 : 30    如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例： In[89]: \u0026nbsp;  def outer(): num = 10 def inner(): nonlocal num # nonlocal关键字声明 num = 100 print(num) inner() print(num) outer()    执行结果： 100 100    以下函数执行将产生错误，因为 a 是一个局部变量，但是在使用时候并没有定义。有 2 中修改方式：\n 将 = 左边的变量 a 换成其他变量名称（比如 b）。 将外部 a 作为参数传入  In[91]: \u0026nbsp;  a = 10 def test(): a = a + 1 print(a) test()    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mUnboundLocalError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-91-4212688e84b0\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 3\u001b[0m \u001b[0ma\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0ma\u001b[0m \u001b[0;34m\u0026#43;\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 4\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 5\u001b[0;31m \u001b[0mtest\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;32m\u0026lt;ipython-input-91-4212688e84b0\u0026gt;\u001b[0m in \u001b[0;36mtest\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0ma\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m10\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 2\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mtest\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 3\u001b[0;31m \u001b[0ma\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0ma\u001b[0m \u001b[0;34m\u0026#43;\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[1;32m 4\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 5\u001b[0m \u001b[0mtest\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;31mUnboundLocalError\u001b[0m: local variable \u0026#39;a\u0026#39; referenced before assignment   可以使用以下方式查看内建作用域中的变量。\ndir(__builtin__) # 或 dir(__builtins__)  这里 __builtin__ 和 __builtins__ 是有区别的，并且在主模块和子模块中有所不同。\n工厂函数：闭包 在函数作用域中，有一个闭包作用域，那怎么产生闭包呢！只要在函数内部定义函数，就会产生闭包作用域。\n闭包作用域：外部函数的本地作用域就是闭包函数的闭包作用域。\n工厂函数：一个返回值时函数的函数就是，这里的返回值函数也叫闭包函数或内部函数，工厂函数也叫外部函数。\nIn[94]: \u0026nbsp;  def marker(n): def action(x): return x ** n return action     In[95]: \u0026nbsp;  f = marker(2) f    执行结果： \u0026lt;function __main__.marker.\u0026lt;locals\u0026gt;.action(x)\u0026gt;   In[96]: \u0026nbsp;  print(f(3), f(4))    执行结果： 9 16    In[32]: \u0026nbsp;  f(4)    执行结果： 16   In[98]: \u0026nbsp;  g = marker(3) print(g(4)) # 4 ** 3 print(f(4)) # 4 ** 2    执行结果： 64 16    对于简单的函数逻辑，也可指直接返回 lambda 函数 In[35]: \u0026nbsp;  def marker(n): return lambda x: x**n     In[36]: \u0026nbsp;  h = marker(3) h(4)    执行结果： 64   ** 闭包使用建议 **\n闭包在必须的时候才使用，可以使用类进行替换。类后面会详细介绍。 注意闭包和循环共同使用时，变量的作用域\n函数对象 python 秉承着一切皆对象的理念，函数也是一个对象，具有属性（可以使用dir()查询）。作为对象，它还可以赋值给其它对象名，或者作为参数传递。 In[117]: \u0026nbsp;  def fun_obj1(f, a): f(a) def fun_obj2(v): print(v*2)     In[121]: \u0026nbsp;  fun_obj1(fun_obj2, 3) # 函数对象作为参数 obj1 = fun_obj1 # 函数对象赋值 obj1(fun_obj2, 3)    执行结果： 6 6    也可以直接使用匿名函数调用 In[119]: \u0026nbsp;  fun_obj1(lambda v: print(v ** 2), 3)    执行结果： 9    生成函数: yield vs. return 在函数返回值的时候我们使用 return，还有一种方式是使用 yield 关键字，此时叫做 生成函数。有以下特点：\n 含有yield关键字 调用生成器函数会返回一个生成器 调用生成器函数时, 它包含的代码并不会马上执行, 而是等到访问生成器元素时才一段一段地执行.  使用场景：当有大量的数据访问，并且每个数据只访问一次，使用生成器会节省大量空间\n对于普通的生成器，第一个next调用，相当于启动生成器，会从生成器函数的第一行代码开始执行，直到第一次执行完yield语句（第4行）后，跳出生成器函数。\n然后第二个next调用，进入生成器函数后，从yield语句的下一句语句（第5行）开始执行，然后重新运行到yield语句，执行后，跳出生成器函数，\n后面再次调用next，依次类推。\nIn[168]: \u0026nbsp;  def gen_func(): print ('yield 1...') yield 1 print ('yield 2...') yield 2 print ('yield 3...') yield 3 print ('yield 4... 是不是外面调用报错了...') return 5 gen_res = gen_func() print(\u0026quot;在函数调用时不会马上执行代码，返回生成器\u0026quot;) print(gen_res) print(\u0026quot;在访问生成器的时候，才会一段一段执行代码\u0026quot;) print(\u0026quot;get 1:\u0026quot;, next(gen_res)) print(\u0026quot;get 2:\u0026quot;, next(gen_res)) print(\u0026quot;get 3:\u0026quot;, next(gen_res)) print(\u0026quot;如果已经超出生成器范围，会产生一个错误；但是如果函数里面最后生成器后面还有代码，会先执行\u0026quot;) print(\u0026quot;get 4:\u0026quot;, next(gen_res))    执行结果： 在函数调用时不会马上执行代码，返回生成器 \u0026lt;generator object gen_func at 0x7f08a824ef10\u0026gt; 在访问生成器的时候，才会一段一段执行代码 yield 1... get 1: 1 yield 2... get 2: 2 yield 3... get 3: 3 如果已经超出生成器范围，会产生一个错误；但是如果函数里面最后生成器后面还有代码，会先执行 yield 4... 是不是外面调用报错了... \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mStopIteration\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-168-10c15cc024b5\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 17\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#34;get 3:\u0026#34;\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgen_res\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 18\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#34;如果已经超出生成器范围，会产生一个错误；但是如果函数里面最后生成器后面还有代码，会先执行\u0026#34;\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m---\u0026gt; 19\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\u0026#34;get 4:\u0026#34;\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mnext\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mgen_res\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mStopIteration\u001b[0m: 5   send vs. next send 和 next 功能相识，区别是send()可以传递yield表达式的值进去，而next()不能传递特定的值，只能传递None进去。因此，我们可以看做c.next() 和 c.send(None) 作用是一样的。需要提醒的是，第一次调用时，请使用next()语句或是send(None)，不能使用send发送一个非None的值，否则会出错的，因为没有Python yield语句来接收这个值。 In[187]: \u0026nbsp;  def double_inputs(): while True: x = yield if not x: return print(x * 2) yield x*2 gen = double_inputs() gen.send(None) gen.send(10) print(\u0026quot;get\u0026quot;, next(gen)) gen.send(20) print(\u0026quot;get\u0026quot;, gen.send(None)) gen.send(30) print(\u0026quot;get\u0026quot;, next(gen)) gen.close()    执行结果： 20 get None 40 get None 60 get None    生成器表达式 在之前介绍 列表推导（解析表达式） 的时候，已经见过生成器表达式的形式了，有了上面的生产函数的知识，理解生成器表达式就简单了。\n生成器表达式与列表推导在语法上十分相似:\n 列表推导（解析表达式）使用[]: [i for i in arr] 生成器表达式使用(): (i for i in arr)  In[100]: \u0026nbsp;  s = (x**2 for x in range(4)) s    执行结果： \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x7f08a82e6468\u0026gt;   In[101]: \u0026nbsp;  next(s),next(s),next(s)    执行结果： (0, 1, 4)   In[102]: \u0026nbsp;  type(s)    执行结果： generator   In[122]: \u0026nbsp;  a,b,c=(x**2 for x in range(3)) a,b,c    执行结果： (0, 1, 4)   函数递归 有一类函数在使用的时候需要注意一下，就是在函数内部调用自己的函数，称为 递归函数。先看一个例子：\n求 1~n 之间所有整数的乘积？\n先来看循环的方式实现：\nIn[198]: \u0026nbsp;  def sum_n(n): result = 1 while n\u0026gt;1: result *= n n -= 1 return result print(sum_n(5)) print(sum_n(3))    执行结果： 120 6    我们也可以使用递归实现 In[203]: \u0026nbsp;  def sum_n2(n): if(n==1): return 1 return n * sum_n2(n-1) print(sum_n2(5)) print(sum_n2(3))    执行结果： 120 6    我们看到在使用递归的时候，我们不会展开具体的实现过程，只是根据乘积递归定义 n! = n * (n-1)! 用程序表达出来，在执行的时候会自动调用展开。 再看一个例子：\n求第 n 个斐波拉契数？\nIn[208]: \u0026nbsp;  def f(n): if n==1 or n==2: return 1 return f(n-1) + f(n-2) print(f(1),f(2),f(3),f(4),f(5),f(6))    执行结果： 1 1 2 3 5 8    使用递归函数注意： 递归函数必须有一个终止条件，不然就是循环了 函数式编程工具 在 python 中提供了一些列和函数式编程的工具和方法，这里将常用列举出来大家有兴趣可以学习使用。\n map、filter、reduce、zip operator、functools 包  程序设计原则  最小化变量作用于 最小化跨文件改变 使用 lambda 表达式时，尽量保持逻辑简单，复杂逻辑使用函数、类或其他方式 对于很多数据处理，尽量使用生成函数 慎用闭包  $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/06-basic-statement/",
	"title": "Python学习 06：python 基础语句：if/for/while",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "前面学习了 python 中的基础数据类型，现在开始学习 python 中和程序结构相关的内容，首先从基础语句开始\n 语句简单分类 if 语句 for 语句 while 语句 解析式语句  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  语句类型 python 程序语言里面语句较多，基本是一个或多个关键字对应一个语句类型，常用的语句类型如下：\n 赋值语句 判断语句 循环语句 解析式语句 异常捕获语句 函数定义语句 函数调用语句 类定义语句 类使用语句 包引入语句  这里我们只介绍 赋值语句 、 判断语句 、 *循环语句*、解析式语句 ，其他语句适合特定类容相关的，在后面和内容一起介绍。\n在 python 中语句嵌套组合，形成更复杂的程序结构。\n赋值语句 还记的变量吧，赋值语句主要是针对变量的。每个赋值语句一定包含 = 操作符，或者含有 = 语义的操作符，例如：+=、*=、/=等。 一个赋值语句包含三部分：=操作符、左值、右值。在=左边的的表达式计算结果称为左值，在=右边的表达式计算结果称为右值。\n 左值的计算结果一定是一个变量或引用 右值的计算记过一定是一个对象  例如：\n a=1, 这里 a 表示左值，是一个变量；1 表示右值，是一个对象 L[a+1]=5*3, 这里 L[a+1] 表示左值，计算的结果是表示一个引用；5*3 表示右值，计算的结果是一个对象\n In[1]: \u0026nbsp;  a=1 a    执行结果： 1   In[2]: \u0026nbsp;  a += 5 a    执行结果： 6    注意：= 操作不要求左值变量已经创建，如果没有定义会自行创建。但是在使用 +=、*=、/= 等类似操作符时，要求 左值既是一个对象，也是一个变量或引用。因为这类操作符是先计算并获取左值引用的对象，然后使用这个对象和右值计算的对象做运算，最后在赋值给左值的变量或引用。\n In[3]: \u0026nbsp;  # 由于 变量 b 没有定义，所以在计算 b 的对象时会发生错误 b += 1    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mNameError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-3-be9562e617df\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0;31m# 由于 变量 b 没有定义，所以在计算 b 的对象时会发生错误\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 2\u001b[0;31m \u001b[0mb\u001b[0m \u001b[0;34m\u0026#43;=\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mNameError\u001b[0m: name \u0026#39;b\u0026#39; is not defined   if 语句 Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。\n可以通过下图来简单了解条件语句的执行过程:\nPython程序语言指定任何非0和非空（null）值为true，0 或者 null 为false。\nPython 编程中 if 语句用于控制程序的执行，基本形式为：\nif 判断条件： 执行语句…… else： 执行语句……  其中\u0026rdquo;判断条件\u0026rdquo;成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。\nelse 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句，具体例子如下：\nIn[4]: \u0026nbsp;  name='Lilei' if name=='Lilei': print(\u0026quot;My name is Lilei!\u0026quot;) else: print(\u0026quot;My name is Hanmeimei!\u0026quot;)    执行结果： My name is Lilei!    if 语句的判断条件可以用\u0026gt;（大于）、\u0026lt;(小于)、==（等于）、\u0026gt;=（大于等于）、\u0026lt;=（小于等于）来表示其关系。\n当判断条件为多个值时，可以使用以下形式\nif 判断条件1: 执行语句1…… elif 判断条件2: 执行语句2…… elif 判断条件3: 执行语句3…… else: 执行语句4……  In[5]: \u0026nbsp;  name='Hanmeimei' if name=='Lilei': print(\u0026quot;My name is Lilei!\u0026quot;) elif name=='Hanmeimei': print(\u0026quot;My name is Hanmeimei!\u0026quot;) elif name=='dog': print(\u0026quot;Sorry, this is a dog!\u0026quot;) else: print(\u0026quot;This is an ET!\u0026quot;) name='apple' if name=='Lilei': print(\u0026quot;My name is Lilei!\u0026quot;) elif name=='Hanmeimei': print(\u0026quot;My name is Hanmeimei!\u0026quot;) elif name=='dog': print(\u0026quot;Sorry, this is a dog!\u0026quot;) else: print(name + \u0026quot; is an ET!\u0026quot;)    执行结果： My name is Hanmeimei! apple is an ET!    判断条件 是一个计算结果为 Boolean 值对象 得表达式。在《Python学习 03：python 数值类型》介绍的的 *比较运算符*、*逻辑运算符*、*成员运算符*、身份运算符 这些操作的结果都是 Boolean 值对象，包含后面将介绍的的 *返回 Boolean 值对象的函数调用操作*，只要任意以表达式返回Boolean 值对象都可以作为 if 语句的判断条件 In[6]: \u0026nbsp;  item = 2 L = [1,2,3] # 成员运算 if item in L: print(\u0026quot;%d 在 %s 中\u0026quot; %(item, str(L))) else: print(\u0026quot;%d 没在 %s 中\u0026quot; %(item, str(L))) # 比较运算符 a = 1 b = 2 if a==b: print(\u0026quot;a 等于 b\u0026quot;) else: print(\u0026quot;a 不等于 b\u0026quot;) # 逻辑运算符 if a==b and item in L: print(\u0026quot;a 等于 b 同时 %d 在 %s 中\u0026quot; %(item, str(L))) else: print(\u0026quot;a 不等于 b 或者 %d 不在 %s 中\u0026quot; %(item, str(L)))    执行结果： 2 在 [1, 2, 3] 中 a 不等于 b a 不等于 b 或者 2 不在 [1, 2, 3] 中    循环语句 for 语句 Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。\nfor循环的语法格式如下：\nfor iterating_var in sequence: statements(s)  流程图：\n实例：\nIn[7]: \u0026nbsp;  print(\u0026quot;循环字符串：\u0026quot;) s = \u0026quot;Python!\u0026quot; for letter in s: print(\u0026quot;\\t当前字符：\u0026quot; + letter) print(\u0026quot;循环序列：\u0026quot;) l = [4,3,2,1,12] for item in l: print(\u0026quot;\\t当前元素：\u0026quot; + str(item))    执行结果： 循环字符串： 当前字符：P 当前字符：y 当前字符：t 当前字符：h 当前字符：o 当前字符：n 当前字符：! 循环序列： 当前元素：4 当前元素：3 当前元素：2 当前元素：1 当前元素：12    可以以通过序列索引来循环： In[8]: \u0026nbsp;  fruits = ['apple', 'orange', 'banana'] for i in range(len(fruits)): print(\u0026quot;第 %d 个水果是 %s\u0026quot; %(i+1, fruits[i]))    执行结果： 第 1 个水果是 apple 第 2 个水果是 orange 第 3 个水果是 banana    注意再循环中对于循环变量的赋值操作不会影响到原始序列的值。但是如果序列里面是是可以修改的对象时，通过循环变量的修改操作会同时修改原序列的中的对应值。 In[9]: \u0026nbsp;  objs = [{'a':'a1'}, {'a':'a2'}, {'a':'a3'}] print(objs) for obj in objs: obj=1 print(obj) print(objs)    执行结果： [{\u0026#39;a\u0026#39;: \u0026#39;a1\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;a2\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;a3\u0026#39;}] 1 1 1 [{\u0026#39;a\u0026#39;: \u0026#39;a1\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;a2\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;a3\u0026#39;}]    In[10]: \u0026nbsp;  objs = [{'a':'a1'}, {'a':'a2'}, {'a':'a3'}] print(objs) for obj in objs: obj['a'] = 'aaa' print(obj) print(objs)    执行结果： [{\u0026#39;a\u0026#39;: \u0026#39;a1\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;a2\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;a3\u0026#39;}] {\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;} {\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;} {\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;} [{\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;}, {\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;}]    while 语句 Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：\nwhile 判断条件： 执行语句…… 执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。\n当判断条件假false时，循环结束。\n执行流程图如下：\nGif 演示 Python while 语句执行过程 In[11]: \u0026nbsp;  count = 0 while count \u0026lt; 9: print('The count is:' + str(count)) count = count + 1 print(\u0026quot;Good bye!\u0026quot;)    执行结果： The count is:0 The count is:1 The count is:2 The count is:3 The count is:4 The count is:5 The count is:6 The count is:7 The count is:8 Good bye!    当当前始终为 true 时，将会无限循环 In[12]: \u0026nbsp;  s = '' while s!='bye': s = input(\u0026quot;Enter a number :\u0026quot;) print(\u0026quot;You entered: \u0026quot; + s) print(\u0026quot;Bye Bye!\u0026quot;)    执行结果： Enter a number : You entered: Enter a number : You entered: Enter a number :bye You entered: bye Bye Bye!    break、continue、pass 语句 再循环中常常会遇到提前结束整个循环或提前结束当前循环操作，这个时候就需要用到 break 和 continue。\n break：结束整个循环，剩余的循环次数不再执行 continue：结束本轮循环操作，本轮循环后面的语句不再执行，但是剩余的循环次数将继续执行 pass：空语句，一个占位符，表示这里什么都每一偶  In[13]: \u0026nbsp;  l = [1,2,3,4,5,6] print(\u0026quot;正常输出：\u0026quot;) for i in l: print(\u0026quot;i = %d\u0026quot; % i) print(\u0026quot;break 输出：\u0026quot;) for i in l: if(i==3): break # 这里将结束 i=3 以后的所有输出 print(\u0026quot;i = %d\u0026quot; % i) print(\u0026quot;break 输出：\u0026quot;) for i in l: if(i==3): continue # 这里将跳过 i=3 的输出 print(\u0026quot;i = %d\u0026quot; % i)    执行结果： 正常输出： i = 1 i = 2 i = 3 i = 4 i = 5 i = 6 break 输出： i = 1 i = 2 break 输出： i = 1 i = 2 i = 4 i = 5 i = 6    语句嵌套 从上面的实例可以看到，在 for 语句里面包含了 if 语句，其实任务语句都可以嵌套使用，语句嵌套使我们可以处理复杂的逻辑和流程。下面通过一个例子说明。\n ？输出常见的加法口诀表\n In[14]: \u0026nbsp;  for i in range(10): for j in range(1, i+1): print('%d+%d=%d' %(j,i,i+j), end='\\t') print()    执行结果： 1\u0026#43;1=2\t1\u0026#43;2=3\t2\u0026#43;2=4\t1\u0026#43;3=4\t2\u0026#43;3=5\t3\u0026#43;3=6\t1\u0026#43;4=5\t2\u0026#43;4=6\t3\u0026#43;4=7\t4\u0026#43;4=8\t1\u0026#43;5=6\t2\u0026#43;5=7\t3\u0026#43;5=8\t4\u0026#43;5=9\t5\u0026#43;5=10\t1\u0026#43;6=7\t2\u0026#43;6=8\t3\u0026#43;6=9\t4\u0026#43;6=10\t5\u0026#43;6=11\t6\u0026#43;6=12\t1\u0026#43;7=8\t2\u0026#43;7=9\t3\u0026#43;7=10\t4\u0026#43;7=11\t5\u0026#43;7=12\t6\u0026#43;7=13\t7\u0026#43;7=14\t1\u0026#43;8=9\t2\u0026#43;8=10\t3\u0026#43;8=11\t4\u0026#43;8=12\t5\u0026#43;8=13\t6\u0026#43;8=14\t7\u0026#43;8=15\t8\u0026#43;8=16\t1\u0026#43;9=10\t2\u0026#43;9=11\t3\u0026#43;9=12\t4\u0026#43;9=13\t5\u0026#43;9=14\t6\u0026#43;9=15\t7\u0026#43;9=16\t8\u0026#43;9=17\t9\u0026#43;9=18\t   In[15]: \u0026nbsp;  for i in range(10): for j in range(1, 10): if(j\u0026gt;i): break print('%d+%d=%d' %(j,i,i+j), end='\\t') print()    执行结果： 1\u0026#43;1=2\t1\u0026#43;2=3\t2\u0026#43;2=4\t1\u0026#43;3=4\t2\u0026#43;3=5\t3\u0026#43;3=6\t1\u0026#43;4=5\t2\u0026#43;4=6\t3\u0026#43;4=7\t4\u0026#43;4=8\t1\u0026#43;5=6\t2\u0026#43;5=7\t3\u0026#43;5=8\t4\u0026#43;5=9\t5\u0026#43;5=10\t1\u0026#43;6=7\t2\u0026#43;6=8\t3\u0026#43;6=9\t4\u0026#43;6=10\t5\u0026#43;6=11\t6\u0026#43;6=12\t1\u0026#43;7=8\t2\u0026#43;7=9\t3\u0026#43;7=10\t4\u0026#43;7=11\t5\u0026#43;7=12\t6\u0026#43;7=13\t7\u0026#43;7=14\t1\u0026#43;8=9\t2\u0026#43;8=10\t3\u0026#43;8=11\t4\u0026#43;8=12\t5\u0026#43;8=13\t6\u0026#43;8=14\t7\u0026#43;8=15\t8\u0026#43;8=16\t1\u0026#43;9=10\t2\u0026#43;9=11\t3\u0026#43;9=12\t4\u0026#43;9=13\t5\u0026#43;9=14\t6\u0026#43;9=15\t7\u0026#43;9=16\t8\u0026#43;9=17\t9\u0026#43;9=18\t   解析式语句 解析式语句可以使我们更容易处理列表数据，它的所有能力都可以使用循环语句实现，可以看做循环语句的简略形式。解析式可以任何支持迭代操作的数据结构，包括：列表、元组、自定义支持迭代类型\n看一下例子： \u0026gt; 将 L 列表中，所有数据都加上 20\nIn[16]: \u0026nbsp;  L = [1,2,3,4,5,6,7,8,9,10] # 循环实现 L1=[] for item in L: L1.append(item+20) print(\u0026quot;循环实现\\t\\t\u0026quot;,end='');print(L1) # 解析式实现 L2=[ item+20 for item in L] print(\u0026quot;解析式实现\\t\u0026quot;,end='');print(L2)    执行结果： 循环实现\t[21, 22, 23, 24, 25, 26, 27, 28, 29, 30] 解析式实现\t[21, 22, 23, 24, 25, 26, 27, 28, 29, 30]    可以在解析式里面做数据过滤\n 找出 L 中所有的偶数\n In[17]: \u0026nbsp;  L = [1,2,3,4,5,6,7,8,9,10] # 循环实现 L1=[] for item in L: if item % 2==0: L1.append(item) print(\u0026quot;循环实现\\t\\t\u0026quot;,end='');print(L1) # 解析式实现 L2=[ item for item in L if item % 2==0] print(\u0026quot;解析式实现\\t\u0026quot;,end='');print(L2)    执行结果： 循环实现\t[2, 4, 6, 8, 10] 解析式实现\t[2, 4, 6, 8, 10]    也可以在解析式里面同时处理多个列表，使其产生多个列表元素组合效果 In[18]: \u0026nbsp;  L1 = [1,2,3] L2 = [3,4,5] print([(x,y) for x in L1 for y in L2]) print([(x,y) for x in L1 for y in L2 if x==y])    执行结果： [(1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5)] [(3, 3)]    当然解析式也是可以嵌套使用 In[19]: \u0026nbsp;  L = [1,2,3,4,5,6] print([x+1 for x in [x*2 for x in L]])    执行结果： [3, 5, 7, 9, 11, 13]    使用解析式生成其他数据结构，但是要确保生成的数据结构本省具有可变性，这样就导致元组是不能用解析式生成的。当使用 (x for x in [1,2,3]) 时，这个其实是 生成表达式 语法，会在下次介绍。 In[1]: \u0026nbsp;  L3 = [1,2,3] print([x**2 for x in L3]) print({\u0026quot;i\u0026quot;+str(x):x**2 for x in L3}) print([x**2 for x in (4,5,6)]) print((x**2 for x in (4,5,6)))    执行结果： [1, 4, 9] {\u0026#39;i1\u0026#39;: 1, \u0026#39;i2\u0026#39;: 4, \u0026#39;i3\u0026#39;: 9} [16, 25, 36] \u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x7f7ec8192518\u0026gt;    试试  ？给定三条线段的长度，判断是否能组成三角形，如果能输出三角形：普通三角形、等腰三角形、等边三角形或直角三角形\n例如：\n a=1; b=2; c=3 输出：不是三角形\na=3; b=4; c=5 输出：直角三角形\na=1; b=1; c=1 输出：等边三角形\n  $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/05-list-dict/",
	"title": "Python学习 05：python 列表、元组、字典",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "列表、元组、字典均是 Python 中基础数据类型。\n 列表操作 元组操作 字典操作  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  接下来介绍 python 里面另外三种常见类型：tuple、list、dict。 list 列表是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。\n序列都可以进行的操作包括索引，切片，加，乘，检查成员。\n此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。\n列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。\n列表的数据项不需要具有相同的类型\nlist 创建 创建列表有 2 中方式：一是使用字面量，二是使用 list 方法\n使用字面量创建\nIn[1]: \u0026nbsp;  L = [] print(L) L = [1,2,3] print(L) L = ['a','b',100] print(L)    执行结果： [] [1, 2, 3] [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, 100]    使用 list 方法创建 In[2]: \u0026nbsp;  L = list('spam') L    执行结果： [\u0026#39;s\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;]   list 访问 直接使用下表访问 In[3]: \u0026nbsp;  L = list('spam') L[1], L[1:3]    执行结果： (\u0026#39;p\u0026#39;, [\u0026#39;p\u0026#39;, \u0026#39;a\u0026#39;])   循环输出 In[4]: \u0026nbsp;  for x in L: print(x)    执行结果： s p a m    判断一个值是否在列表中 In[5]: \u0026nbsp;  3 in L, 'p' in L    执行结果： (False, True)   list 操作 获取列表长度 In[6]: \u0026nbsp;  len([1,2,3,4])    执行结果： 4   列表拼接 In[7]: \u0026nbsp;  [1,2,3] + [4,5,6]    执行结果： [1, 2, 3, 4, 5, 6]   重复列表中所有元素 In[8]: \u0026nbsp;  ['Ni!', 'You'] * 4    执行结果： [\u0026#39;Ni!\u0026#39;, \u0026#39;You\u0026#39;, \u0026#39;Ni!\u0026#39;, \u0026#39;You\u0026#39;, \u0026#39;Ni!\u0026#39;, \u0026#39;You\u0026#39;, \u0026#39;Ni!\u0026#39;, \u0026#39;You\u0026#39;]   列表和字符串之间的转换操作 In[9]: \u0026nbsp;  str([1,2]) + \u0026quot;34\u0026quot;    执行结果： \u0026#39;[1, 2]34\u0026#39;   In[10]: \u0026nbsp;  [1,2]+list(\u0026quot;34\u0026quot;)    执行结果： [1, 2, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;]   迭代生产新列表 In[11]: \u0026nbsp;  res = [c*4 for c in 'SPAM'] res    执行结果： [\u0026#39;SSSS\u0026#39;, \u0026#39;PPPP\u0026#39;, \u0026#39;AAAA\u0026#39;, \u0026#39;MMMM\u0026#39;]   In[12]: \u0026nbsp;  res = [] for c in 'SPAM': res.append(c*4) res    执行结果： [\u0026#39;SSSS\u0026#39;, \u0026#39;PPPP\u0026#39;, \u0026#39;AAAA\u0026#39;, \u0026#39;MMMM\u0026#39;]   In[13]: \u0026nbsp;  list(map(abs,[-1,-2,0,1,2]))    执行结果： [1, 2, 0, 1, 2]   索引、切片、多维 In[14]: \u0026nbsp;  matrix = [ [1,2,3], [4,5,6], [7,8,9] ] matrix    执行结果： [[1, 2, 3], [4, 5, 6], [7, 8, 9]]   In[15]: \u0026nbsp;  matrix[1]    执行结果： [4, 5, 6]   In[16]: \u0026nbsp;  matrix[1][1]    执行结果： 5   改变元素 In[17]: \u0026nbsp;  L = [1,2,3] L    执行结果： [1, 2, 3]   In[18]: \u0026nbsp;  L[1] = 0 L    执行结果： [1, 0, 3]   In[19]: \u0026nbsp;  L[1:2] = [4,5] L    执行结果： [1, 4, 5, 3]   In[20]: \u0026nbsp;  L[1:1] = [6,7] L    执行结果： [1, 6, 7, 4, 5, 3]   In[21]: \u0026nbsp;  L[1:2] = [] L    执行结果： [1, 7, 4, 5, 3]   del 关键字删除 In[22]: \u0026nbsp;  L = ['spam', 'eggs', 'ham', 'toast'] L    执行结果： [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;toast\u0026#39;]   In[23]: \u0026nbsp;  del L[0] L    执行结果： [\u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;toast\u0026#39;]   In[24]: \u0026nbsp;  del L[1:] L    执行结果： [\u0026#39;eggs\u0026#39;]   排序 In[25]: \u0026nbsp;  L = ['eat', 'more', 'SPAM!'] L    执行结果： [\u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;SPAM!\u0026#39;]   In[26]: \u0026nbsp;  L.sort() L    执行结果： [\u0026#39;SPAM!\u0026#39;, \u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;]   In[27]: \u0026nbsp;  L.sort(key=str.lower) L    执行结果： [\u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;SPAM!\u0026#39;]   In[28]: \u0026nbsp;  L.sort(key=str.lower, reverse=True) L    执行结果： [\u0026#39;SPAM!\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;eat\u0026#39;]   还可以使用内置 sorted 函数进行排序，只是 sorted 函数不会改变原有 list 对象，会返回一个新的 list 对象 In[29]: \u0026nbsp;  Ls=[3,4,2]     In[30]: \u0026nbsp;  sorted(Ls), Ls    执行结果： ([2, 3, 4], [3, 4, 2])   list 还有其他常用操作方法，请使用 dir 和 help 进行查看学习。例如：dir([])。 tuple 在 python 有一个和 list 很相似的数据结构：tuple。他们支持的访问操作几乎相同，一个本质的却别就是：\ntuple 不可修改，list 可以修改\n元组使用小括号，列表使用方括号\n由于 tuple 不可变性，所以 list 中一切可能改变内容的操作 tuple 都没有，其他访问操作方式完全一下，当然返回的数据类型是 tuple\nIn[31]: \u0026nbsp;  t = ('eat', 'more', 'SPAM!') t    执行结果： (\u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;SPAM!\u0026#39;)   In[32]: \u0026nbsp;  t1 = 'a','b','c' t1    执行结果： (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;)   In[33]: \u0026nbsp;  t[0]    执行结果： \u0026#39;eat\u0026#39;   In[34]: \u0026nbsp;  t[1:]    执行结果： (\u0026#39;more\u0026#39;, \u0026#39;SPAM!\u0026#39;)   In[35]: \u0026nbsp;  (1,2) + (3,4)    执行结果： (1, 2, 3, 4)   In[36]: \u0026nbsp;  (1,2,3) * 4    执行结果： (1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3)   In[37]: \u0026nbsp;  sorted(t)    执行结果： [\u0026#39;SPAM!\u0026#39;, \u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;]   命名 tuple 以上元组的访问是通过索引访问，这个有时候是不方便的。这个时候我们就需要使用命名元组。 In[38]: \u0026nbsp;  from collections import namedtuple Student = namedtuple('Student', ['name', 'age', 'sex', 'email']) s = Student('Jim', 21, 'male', '123@qq.com') print(Student) print(s) print(s.age)    执行结果： \u0026lt;class \u0026#39;__main__.Student\u0026#39;\u0026gt; Student(name=\u0026#39;Jim\u0026#39;, age=21, sex=\u0026#39;male\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;) 21    dict 字典是另一种可变容器模型，且可存储任意类型对象。 In[39]: \u0026nbsp;  # 字典创建     In[40]: \u0026nbsp;  D = {'spam':2, 'ham': 1, 'eggs': 3} D    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: 1, \u0026#39;eggs\u0026#39;: 3}   In[41]: \u0026nbsp;  # 其他方式创建 D1 = {} D1['spam'] = 2 D1['ham'] = 1 D1['eggs'] = 3 D    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: 1, \u0026#39;eggs\u0026#39;: 3}   In[42]: \u0026nbsp;  D2 = dict(spam=2, ham=1, eggs=3) D2    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: 1, \u0026#39;eggs\u0026#39;: 3}   In[43]: \u0026nbsp;  D3 = dict([('spam',2),('eggs',3),('ham', 1)]) D3    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;eggs\u0026#39;: 3, \u0026#39;ham\u0026#39;: 1}   In[44]: \u0026nbsp;  D4 = dict.fromkeys(['a','b','c'],0) D4    执行结果： {\u0026#39;a\u0026#39;: 0, \u0026#39;b\u0026#39;: 0, \u0026#39;c\u0026#39;: 0}   In[45]: \u0026nbsp;  D5 = {x:x**2 for x in range(5)} D5    执行结果： {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}   In[46]: \u0026nbsp;  D6 = dict(zip(['a','b','c'],[1,2,3])) D6    执行结果： {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3}   In[47]: \u0026nbsp;  D['ham']    执行结果： 1   字段操作 In[48]: \u0026nbsp;  D = {'spam':2, 'ham': 1, 'eggs': 3} len(D)    执行结果： 3   In[49]: \u0026nbsp;  判断是否包含某个 key。注意：不能使用这样判断某个值是否存在。    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-49-6b1d84981dc0\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m1\u001b[0m \u001b[0;31m 判断是否包含某个 key。注意：不能使用这样判断某个值是否存在。\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid character in identifier    In[50]: \u0026nbsp;  'ham' in D    执行结果： True   In[51]: \u0026nbsp;  2 in D    执行结果： False   获取字段数据 In[52]: \u0026nbsp;  D = {'spam':2, 'ham': 1, 'eggs': 3} D['eggs']    执行结果： 3   In[53]: \u0026nbsp;  D.get('spam')    执行结果： 2   当使用 [] 方式获取值时，如果字典不包含 key 时，会产生异常。\n使用 get 方法获取值时，如果字典不包含 key 时，会返回 None。\n可以给 get 方法传入一个默认值，如果字典不包含 key 时，会返回传入的默认值。\nIn[54]: \u0026nbsp;  D['toast']    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mKeyError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-54-67654c94aa0d\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mD\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m\u0026#39;toast\u0026#39;\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mKeyError\u001b[0m: \u0026#39;toast\u0026#39;   In[55]: \u0026nbsp;  D.get('toast'), D.get('toast', 88)    执行结果： (None, 88)   当使用一个不存在的 key 是会发生错误时，可以使用如下方式处理\n 使用 if 判断来避免错误 使用 try 对异常进行捕获  In[56]: \u0026nbsp;  if (2,4,6) in DM: print(DM[(2,4,6)]) else: print(0)    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mNameError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-56-989f0481fb95\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 2\u001b[0;31m \u001b[0;32mif\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m6\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mDM\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[1;32m 3\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mDM\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m6\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 4\u001b[0m \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 5\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;31mNameError\u001b[0m: name \u0026#39;DM\u0026#39; is not defined   In[57]: \u0026nbsp;  try: print(DM[(2,4,6)]) except KeyError: print(0)    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mNameError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-57-bab22ceab466\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 2\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mDM\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m6\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[1;32m 3\u001b[0m \u001b[0;32mexcept\u001b[0m \u001b[0mKeyError\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 4\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;31mNameError\u001b[0m: name \u0026#39;DM\u0026#39; is not defined   返回所有的 key 或 value In[58]: \u0026nbsp;  list(D.keys())    执行结果： [\u0026#39;spam\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;eggs\u0026#39;]   In[59]: \u0026nbsp;  D.values(), list(D.values())    执行结果： (dict_values([2, 1, 3]), [2, 1, 3])   In[60]: \u0026nbsp;  print(D.items()) print(list(D.items()))    执行结果： dict_items([(\u0026#39;spam\u0026#39;, 2), (\u0026#39;ham\u0026#39;, 1), (\u0026#39;eggs\u0026#39;, 3)]) [(\u0026#39;spam\u0026#39;, 2), (\u0026#39;ham\u0026#39;, 1), (\u0026#39;eggs\u0026#39;, 3)]    字典修改 In[61]: \u0026nbsp;  D['ham'] = ['grill', 'bake', 'fry'] D    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;eggs\u0026#39;: 3}   In[62]: \u0026nbsp;  del D['eggs'] D    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;]}   In[63]: \u0026nbsp;  D['bb'] = 'bbbb' D    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;bb\u0026#39;: \u0026#39;bbbb\u0026#39;}   In[64]: \u0026nbsp;  print(D) D2 = {'bb':'b2b2','a':'aa'} D.update(D2) print(D)    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;bb\u0026#39;: \u0026#39;bbbb\u0026#39;} {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;bb\u0026#39;: \u0026#39;b2b2\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;aa\u0026#39;}    In[65]: \u0026nbsp;  print(D) D.pop('ham') print(D)    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;bb\u0026#39;: \u0026#39;b2b2\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;aa\u0026#39;} {\u0026#39;spam\u0026#39;: 2, \u0026#39;bb\u0026#39;: \u0026#39;b2b2\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;aa\u0026#39;}    ** 对于字典的 key 不要求必须是字符串类型，人也一种不可变对象类型都可以作为 key。比如我们可以使用 tuple ** In[66]: \u0026nbsp;  DM = {} DM[(1,2,3)] = 88 DM[(4,5,6)] = 99 DM    执行结果： {(1, 2, 3): 88, (4, 5, 6): 99}   In[67]: \u0026nbsp;  l = tuple([4,5,6]) DM[l]    执行结果： 99   排序输出 dict 是 hash 存储，本身没有顺序，也不能进行排序。但是可以将 keys() 函数返回的所有 key 转换成 list，然后排序输出 In[68]: \u0026nbsp;  D    执行结果： {\u0026#39;spam\u0026#39;: 2, \u0026#39;bb\u0026#39;: \u0026#39;b2b2\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;aa\u0026#39;}   In[69]: \u0026nbsp;  ks = D.keys() for k in sorted(ks): print(k, D[k])    执行结果： a aa bb b2b2 spam 2    $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/04-string/",
	"title": "Python学习 04：python 字符串类型",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "字符串是 Python 中最常用的数据类型。我们可以使用引号(\u0026lsquo;或\u0026rdquo;)来创建字符串。\n 字符串字面量 字符串操作 字符串格式化 字符串转换 模式匹配（正则表达式）介绍  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  字面量 python 中单引号和双引号是一样的 In[1]: \u0026nbsp;  'span\u0026quot;\u0026quot;m', \u0026quot;It's\u0026quot;    执行结果： (\u0026#39;span\u0026#34;\u0026#34;m\u0026#39;, \u0026#34;It\u0026#39;s\u0026#34;)   可以使用 ''' 或 \u0026quot;\u0026quot;\u0026quot; 创建字符串 In[2]: \u0026nbsp;  '''aaaa''', \u0026quot;\u0026quot;\u0026quot;bbbb\u0026quot;\u0026quot;\u0026quot;    执行结果： (\u0026#39;aaaa\u0026#39;, \u0026#39;bbbb\u0026#39;)   带有转义字符的字符串，会将 \\ 看做转义标识 In[3]: \u0026nbsp;  \u0026quot;a\\tb\\nc\\0m\u0026quot;    执行结果： \u0026#39;a\\tb\\nc\\x00m\u0026#39;   原始字符串，以 r 开头并不会将 \\ 看做转义标识 In[4]: \u0026nbsp;  r\u0026quot;a\\b\\c\u0026quot; #    执行结果： \u0026#39;a\\\\b\\\\c\u0026#39;   bytes 字符串，，以 b 开头 In[5]: \u0026nbsp;  b'sp\\x01am'    执行结果： b\u0026#39;sp\\x01am\u0026#39;   Unicode 字符串，以 u 或 U 开头 In[6]: \u0026nbsp;  u'eggs\\u0020spam'    执行结果： \u0026#39;eggs spam\u0026#39;   多行字符串 In[7]: \u0026nbsp;  s = \u0026quot;\u0026quot;\u0026quot;今天天气正好， 我们去打球吧。 这是个好主意\u0026quot;\u0026quot;\u0026quot; s    执行结果： \u0026#39;今天天气正好，\\n 我们去打球吧。\\n这是个好主意\u0026#39;   In[8]: \u0026nbsp;  print(s)    执行结果： 今天天气正好， 我们去打球吧。 这是个好主意    In[9]: \u0026nbsp;  print('''aaaa bbbb ddddd ccccc''')    执行结果： aaaa bbbb ddddd ccccc    转义特殊字符串 在需要在字符中使用特殊字符时，python用反斜杠()转义字符。如下表：\n   转义字符 描述 示例     (在行尾时) 续行符    \\n 换行    \\ 反斜杠符号    \\\u0026rsquo; 单引号    \\\u0026rdquo; 双引号    \\a 响铃    \\b 退格(Backspace)    \\f 换页    \\r 回车    \\t 横向制表符    \\v 纵向制表符    \\x 十六进制数，yy代表的字符，例如：\\x0a代表换行    \\o 八进制数，yy代表的字符，例如：\\o12代表换行    \\0 空    \\u 16位 Unicode 字符    \\U 32位 Unicode 字符      原始字符串抑制转义\n In[10]: \u0026nbsp;  s = 'a\\nb\\tc' s    执行结果： \u0026#39;a\\nb\\tc\u0026#39;   In[11]: \u0026nbsp;  print(s)    执行结果： a b\tc    In[12]: \u0026nbsp;  len(s)    执行结果： 5   In[13]: \u0026nbsp;  '\\0'    执行结果： \u0026#39;\\x00\u0026#39;   In[14]: \u0026nbsp;  len(r'a\\nb\\tc'), len('a\\nb\\tc')    执行结果： (7, 5)   字符串运算符 下表实例变量a值为字符串 \u0026ldquo;Hello\u0026rdquo;，b变量值为 \u0026ldquo;Python\u0026rdquo;：\n   操作符 描述 实例     + 字符串连接 a + b 输出结果： HelloPython   * 重复输出字符串 a*2 输出结果：HelloHello   [] 通过索引获取字符串中字符 a[1] 输出结果 e   [ : ] 截取字符串中的一部分 a[1:4] 输出结果 ell   in 成员运算符 - 如果字符串中包含给定的字符返回 True \u0026lsquo;H\u0026rsquo; in a 输出结果 1   not in 成员运算符 - 如果字符串中不包含给定的字符返回 True \u0026rsquo;M\u0026rsquo; not in a 输出结果 1   % 格式字符串 请看下一节内容。    In[15]: \u0026nbsp;  'abc' + 'def'    执行结果： \u0026#39;abcdef\u0026#39;   In[16]: \u0026nbsp;  'Ni' * 4    执行结果： \u0026#39;NiNiNiNi\u0026#39;   In[17]: \u0026nbsp;  print('-' * 80)    执行结果： --------------------------------------------------------------------------------    In[18]: \u0026nbsp;  myjob = \u0026quot;hacker\u0026quot; for c in myjob: print(c, end=' ')    执行结果： h a c k e r    判断是否子串 In[19]: \u0026nbsp;  'k' in myjob    执行结果： True   In[20]: \u0026nbsp;  'z' in myjob    执行结果： False   In[21]: \u0026nbsp;  'spam' in 'abcspamdef'    执行结果： True   索引和切割 S[i]: 抽取第 i 个字符\nS[i:j]: 抽取索引为 i 到 j 的子串（包含 i 不包含 j）\nS[i:]: 抽取索引为 i 之后的子串（包含 i）\nS[:j]: 抽取索引为 j 之前的子串（不包含 j）\nS[:]: 抽取整个字符串\nS[i:j:k]: 抽取索引为 i 到 j 的子串（包含 i 不包含 j），步长为 k\nS[::k]: 抽取整个字符串，步长为 k\nS[::-1]: 反向抽取整个字符串\nIn[22]: \u0026nbsp;  S = 'spam' S[0], S[-2]    执行结果： (\u0026#39;s\u0026#39;, \u0026#39;a\u0026#39;)   In[23]: \u0026nbsp;  S[1:3], S[1:], S[:-1]    执行结果： (\u0026#39;pa\u0026#39;, \u0026#39;pam\u0026#39;, \u0026#39;spa\u0026#39;)   In[24]: \u0026nbsp;  S[0:4:2], S[::2], S[::-1]    执行结果： (\u0026#39;sa\u0026#39;, \u0026#39;sa\u0026#39;, \u0026#39;maps\u0026#39;)   字符串不可改变性 任何操作都不能改变原始字符串对象本身，都是产生新的字符串对象。当我们用变量时，会有一种改变字符串对象的错觉，这时其实是将变量指向了一个新的字符串对象。 In[25]: \u0026nbsp;  S = 'spam' S[0] = 'x'    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-25-7ffb2cc33b47\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0mS\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m\u0026#39;spam\u0026#39;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 2\u001b[0;31m \u001b[0mS\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m\u0026#39;x\u0026#39;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: \u0026#39;str\u0026#39; object does not support item assignment   In[26]: \u0026nbsp;  S = S + 'SPAM!' # 并没有改变原来的 'spam' 字符串对象，而是产生了一个新的字符串对象，并将变量 S 指向新对象 S    执行结果： \u0026#39;spamSPAM!\u0026#39;   In[27]: \u0026nbsp;  S.replace('am', 'xxxx'), S # 字符串的任何操作都不能改变源字符串对象    执行结果： (\u0026#39;spxxxxSPAM!\u0026#39;, \u0026#39;spamSPAM!\u0026#39;)   更多例子。注意这里的 spam 和 eggs 在内存中存储是不一样的，感兴趣的可以 google 一下。 In[28]: \u0026nbsp;  B = b'spam' S = 'eggs' type(B), type(S)    执行结果： (bytes, str)   In[29]: \u0026nbsp;  B, S    执行结果： (b\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;)   In[30]: \u0026nbsp;  B[0], S[0]    执行结果： (115, \u0026#39;e\u0026#39;)   In[31]: \u0026nbsp;  B[1:], S[1:]    执行结果： (b\u0026#39;pam\u0026#39;, \u0026#39;ggs\u0026#39;)   In[32]: \u0026nbsp;  list(B), list(S)    执行结果： ([115, 112, 97, 109], [\u0026#39;e\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;s\u0026#39;])   字符串转换 数字转换 和其他动态类型语言不同，python 中字符串对象和数值对象是不能直接做运算的，必须进行显示转换。这是 python 和其他动态类型语言不同的地方，它的类型动态性只是表现在变量上面，对于对象本身必须是特定类型，并且是强类型的。对于变量和对象的关系请看前面的文章。\n以下是一些实例：\nIn[33]: \u0026nbsp;  '42' + 1    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-33-5d43c357ae74\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0;34m\u0026#39;42\u0026#39;\u001b[0m \u001b[0;34m\u0026#43;\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: must be str, not int   In[34]: \u0026nbsp;  int('42'), str(42)    执行结果： (42, \u0026#39;42\u0026#39;)   In[35]: \u0026nbsp;  repr(42)    执行结果： \u0026#39;42\u0026#39;   In[36]: \u0026nbsp;  print(str('spam'), repr('spam'))    执行结果： spam \u0026#39;spam\u0026#39;    这里我们使用到了 str 和 repr 两个字符串函数，发现他们返回的东西几乎一样，其实他们是有差别的:\n str() 的输出追求可读性，输出格式要便于理解，适合用于输出内容到用户终端。 repr() 的输出追求明确性，除了对象内容，还需要展示出对象的数据类型信息，适合开发和调试阶段使用。  有兴趣的可以使用 help 方法查看两者的区别。\n以下是更多实例：\nIn[37]: \u0026nbsp;  int(\u0026quot;42\u0026quot;) + 1    执行结果： 43   In[38]: \u0026nbsp;  \u0026quot;42\u0026quot; + str(1)    执行结果： \u0026#39;421\u0026#39;   In[39]: \u0026nbsp;  \u0026quot;1.234E-10\u0026quot;, float(\u0026quot;1.234E-10\u0026quot;)    执行结果： (\u0026#39;1.234E-10\u0026#39;, 1.234e-10)   In[40]: \u0026nbsp;  B = '1101' I = 0 while B!='': I = I*2 + (ord(B[0]) - ord('0')) B = B[1:] I    执行结果： 13   In[41]: \u0026nbsp;  int('1101', 2), bin(13)    执行结果： (13, \u0026#39;0b1101\u0026#39;)   字符编码转换 对于单个字符可以使用 ord() 函数获取他的 ASCII 码值，一个 ASCII 码值使用 chr() 得到对于的字符。 In[42]: \u0026nbsp;  ord('s'), chr(115)    执行结果： (115, \u0026#39;s\u0026#39;)   将字符转换成 ASCII 码过后，可以进行算数运算。但是直接使用字符做算数运算会报错，这里和 C 语言是不一样的。 In[43]: \u0026nbsp;  chr(ord('5')+1)    执行结果： \u0026#39;6\u0026#39;   In[44]: \u0026nbsp;  ord('5') - ord('0')    执行结果： 5   In[45]: \u0026nbsp;  '5' - '0'    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-45-f436e1546941\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0;34m\u0026#39;5\u0026#39;\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0;34m\u0026#39;0\u0026#39;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: unsupported operand type(s) for -: \u0026#39;str\u0026#39; and \u0026#39;str\u0026#39;   字符串方法调用 使用 dir(\u0026quot;\u0026quot;) 查看字符串类型有哪些支持的内置方法。每个方法的具体使用方式再使用 help() 查看。这里只列举部分方法使用 In[46]: \u0026nbsp;  # 字符串长度 len('abc')    执行结果： 3   In[47]: \u0026nbsp;  # 分隔字符串 'a,b,c'.split(',')    执行结果： [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]   In[48]: \u0026nbsp;  # 字符串拼接 '\u0026gt;'.join(['a','b','c'])    执行结果： \u0026#39;a\u0026gt;b\u0026gt;c\u0026#39;   字符串格式化  格式化表达式：\u0026rsquo;\u0026hellip;%s\u0026hellip;\u0026rsquo; %(values) 格式化方法调用：\u0026rsquo;\u0026hellip;{}\u0026hellip;\u0026lsquo;.format(values)  格式化符号\n   符 号 描述     %c 格式化字符及其ASCII码   %s 格式化字符串   %r 和 s 类似，但是使用 repr 输出   %d 格式化整数   %i 格式化整数   %u 格式化无符号整型   %o 格式化无符号八进制数   %x 格式化无符号十六进制数   %X 格式化无符号十六进制数（大写）   %f 格式化浮点数字，可指定小数点后的精度   %F 和 f 类似，但是字母大写   %e 用科学计数法格式化浮点数   %E 作用同%e，用科学计数法格式化浮点数   %g %f和%e的简写   %G %f 和 %E 的简写   %p 用十六进制数格式化变量的地址   %% 输出 %     基础格式化语法\n%[(keyname)][flags][width][.precision]typecode\n高级格式化语法\n {fieldname component !conversionflag :formatspec} formatspec: [[fill]align][sign][#][0][width][,][.precision][typecode]\n   格式化表达式 以下是一些实例\nIn[49]: \u0026nbsp;  x = 1234 'integers: ...%d...%-6d...%06d' % (x,x,x)    执行结果： \u0026#39;integers: ...1234...1234 ...001234\u0026#39;   In[50]: \u0026nbsp;  x = 1.23456789 '%e | %f |%g' %(x,x,x)    执行结果： \u0026#39;1.234568e\u0026#43;00 | 1.234568 |1.23457\u0026#39;   In[51]: \u0026nbsp;  '%E' % x    执行结果： \u0026#39;1.234568E\u0026#43;00\u0026#39;   更多格式化类型使用，请自行实践 In[52]: \u0026nbsp;  '%s' % x, str(x)    执行结果： (\u0026#39;1.23456789\u0026#39;, \u0026#39;1.23456789\u0026#39;)   In[53]: \u0026nbsp;  # 基于字典的格式化 'a=%(a)d; b=%(bb)s' % {'a': 1, 'bb':'bbbb'}    执行结果： \u0026#39;a=1; b=bbbb\u0026#39;   vars() 函数返回所有的变量 In[54]: \u0026nbsp;  '%(x)s or %(S)s' % vars()    执行结果： \u0026#39;1.23456789 or eggs\u0026#39;   格式化方法 In[55]: \u0026nbsp;  template = '{0}, {1}, {2}' template.format('spam', 'orange', 'apple')    执行结果： \u0026#39;spam, orange, apple\u0026#39;   In[56]: \u0026nbsp;  template = '{}, {}, {}' template.format('spam', 'orange', 'apple')    执行结果： \u0026#39;spam, orange, apple\u0026#39;   In[57]: \u0026nbsp;  template = '{a}, {b}, {c}' template.format(a='spam', c='orange', b='apple')    执行结果： \u0026#39;spam, apple, orange\u0026#39;   In[58]: \u0026nbsp;  template = '{a}, {b}, {0}' template.format('spam', a='orange', b='apple')    执行结果： \u0026#39;orange, apple, spam\u0026#39;   添加关键字、属性和偏移量 In[59]: \u0026nbsp;  import sys 'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})    执行结果： \u0026#39;My laptop runs linux\u0026#39;   In[60]: \u0026nbsp;  'My {map[kind]} runs {sys.platform}'.format(sys=sys, map={'kind': 'laptop'})    执行结果： \u0026#39;My laptop runs linux\u0026#39;   高级格式化 In[61]: \u0026nbsp;  '{:,d}'.format(9999999999)    执行结果： \u0026#39;9,999,999,999\u0026#39;   bytearray 操作 对于 bytearray 这里列举一些使用的实例，不做深入介绍。 In[62]: \u0026nbsp;  S = 'spam' # C = bytearray(S) # 此语句在2.6+正常，但是在 3.X 中会语法错误 C = bytearray(S, 'latin1') C    执行结果： bytearray(b\u0026#39;spam\u0026#39;)   In[63]: \u0026nbsp;  C = bytearray(b'spam') C    执行结果： bytearray(b\u0026#39;spam\u0026#39;)   In[64]: \u0026nbsp;  # bytearray 可以修改 C[0] = 10     In[65]: \u0026nbsp;  # 但是修改必须是整数，不能是字符 C[0] = '1'    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-65-7c46a9aa2011\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0;31m# 但是修改必须是整数，不能是字符\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 2\u001b[0;31m \u001b[0mC\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m\u0026#39;1\u0026#39;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: an integer is required   In[66]: \u0026nbsp;  C[0] = ord('1') C[1] = b'Y'[0] C    执行结果： bytearray(b\u0026#39;1Yam\u0026#39;)   In[67]: \u0026nbsp;  C    执行结果： bytearray(b\u0026#39;1Yam\u0026#39;)   模式匹配 模式匹配也叫正则表达式，也是字符串处理的一种方式，由于其强大功能，在实际项目中被普遍使用。现在不论是什么语言都有提供模式匹配的功能，并且在正则表达式的功能和语法上都打通大同小异。由于其语言的独立性和重要性后面会单独讲解，这里为了字符串操作的完整性做简单的实例展示，不解释。 查找匹配 In[68]: \u0026nbsp;  import re s='123abc456eabc789' print(re.findall(r'abc',s)) s = 'I have a dog , I have a cat' print(re.findall( r'I have a (?:dog|cat)' , s ))    执行结果： [\u0026#39;abc\u0026#39;, \u0026#39;abc\u0026#39;] [\u0026#39;I have a dog\u0026#39;, \u0026#39;I have a cat\u0026#39;]    使用compile加速 In[69]: \u0026nbsp;  s='111,222,aaa,bbb,555,ccc333,444ddd' rule=r'\\b\\d+\\b' compiled_rule=re.compile(rule) compiled_rule.findall(s)    执行结果： [\u0026#39;111\u0026#39;, \u0026#39;222\u0026#39;, \u0026#39;555\u0026#39;]   匹配数字开头 In[71]: \u0026nbsp;  s='123 456/n789 012/n345 678' rc=re.compile(r'^\\d+') rc.findall(s)    执行结果： [\u0026#39;123\u0026#39;]   小结 一篇文章不可能把字符串的方方面面都包括进来，比如字符串在 python 的存储、不同字符集的转行等。同时刚开始我们也不能用到所有的这些知识内容，所以在刚开始重点应该放在实际编码操作和整体知识体系的建立上，等熟练了或后面遇到相关问题了，在深入研究某块内容。希望对大家能有所帮助。 $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/03-number/",
	"title": "Python学习 03：python 数值类型",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "每种语言都会有其内置的基本数据类型，我们在学一门语言时，首先需要掌握其基本数据类型，学习 python 也不例外。python 的基本类型类型介绍在前一篇已经做过介绍了，这篇详细介绍其中的 数值类型。\n python 变量 几种数值类型：整数、浮点数、小数、分数、集合 数值运算符 数值工具模块   建议：在编程初期阶段完全是一个技术活，只要孰能生巧就行，所以在开始学习一门编程语言时一定要动手实践和操作。\n \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  变量 在 python 中创建一个变量很简单只需要简单的一个赋值语句就可以创建一个变量。如： In[1]: \u0026nbsp;  v = 3     这条语句包含三个步骤：\n 创建一个值为 3 的新对象 创建一个变量 a (如果之前不存在） 关联变量 a 到 新对象  python 是一个动态类型语言，所以在创建变量的时候不需要指定类型，只要在使用之前创建它就行。这里有一个比较容易混淆的地方：数据的类型信息是存储在对象中，而不是在变量中 ，变量只是 系统表 中的一个实体，用于连接到对象。其实在 python 中我们可以将变量看做一个指针或引用，指向或引用到所赋值的对象内存块，而具体的数据类型、数据值等信息全部存储在对象内存块中。这样大家就能更好的理解 python 的动态数据类型。\nIn[2]: \u0026nbsp;  m = 3 n = m m,n    执行结果： (3, 3)   In[3]: \u0026nbsp;  m = 'aaa' m,n    执行结果： (\u0026#39;aaa\u0026#39;, 3)   变量用于计算实例 In[4]: \u0026nbsp;  a = 3 b = 4     In[5]: \u0026nbsp;  a+1, a-1    执行结果： (4, 2)   In[6]: \u0026nbsp;  b*3, b/2    执行结果： (12, 2.0)   In[7]: \u0026nbsp;  a%2, b**2    执行结果： (1, 16)   In[8]: \u0026nbsp;  2+4.0, 2.0**b    执行结果： (6.0, 16.0)   如果在使用变量之前没有创建过变量将会得到错误 In[9]: \u0026nbsp;  c*2    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mNameError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-9-4a4053e8f551\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mc\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mNameError\u001b[0m: name \u0026#39;c\u0026#39; is not defined   使两个变量引用到同一个可更改对象，用 is 和 == 运算符比较两个变量的结果（is 计算是否为同一个对象；== 计算是否为相同的值） In[10]: \u0026nbsp;  L1 = [2,3,4] L2 = L1 L1,L2    执行结果： ([2, 3, 4], [2, 3, 4])   In[11]: \u0026nbsp;  L1[0] = 24 L1,L2, (L1 is L2), (L1==L2)    执行结果： ([24, 3, 4], [24, 3, 4], True, True)   现在我们创建两个内容一样的两个对象，分别用两个变量引用它们，再次使用用 is 和 == 运算符比较两个变量的结果 In[12]: \u0026nbsp;  L3 = [2,3,4] L4 = [2,3,4] L3,L4, L3 is L4, L3==L4    执行结果： ([2, 3, 4], [2, 3, 4], False, True)   注意一下代码执行结果 In[13]: \u0026nbsp;  X = 42 Y = 42 X,Y, X==Y, X is Y    执行结果： (42, 42, True, True)   这里我们的 python 表达式写的是创建了两个值为 42 的对象，但是 X 和 Y 的 is 运算为什么是 True 呢？这是由于 python 会缓存和重复使用数字和字符串对象。我们可以使用 sys.getrefcount 查看一个对象被使用了多少次（以下的执行结果可能会每次不一样）。 In[14]: \u0026nbsp;  import sys sys.getrefcount(42)    执行结果： 36   In[15]: \u0026nbsp;  X1 = 42 X2 = 42 sys.getrefcount(42)    执行结果： 40   变量数据格式化输出 In[16]: \u0026nbsp;  a = 3; b = 4 print(b/(2.0+a))    执行结果： 0.8    In[17]: \u0026nbsp;  num = 1 / 3.0 '%e' % num    执行结果： \u0026#39;3.333333e-01\u0026#39;   In[18]: \u0026nbsp;  '%4.2f' % num    执行结果： \u0026#39;0.33\u0026#39;   In[19]: \u0026nbsp;  '{0:4.2f}'.format(num)    执行结果： \u0026#39;0.33\u0026#39;   基本数值类型 python 支持的数值类型比较多，大家不用一次性全部弄懂，只需要掌握集中基本的就行，剩下的在需要的时候在学习就可以了。\n   实例 类型     1234,-24,0,99999999 整数(不限大小)   1.23,1.0,3.14e-10,4E210,4.0e+210 浮点数   0o177, 0x9ff, 0b101010 八进制（Octal）, 十六进制（hex）, 二进制（binary）   3+4j, 3.0+4.0j, 3J 复数   set(\u0026lsquo;spam\u0026rsquo;), {1,2,3,4} 集合   Decimal(\u0026lsquo;1.0\u0026rsquo;), Fraction(1,3) 扩展类型：小数、分数   bool(x), True, False Boolean 和 常亮    运算符 python 中有很运算符供我们使用，这里简答的做下分类介绍\n算数运算符    运算符 描述 实例     + 加 - 两个对象相加 10+20 输出结果 30   - 减 - 得到负数或是一个数减去另一个数 10 - 20 输出结果 -10   * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 10 * 20 输出结果 200   / 除 - x除以y 20 / 10 输出结果 2   % 取模 - 返回除法的余数 10 % 20 输出结果 0   ** 幂 - 返回x的y次幂 10**20 为10的20次方， 输出结果 100000000000000000000   // 取整除 - 返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0    使用举例： In[20]: \u0026nbsp;  40 + 3.1    执行结果： 43.1   In[21]: \u0026nbsp;  1+2*3    执行结果： 7   In[22]: \u0026nbsp;  2*3**2    执行结果： 18   In[23]: \u0026nbsp;  3**9    执行结果： 19683   In[24]: \u0026nbsp;  10 / 4    执行结果： 2.5   In[25]: \u0026nbsp;  10/4.0    执行结果： 2.5   In[26]: \u0026nbsp;  # 计算的数据类型 10//3, 10//3.0, 10%3, 10%3.0    执行结果： (3, 3.0, 1, 1.0)   比较云算法    运算符 描述 实例     == 等于 - 比较对象是否相等 (10 == 20) 返回 False。   != 不等于 - 比较两个对象是否不相等 (10 != 20) 返回 true.   \u0026lt;\u0026gt; 不等于 - 比较两个对象是否不相等 (10 \u0026lt;\u0026gt; 20) 返回 true。这个运算符类似 != 。   \u0026gt; 大于 - 返回x是否大于y (10 \u0026gt; 20) 返回 False。   \u0026lt; 小于 - 返回x是否小于y。 (10 \u0026lt; 20) 返回 true。   \u0026gt;= 大于等于 - 返回x是否大于等于y。 (10 \u0026gt;= 20) 返回 False。   \u0026lt;= 小于等于 - 返回x是否小于等于y。 (10 \u0026lt;= 20) 返回 true。     所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。\n In[27]: \u0026nbsp;  1\u0026lt;2    执行结果： True   In[28]: \u0026nbsp;  2.0\u0026gt;=1    执行结果： True   In[29]: \u0026nbsp;  2.0==2.0    执行结果： True   In[30]: \u0026nbsp;  2.0!=2.0    执行结果： False   链式写法 In[31]: \u0026nbsp;  x = 2 y = 4 z = 6     In[32]: \u0026nbsp;  x\u0026lt;y\u0026lt;z, x\u0026lt;y and y\u0026lt;z    执行结果： (True, True)   In[33]: \u0026nbsp;  x\u0026lt;y\u0026gt;z, x\u0026lt;y and y\u0026gt;z    执行结果： (False, False)   In[34]: \u0026nbsp;  1==2\u0026lt;3 # same as: 1==2 and 2\u0026lt;3    执行结果： False   在浮点数比较时，注意精度问题 In[35]: \u0026nbsp;  1.1+2.2 == 3.3    执行结果： False   In[36]: \u0026nbsp;  1.1+2.2    执行结果： 3.3000000000000003   In[37]: \u0026nbsp;  int(1.1+2.2) == int(3.3)    执行结果： True   赋值运算符    运算符 描述 实例     = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c   += 加法赋值运算符 c += a 等效于 c = c + a   -= 减法赋值运算符 c -= a 等效于 c = c - a   *= 乘法赋值运算符 c *= a 等效于 c = c * a   /= 除法赋值运算符 c /= a 等效于 c = c / a   %= 取模赋值运算符 c %= a 等效于 c = c % a   **= 幂赋值运算符 c **= a 等效于 c = c ** a   //= 取整除赋值运算符 c //= a 等效于 c = c // a     复制运算符左边必须是变量\n In[38]: \u0026nbsp;  a = 10 b = 20     In[39]: \u0026nbsp;  c = a +b c    执行结果： 30   In[40]: \u0026nbsp;  c += 3 c    执行结果： 33   如果复制运算符左边不是变量将会发生错误 In[41]: \u0026nbsp;  1 = a+b    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-41-3872f374d6ae\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m1\u001b[0m \u001b[0;31m 1 = a\u0026#43;b\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m can\u0026#39;t assign to literal    位运算符    运算符 描述 实例     \u0026amp; 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 (a \u0026amp; b) 输出结果 12 ，二进制解释： 0000 1100   \u0026#124; 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 (a \u0026#124; b) 输出结果 61 ，二进制解释： 0011 1101   ^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001   ~ 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1 (~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式。   \u0026lt;\u0026lt; 左移动运算符：运算数的各二进位全部左移若干位，由 \u0026lt;\u0026lt; 右边的数字指定了移动的位数，高位丢弃，低位补0。 a \u0026lt;\u0026lt; 2 输出结果 240 ，二进制解释： 1111 0000   \u0026gt;\u0026gt; 右移动运算符：把\u0026rdquo;\u0026gt;\u0026gt;\u0026ldquo;左边的运算数的各二进位全部右移若干位，\u0026gt;\u0026gt; 右边的数字指定了移动的位数 a \u0026gt;\u0026gt; 2 输出结果 15 ，二进制解释： 0000 1111    In[42]: \u0026nbsp;  x = 1 x\u0026lt;\u0026lt;2    执行结果： 4   In[43]: \u0026nbsp;  x|2    执行结果： 3   In[44]: \u0026nbsp;  x \u0026amp; 1    执行结果： 1   In[45]: \u0026nbsp;  X = 0b0001     In[46]: \u0026nbsp;  X\u0026lt;\u0026lt;2    执行结果： 4   In[47]: \u0026nbsp;  bin(X\u0026lt;\u0026lt;2)    执行结果： \u0026#39;0b100\u0026#39;   In[48]: \u0026nbsp;  bin(X|0b010)    执行结果： \u0026#39;0b11\u0026#39;   In[49]: \u0026nbsp;  bin(X \u0026amp; 0b1)    执行结果： \u0026#39;0b1\u0026#39;   In[50]: \u0026nbsp;  X = 0xFF bin(X)    执行结果： \u0026#39;0b11111111\u0026#39;   In[51]: \u0026nbsp;  bin(X ^ 0b10101010)    执行结果： \u0026#39;0b1010101\u0026#39;   逻辑运算符    运算符 逻辑表达式 描述 实例     and x and y 布尔\u0026rdquo;与\u0026rdquo; - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 (10 and 20) 返回 20。   or x or y 布尔\u0026rdquo;或\u0026rdquo; - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 (10 or 20) 返回 10。   not not x 布尔\u0026rdquo;非\u0026rdquo; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 not(10 and b20) 返回 False    逻辑运算符的结果是真或假，首先看看 python 中如何表示真和假\npython 提供了 bool 类型来表示真假，且这个类型只有两个常亮值：True 和 False\nIn[52]: \u0026nbsp;  type(True), type(False)    执行结果： (bool, bool)   In[53]: \u0026nbsp;  isinstance(True, int)    执行结果： True    True 和 False 在 python 内部使用整数 1 和 0 表示，也就是说它们的值和整数 1、0 相等。但是他们和整数 1、0 是不同的对象\n In[54]: \u0026nbsp;  True == 1, False==0    执行结果： (True, True)   In[55]: \u0026nbsp;  True is 1, False is 0    执行结果： (False, False)    由于 True 和 False 的值等于 1 和 0 ，所以他们可以参与部分数值计算。但是强烈建议不要这样使用\n In[56]: \u0026nbsp;  True + 4, False / 4    执行结果： (5, 0.0)   逻辑计算实例： In[57]: \u0026nbsp;  (10 and 20), not(10 and 20)    执行结果： (20, False)   In[58]: \u0026nbsp;  True and False, True or False    执行结果： (False, True)   成员运算符    运算符 描述 实例     in 如果在指定的序列中找到值返回 True，否则返回 False。 x 在 y 序列中 , 如果 x 在 y 序列中返回 True。   not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。    In[59]: \u0026nbsp;  'a' in 'abb', 'a' in 'bbb'    执行结果： (True, False)   In[60]: \u0026nbsp;  1 in [1,2,2,3], 0 not in [1,2,2,3]    执行结果： (True, True)   身份运算符    运算符 描述 实例     is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False   is not is not 是判断两个标识符是不是引用自不同对象 x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。    In[61]: \u0026nbsp;  'a' is 'a'    执行结果： True   In[62]: \u0026nbsp;  [1,1] is [1,1], [12] is not [1,1]    执行结果： (False, True)   优先级 当在表达式里面同时使用多个运算符时，需要注意各个运算符的优先级，优先级高的将被优先执行。以下表格列出了从最高到最低优先级的所有运算符：\n   运算符 描述     ** 指数 (最高优先级)   ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)   * / % // 乘，除，取模和取整除   + - 加法减法   \u0026gt;\u0026gt; \u0026lt;\u0026lt; 右移，左移运算符   \u0026amp; 位 \u0026lsquo;AND\u0026rsquo;   ^ \u0026#124; 位运算符   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 比较运算符   \u0026lt;\u0026gt; == != 等于运算符   = %= /= //= -= += *= **= 赋值运算符   is is not 身份运算符   in not in 成员运算符   not or and 逻辑运算符    **当需要改变表达式执行顺序的时候，可以使用 () **\nIn[63]: \u0026nbsp;  (1+2)*3, 1+2*3    执行结果： (9, 7)   In[64]: \u0026nbsp;  (2*3)**2, 2*3**2    执行结果： (36, 18)   数值类型转换 In[65]: \u0026nbsp;  int(3.1415)    执行结果： 3   In[66]: \u0026nbsp;  float(3)    执行结果： 3.0   进制转换 python 可以支持任意进制的数值，常用的有二进制、八进制、十进制、十六进制，进制之间可以任意转换。 In[67]: \u0026nbsp;  0o1, 0o20, 0o377 # 8进制    执行结果： (1, 16, 255)   In[68]: \u0026nbsp;  0x01, 0x10, 0xFF # 16进制    执行结果： (1, 16, 255)   In[69]: \u0026nbsp;  0b1, 0b10000, 0b11111111 # 2进制    执行结果： (1, 16, 255)   In[70]: \u0026nbsp;  64, 0o100, 0x40, 0b1000000    执行结果： (64, 64, 64, 64)   In[71]: \u0026nbsp;  # 十进制转换到 8、16、2 进制 oct(64), hex(64), bin(64)    执行结果： (\u0026#39;0o100\u0026#39;, \u0026#39;0x40\u0026#39;, \u0026#39;0b1000000\u0026#39;)   In[72]: \u0026nbsp;  # 二进制转十进制 int('01010101', 2)    执行结果： 85   In[73]: \u0026nbsp;  # 获取数值的二进制位数 X = 99 bin(X), X.bit_length(), len(bin(X))-2    执行结果： (\u0026#39;0b1100011\u0026#39;, 7, 7)   In[74]: \u0026nbsp;  # 不同进制的字符串表示转换成数字 int('64'), int('100', 8), int('40',16), int('1000000', 2)    执行结果： (64, 64, 64, 64)   In[75]: \u0026nbsp;  eval('64'), eval('0o100'), eval('0x40'), eval('0b1000000')    执行结果： (64, 64, 64, 64)   In[76]: \u0026nbsp;  # 数值不同进制输出 '{0:o}, {1:x}, {2:b}'.format(64, 64, 64)    执行结果： \u0026#39;100, 40, 1000000\u0026#39;   In[77]: \u0026nbsp;  '%o, %x, %x, %X' % (64,64,255,255)    执行结果： \u0026#39;100, 40, ff, FF\u0026#39;   其他数值类型 复数 In[79]: \u0026nbsp;  1j * 1j    执行结果： (-1\u0026#43;0j)   In[80]: \u0026nbsp;  2+1j*3    执行结果： (2\u0026#43;3j)   In[81]: \u0026nbsp;  (2+1j) * 3    执行结果： (6\u0026#43;3j)   小数 由于浮点数的精度问题，在计算时没有办法绝对精确，这个时候就需要使用的小数类型。比如如下计算，我们都知道最后结果为 0，但是 python 的执行结果却不是 0。 In[82]: \u0026nbsp;  0.1+0.1+0.1 - 0.3    执行结果： 5.551115123125783e-17   In[83]: \u0026nbsp;  # python 中使用小数需要用到 decimal 模块 from decimal import Decimal Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')    执行结果： Decimal(\u0026#39;0.0\u0026#39;)   In[84]: \u0026nbsp;  Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30')    执行结果： Decimal(\u0026#39;0.00\u0026#39;)   对于传入 Decimal 是一个浮点数时，结果和我们预期会有些出入，大家使用的时候注意 In[85]: \u0026nbsp;  Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)    执行结果： Decimal(\u0026#39;2.775557561565156540423631668E-17\u0026#39;)   对于一些无限小数，可以使用 decimal.getcontext().prec 指定精度（就是小数位数） In[86]: \u0026nbsp;  import decimal decimal.Decimal('1') / decimal.Decimal('7')    执行结果： Decimal(\u0026#39;0.1428571428571428571428571429\u0026#39;)   In[87]: \u0026nbsp;  decimal.getcontext().prec = 4 decimal.Decimal(1) / decimal.Decimal(7)    执行结果： Decimal(\u0026#39;0.1429\u0026#39;)   在处理进度的时候，可以结合 python 的 with 语句进行上下文管理，关于上下文的概念后面会详细讲解 In[88]: \u0026nbsp;  # 设置全局上下文精度 decimal.getcontext().prec = 4 print(decimal.Decimal('1.00') / decimal.Decimal('3.00')) with decimal.localcontext() as ctx: # 设置局部上下文精度，覆盖全局上下文精度 ctx.prec = 2 decimal.Decimal('1.00') / decimal.Decimal('3.00') print(decimal.Decimal('1.00') / decimal.Decimal('3.00')) # 当退出 with 语句的时候，局部上下文精度失效，返回全局上下文精度 print(decimal.Decimal('1.00') / decimal.Decimal('3.00')) decimal.Decimal('1.00') / decimal.Decimal('3.00')    执行结果： 0.3333 0.33 0.3333 Decimal(\u0026#39;0.3333\u0026#39;)   Fraction (分数) 在上面使用小数的时候，当遇到无限小数的时候，即使使用 Decimal 还是不能完全精确表示一个数，这个时候 python 为我们提供了分数类型 In[89]: \u0026nbsp;  from fractions import Fraction x = Fraction(1,3) y = Fraction(4,6)     In[90]: \u0026nbsp;  x    执行结果： Fraction(1, 3)   In[91]: \u0026nbsp;  y    执行结果： Fraction(2, 3)   In[92]: \u0026nbsp;  print(y)    执行结果： 2/3    In[93]: \u0026nbsp;  x+y    执行结果： Fraction(1, 1)   In[94]: \u0026nbsp;  x-y    执行结果： Fraction(-1, 3)   In[95]: \u0026nbsp;  x*y    执行结果： Fraction(2, 9)   In[96]: \u0026nbsp;  Fraction('.25')    执行结果： Fraction(1, 4)   In[97]: \u0026nbsp;  Fraction(0.25)    执行结果： Fraction(1, 4)   In[98]: \u0026nbsp;  Fraction('1.25')    执行结果： Fraction(5, 4)   In[99]: \u0026nbsp;  Fraction('.25') + Fraction('1.25')    执行结果： Fraction(3, 2)   fractions 和 decimals 中的数值计算 In[100]: \u0026nbsp;  0.1+0.1+0.1 - 0.3    执行结果： 5.551115123125783e-17   In[101]: \u0026nbsp;  Fraction('0.1') + Fraction('0.1') + Fraction('0.1') - Fraction('0.3')    执行结果： Fraction(0, 1)   In[102]: \u0026nbsp;  Fraction(1,10) + Fraction(1,10) + Fraction(1,10) - Fraction(3,10)    执行结果： Fraction(0, 1)   In[103]: \u0026nbsp;  Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30')    执行结果： Decimal(\u0026#39;0.00\u0026#39;)   Frcation 转换 In[104]: \u0026nbsp;  # 浮点数 =\u0026gt; 分数 from fractions import Fraction print((2.5).as_integer_ratio()) f=2.5 z = Fraction(*f.as_integer_ratio()) # 构造函数 print(z) print(Fraction.from_float(1.75)) # from_float 静态方法    执行结果： (5, 2) 5/2 7/4    In[105]: \u0026nbsp;  x = Fraction(1, 3) x, x+z    执行结果： (Fraction(1, 3), Fraction(17, 6))   In[106]: \u0026nbsp;  float(x), float(x+z)    执行结果： (0.3333333333333333, 2.8333333333333335)   In[107]: \u0026nbsp;  x = Fraction(1, 3) x    执行结果： Fraction(1, 3)   In[108]: \u0026nbsp;  print(x + 2) # Fraction + int -\u0026gt; Fraction    执行结果： 7/3    In[109]: \u0026nbsp;  x + 2.0 # Fraction + float -\u0026gt; float    执行结果： 2.3333333333333335   In[110]: \u0026nbsp;  x + Fraction(3,4) # Fraction + Fraction -\u0026gt; Fraction    执行结果： Fraction(13, 12)   限制最大分母值 In[111]: \u0026nbsp;  Fraction('0.1')    执行结果： Fraction(1, 10)   In[112]: \u0026nbsp;  Fraction(*(0.1).as_integer_ratio())    执行结果： Fraction(3602879701896397, 36028797018963968)   In[113]: \u0026nbsp;  Fraction.from_float(0.1).limit_denominator(10)    执行结果： Fraction(1, 10)   集合 这里说的集合和其他语言里面的集合数据类型有所不同，更像是数学里面集合的概念，可以做一些集合运算。只是集合里面不能含有重复的值。 In[114]: \u0026nbsp;  x = set([1,2,3]) y = set([3,4,5])     In[115]: \u0026nbsp;  x==y    执行结果： False   In[116]: \u0026nbsp;  x\u0026gt;y    执行结果： False   In[117]: \u0026nbsp;  x\u0026lt;y    执行结果： False   In[118]: \u0026nbsp;  x-y    执行结果： {1, 2}   In[119]: \u0026nbsp;  x|y    执行结果： {1, 2, 3, 4, 5}   In[120]: \u0026nbsp;  x\u0026amp;y    执行结果： {3}   In[121]: \u0026nbsp;  x ^ y    执行结果： {1, 2, 4, 5}   In[122]: \u0026nbsp;  1 in x, 0 in x    执行结果： (True, False)   In[123]: \u0026nbsp;  z = x.intersection(y) z    执行结果： {3}   集合 和 list 是不同饿数据类型，尽管开起来相似，使用起来也相似，但是请他们确实是不同的数据类型，所以集合不能和 list 进行运算 In[124]: \u0026nbsp;  x | [6,7]    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-124-20f2eb6b3738\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mx\u001b[0m \u001b[0;34m|\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;36m6\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m7\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: unsupported operand type(s) for |: \u0026#39;set\u0026#39; and \u0026#39;list\u0026#39;   In[125]: \u0026nbsp;  x | {6,7}    执行结果： {1, 2, 3, 6, 7}   In[126]: \u0026nbsp;  type({1,2}), type({})    执行结果： (set, dict)   集合方法 In[127]: \u0026nbsp;  x.union({6,7})    执行结果： {1, 2, 3, 6, 7}   In[128]: \u0026nbsp;  x.union([6,7])    执行结果： {1, 2, 3, 6, 7}   In[129]: \u0026nbsp;  x.union(set([6,7]))    执行结果： {1, 2, 3, 6, 7}   In[130]: \u0026nbsp;  x.union((6,7))    执行结果： {1, 2, 3, 6, 7}   In[131]: \u0026nbsp;  x.intersection((3,6,7))    执行结果： {3}   In[132]: \u0026nbsp;  x.issubset(range(0,10))    执行结果： True   In[133]: \u0026nbsp;  x    执行结果： {1, 2, 3}   In[134]: \u0026nbsp;  x.add([3,4,5]) # 只能加入不可变对象    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-134-ae00bcadd4dd\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m3\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m5\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# 只能加入不可变对象\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: unhashable type: \u0026#39;list\u0026#39;   In[135]: \u0026nbsp;  x.add({'a':1})    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-135-61439b18554b\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mx\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m{\u001b[0m\u001b[0;34m\u0026#39;a\u0026#39;\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: unhashable type: \u0026#39;dict\u0026#39;   In[136]: \u0026nbsp;  x.add((3,45)) x    执行结果： {(3, 45), 1, 2, 3}   In[137]: \u0026nbsp;  x | {(4,5,6),(10,3)}    执行结果： {(10, 3), (3, 45), (4, 5, 6), 1, 2, 3}   In[138]: \u0026nbsp;  x    执行结果： {(3, 45), 1, 2, 3}   In[139]: \u0026nbsp;  (3, 45) in x    执行结果： True   In[140]: \u0026nbsp;  (4,5,6) in x    执行结果： False   数值工具 python 已经内置了常用的数值工具模块 math，包括 PI 常数、E 常数、正选、小数的四舍五入等工具。 由于篇幅原因这里只举例部分使用方式，并不是说其他不重要，在大家使用到的使用使用 dir() 和 help() 查看帮助文档就行。 In[141]: \u0026nbsp;  # 引入 math 模块 import math # pi 和 e 常数 math.pi, math.e    执行结果： (3.141592653589793, 2.718281828459045)   In[142]: \u0026nbsp;  math.floor(2.5), math.floor(-2.5) # 向下取整    执行结果： (2, -3)   In[143]: \u0026nbsp;  math.ceil(2.567), math.ceil(-2.567) # 向上整数部分    执行结果： (3, -2)   In[144]: \u0026nbsp;  round(2.567), round(2.467), round(2.567, 2) # 四舍五入    执行结果： (3, 2, 2.57)   In[145]: \u0026nbsp;  (1/3.0), round(1/3.0,3), ('%.2f'%(1/3.0))    执行结果： (0.3333333333333333, 0.333, \u0026#39;0.33\u0026#39;)   In[146]: \u0026nbsp;  math.trunc(2.5), math.trunc(-2.5) # 保留整数部分    执行结果： (2, -2)   In[147]: \u0026nbsp;  # sin 函数 math.sin(2*math.pi/180)    执行结果： 0.03489949670250097   In[148]: \u0026nbsp;  # 开平法 math.sqrt(144), 144**0.5, pow(144, 0.5), math.sqrt(2)    执行结果： (12.0, 12.0, 12.0, 1.4142135623730951)   In[149]: \u0026nbsp;  # 幂操作 和 幂函数 pow(2,4), 2**4, 2.0**4.0    执行结果： (16, 16, 16.0)   In[150]: \u0026nbsp;  # 绝对值 和 求和 abs(-42.0), sum((1,2,3,4))    执行结果： (42.0, 10)   In[151]: \u0026nbsp;  # 最小值 和 最大值 min(3,1,2,4), max(3,1,2,4)    执行结果： (1, 4)   In[152]: \u0026nbsp;  dir(math) # 查看更多的 math 方法，使用 help 函数查看使用文档。例如: help(math.acos)    执行结果： [\u0026#39;__doc__\u0026#39;, \u0026#39;__file__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__name__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;copysign\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;degrees\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;erf\u0026#39;, \u0026#39;erfc\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;fabs\u0026#39;, \u0026#39;factorial\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;frexp\u0026#39;, \u0026#39;fsum\u0026#39;, \u0026#39;gamma\u0026#39;, \u0026#39;gcd\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;inf\u0026#39;, \u0026#39;isclose\u0026#39;, \u0026#39;isfinite\u0026#39;, \u0026#39;isinf\u0026#39;, \u0026#39;isnan\u0026#39;, \u0026#39;ldexp\u0026#39;, \u0026#39;lgamma\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log2\u0026#39;, \u0026#39;modf\u0026#39;, \u0026#39;nan\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;radians\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;, \u0026#39;tau\u0026#39;, \u0026#39;trunc\u0026#39;]   In[153]: \u0026nbsp;  help(math.acos)    执行结果： Help on built-in function acos in module math: acos(...) acos(x) Return the arc cosine (measured in radians) of x.    随机数 在写程序中往往会遇到生成随机数，或在一批数据中随机抽取一个数据的需求。这个时候就需要用到 python 内置的随机数模块 random ，这里展示几个常用的方法和方式，需要详细了解模块的使用请使用 dir() 和 help() 查看使用文档。 In[154]: \u0026nbsp;  import random random.random()    执行结果： 0.13103505768991708   In[155]: \u0026nbsp;  random.random()    执行结果： 0.5621144849249962   In[156]: \u0026nbsp;  random.randint(1,10), random.randint(1,10)    执行结果： (3, 8)   In[157]: \u0026nbsp;  random.choice(['a', 1, 'c', 'd'])    执行结果： \u0026#39;c\u0026#39;   In[158]: \u0026nbsp;  random.choice(['a', 1, 'c', 'd'])    执行结果： \u0026#39;c\u0026#39;   In[159]: \u0026nbsp;  l = ['a','b','c','d'] random.shuffle(l) l    执行结果： [\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]   In[160]: \u0026nbsp;  random.shuffle(l) l    执行结果： [\u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;]   如果想要学习更多的数值计算方法和类型，大家可以学习一下 NumPy 库。\n试一试 给出直角三角形的斜边和一个直角边长度，计算另一个直角边长度（比如：给出 5、4 =\u0026gt; 输出另外一个直角边为 3） 给出 4 条线段的长度，判断是否组成矩形  $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/02-basic-grammer/",
	"title": "Python学习 02：python 基础语法初识",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。",
	"content": "由于我们使用的 Jupyter web 交互式环境，所以对于 python 原始的交互式环境和如何在物理机器上运行 python 程序将放到后面介绍。直接进入 python 语法的学习。首先先简单了解 Python 的基础语法。\npython 高层概念  程序由模块组成 模块包含语句 语句包含表达式 表达式创建和操作对象  \nvar defaultColors = [ '#000', '#D00', '#00CF12', '#C2CB00', '#3100CA', '#E100C6', '#00CBCB', '#C7C7C7', '#686868', '#FF5959', '#00FF6B', '#FAFF5C', '#775AFF', '#FF47FE', '#0FF', '#FFF' ]; function term2html(text, options) { options = options || {}; var colors = options.colors || defaultColors; text = text.replace(/^.*\\u001B\\[[12]K/mg, ''); text = text.replace(/^(.*)\\u001B\\[(\\d+)G/mg, function(_, text, n) { return text.slice(0, n); }); var state = { bg: -1, fg: -1, bold: false, underline: false, negative: false }; text = text.replace(/\\u001B\\[([\\d;]+)m([^\\u001B]+)/g, function(_, n, text) { n.split(';').forEach(function(code) { code = code | 0; if (code === 0) { state.bg = -1; state.fg = -1; state.bold = false; state.underline = false; state.negative = false; } else if (code === 1) { state.bold = true; } else if (code === 4) { state.underline = true; } else if (code === 7) { state.negative = true; } else if (code === 21) { state.bold = false; } else if (code === 24) { state.underline = false; } else if (code === 27) { state.negative = false; } else if (code = 30 \u0026\u0026 code = 40 \u0026\u0026 code = 90 \u0026\u0026 code = 100 \u0026\u0026 code /g, '\u0026gt;'); if (style) { return '' + html + ''; } else { return html; } }); return text.replace(/\\u001B\\[.*?[A-Za-z]/g, ''); }  标识符  在 Python 里，标识符由字母、数字、下划线组成。\n 在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。\n Python 中的标识符是区分大小写的。\n 以下划线开头的标识符是有特殊意义的。以单下划线开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入；\n 以双下划线开头的 __foo 代表类的私有成员；以双下划线开头和结尾的 __foo__代表 Python 里特殊方法专用的标识，如 __init__() 代表类的构造函数。\n Python 可以同一行显示多条语句，方法是用分号;分开， 如：\n  In[53]: \u0026nbsp;  a=\u0026quot;a\u0026quot; _b1=\u0026quot;bb\u0026quot; print(\u0026quot;hello, \u0026quot;); print(\u0026quot;world!\u0026quot;) a/b = \u0026quot;ccc\u0026quot; # 这里错误，不能包含 字母、数字、下划线 以外的字符    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-53-7c067522f272\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m5\u001b[0m \u001b[0;31m a/b = \u0026#34;ccc\u0026#34; # 这里错误，不能包含 字母、数字、下划线 以外的字符\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m can\u0026#39;t assign to operator    保留字 下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。\n所有 Python 的关键字只包含小写字母。\n   保留字 保留字 保留字     and exec not   assert finally or   break for pass   class from print   continue global raise   def if return   del import try   elif in while   else is with   except lambda yield    行和缩进 学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。\n缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示：\nIn[4]: \u0026nbsp;  if True: print(\u0026quot;True\u0026quot;) else: print(\u0026quot;False\u0026quot;)    执行结果： True    In[6]: \u0026nbsp;  if True: print( \u0026quot;Answer\u0026quot;) print( \u0026quot;True\u0026quot;) else: print( \u0026quot;Answer\u0026quot;) # 没有严格缩进，在执行时会报错 print( \u0026quot;False\u0026quot;)    执行结果： \u001b[0;36m File \u001b[0;32m\u0026#34;\u0026lt;ipython-input-6-90ba842299af\u0026gt;\u0026#34;\u001b[0;36m, line \u001b[0;32m7\u001b[0m \u001b[0;31m print( \u0026#34;False\u0026#34;)\u001b[0m \u001b[0m ^\u001b[0m \u001b[0;31mIndentationError\u001b[0m\u001b[0;31m:\u001b[0m unindent does not match any outer indentation level    IndentationError: unindent does not match any outer indentation level 错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。\n如果是 IndentationError: unexpected indent 错误, 则 python 编译器是在告诉你\u0026rdquo;Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题\u0026rdquo;，所有 python 对格式要求非常严格。\n因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。\n建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用\n多行语句 Python语句中一般以新行作为语句的结束符。\n但是我们可以使用斜杠（ \\）将一行的语句分为多行显示，如下所示：\nIn[0]: \u0026nbsp;  item_one='1' item_two = '2' item_three = '3' total = item_one + \\ item_two + \\ item_three     语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例： In[0]: \u0026nbsp;  days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']     python 引号 Python 可以使用引号( \u0026lsquo; )、双引号( \u0026ldquo; )、三引号( \u0026ldquo;\u0026rsquo; 或 \u0026ldquo;\u0026rdquo;\u0026rdquo; ) 来表示字符串，引号的开始与结束必须的相同类型的。\n其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。\nIn[0]: \u0026nbsp;  word = 'word' sentence = \u0026quot;这是一个句子。\u0026quot; paragraph = \u0026quot;\u0026quot;\u0026quot;这是一个段落。 包含了多个语句\u0026quot;\u0026quot;\u0026quot;     Python 注释 python中单行注释采用 # 开头。注释可以在语句或表达式行末。\npython 中多行注释使用三个单引号(\u0026ldquo;\u0026lsquo;)或三个双引号(\u0026rdquo;\u0026ldquo;\u0026rdquo;)。\nIn[12]: \u0026nbsp;  # 第一个注释 print(\u0026quot;Hello, Python!\u0026quot;) # 第二个注释 ''' 这是多行注释，使用单引号。 这是多行注释，使用单引号。 这是多行注释，使用单引号。 ''' \u0026quot;\u0026quot;\u0026quot; 这是多行注释，使用双引号。 这是多行注释，使用双引号。 这是多行注释，使用双引号。 \u0026quot;\u0026quot;\u0026quot; print(\u0026quot;没有看到错误就正确了哟！恭喜你\u0026quot;)    执行结果： Hello, Python! 没有看到错误就正确了哟！恭喜你    python 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。\n空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。\n记住：空行也是程序代码的一部分。\n数据类型 对于数据类型这里只做简要介绍，随后会详细介绍每种类型。\n   对象类型 实例     Numbers(数值) 123, 3.4, 3+4j, Ob111, Decimal(), Fraction()   Strings(字符) \u0026lsquo;你好\u0026rsquo;, \u0026ldquo;spam\u0026rdquo;, b\u0026rsquo;\\x01c\u0026rsquo;, u\u0026rsquo;sp\\xc4m\u0026rsquo;   Lists(列表) [1,[2,\u0026lsquo;three\u0026rsquo;], 4.5], list(range(10))   Dictionaries (字典) {\u0026lsquo;food\u0026rsquo;:\u0026lsquo;orange\u0026rsquo;, \u0026lsquo;taste\u0026rsquo;: \u0026lsquo;yum\u0026rsquo;}, dict(hours=10)   Tuples(元组) (1,\u0026lsquo;yellow\u0026rsquo;, 4, \u0026lsquo;U\u0026rsquo;), tuple(\u0026lsquo;spam\u0026rsquo;), namedtuple   Files(文件) open(\u0026lsquo;eggs.text\u0026rsquo;), open(\u0026lsquo;/data/aaa.bin\u0026rsquo;, \u0026lsquo;wb\u0026rsquo;)   Sets(集合) set(\u0026lsquo;abc\u0026rsquo;), {\u0026lsquo;a\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, \u0026lsquo;c\u0026rsquo;}   Other core types(其他核心类型) Booleans, types, None   Program unit types(程序单元类型) Functios, modules, classes   Implementation-related types(实施相关) 编译的代码(.pyc)，stack tracebacks    数值 In[15]: \u0026nbsp;  123    执行结果： 123   In[16]: \u0026nbsp;  123+222    执行结果： 345   In[17]: \u0026nbsp;  1.4*4    执行结果： 5.6   In[18]: \u0026nbsp;  2**200    执行结果： 1606938044258990275541962092341162602522202993782792835301376   In[19]: \u0026nbsp;  # 去数字长度 len(str(2**100000))    执行结果： 30103   In[23]: \u0026nbsp;  3.1415 * 2    执行结果： 6.283   In[22]: \u0026nbsp;  # 使用 print 输出 print(3.1415 * 2)    执行结果： 6.283    In[26]: \u0026nbsp;  # 使用 math 数据模块 import math math.pi    执行结果： 3.141592653589793   In[27]: \u0026nbsp;  math.sqrt(85)    执行结果： 9.219544457292887   In[9]: \u0026nbsp;  # 随机数 import random as rd rd.random()    执行结果： 0.9251197304813635   In[33]: \u0026nbsp;  # 随机选择一个元素 rd.choice([1,2,3,4])    执行结果： 2   数值格式化输出 In[35]: \u0026nbsp;  print('{:,.2f}'.format(29688.2578)) print('%.2f | %+05d' % (3.1415926, -42))    执行结果： 29,688.26 3.14 | -0042    字符串 字符串是要使用引号引起来，可以使以下三种的其中一种：''、\u0026quot;\u0026quot;、\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;。其中 \u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot;\u0026quot; 可以包含多行文本。并且字符串是不可以改变的。 In[12]: \u0026nbsp;  S = \u0026quot;Yellow\u0026quot; len(S) # 获取文本长度    执行结果： 6   In[14]: \u0026nbsp;  # 获取字符串特定位置的字符 print(S[0]) print(S[1]) print(S[-1]) # 可以使用负数，表示从右向左 print(S[-2]) print(S[len(S)-1]) # 这个和 print(S[-1]) 等效    执行结果： Y e w o w    In[17]: \u0026nbsp;  print(S) # 返回字符串子串 print(S[1:3]) print(S[1:]) print(S) # 返回字符串不会更改字符串的值 print(S[0:3]) print(S[:-1]) print(S[:])    执行结果： Yellow el ellow Yellow Yel Yello Yellow    In[18]: \u0026nbsp;  # 拼接两个字符串 print(S + \u0026quot;abc\u0026quot;) # 重复输出 N 遍字符串 print(S*8)    执行结果： Yellowabc YellowYellowYellowYellowYellowYellowYellowYellow    不可更改性 In[20]: \u0026nbsp;  print(S) # 此语句将会报错 S[0] = 'z'    执行结果： Yellow \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mTypeError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-20-798812957f79\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 3\u001b[0m \u001b[0;31m# 此语句将会报错\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 4\u001b[0;31m \u001b[0mS\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m\u0026#39;z\u0026#39;\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mTypeError\u001b[0m: \u0026#39;str\u0026#39; object does not support item assignment   In[21]: \u0026nbsp;  # 但是我们可以使用 子串 和 字符串拼接，形成新的字符串 S = 'z' + S[1:] print(S)    执行结果： zellow    In[24]: \u0026nbsp;  # 或者可以使用 list 进行字符串的修改，但是这个也是形成新的字符串，不会修改原始字符串 a = \u0026quot;abcdefg\u0026quot; L = list(a) L L[1] = 'c' print(''.join(L)) print(a)    执行结果： accdefg abcdefg    更多关于字符串的知识，后面会详细介绍 格式化 In[36]: \u0026nbsp;  print('%s, eggs, and %s' % ('spam', 'SPAM!')) print('{0}, eggs, and {1}'.format('spam', 'SPAM!')) print('{}, eggs, and {}'.format('spam', 'SPAM!'))    执行结果： spam, eggs, and SPAM! spam, eggs, and SPAM! spam, eggs, and SPAM!    列表 In[25]: \u0026nbsp;  L = [123, 'spam', 1.33] print(L) print(len(L)) # 获取列表长度    执行结果： [123, \u0026#39;spam\u0026#39;, 1.33] 3    In[26]: \u0026nbsp;  # 获取列表值 print(L[0]) print(L[:-1]) # 返回一个子列表    执行结果： 123 [123, \u0026#39;spam\u0026#39;]    In[29]: \u0026nbsp;  print(L + [4,5,6]) # 列表拼接 print(L*2)    执行结果： [123, \u0026#39;spam\u0026#39;, 1.33, 4, 5, 6] [123, \u0026#39;spam\u0026#39;, 1.33, 123, \u0026#39;spam\u0026#39;, 1.33]    In[31]: \u0026nbsp;  # 检查边界 print(L) print(L[1]) print(L[99]) # 这里会报错误    执行结果： [123, \u0026#39;spam\u0026#39;, 1.33] spam \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mIndexError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-31-d40083741a4a\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[1;32m 1\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mL\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[1;32m 2\u001b[0m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mL\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0;32m----\u0026gt; 3\u001b[0;31m \u001b[0mprint\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mL\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m99\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;31m# 这里会报错误\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mIndexError\u001b[0m: list index out of range   In[32]: \u0026nbsp;  L[99] = 1 # 赋值也会报错    执行结果： \u001b[0;31m---------------------------------------------------------------------------\u001b[0m\u001b[0;31mIndexError\u001b[0m Traceback (most recent call last)\u001b[0;32m\u0026lt;ipython-input-32-a8d940cf9021\u0026gt;\u001b[0m in \u001b[0;36m\u0026lt;module\u0026gt;\u001b[0;34m()\u001b[0m \u001b[0;32m----\u0026gt; 1\u001b[0;31m \u001b[0mL\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m99\u001b[0m\u001b[0;34m]\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m1\u001b[0m \u001b[0;31m# 赋值也会报错\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m \u001b[0m\u001b[0;31mIndexError\u001b[0m: list assignment index out of range   元组 In[1]: \u0026nbsp;  (1,2,3)    执行结果： (1, 2, 3)   In[44]: \u0026nbsp;  a = (1,2,3) a[2]    执行结果： 3   字典 In[43]: \u0026nbsp;  d = {\u0026quot;a\u0026quot;:1, \u0026quot;b\u0026quot;:2} print(d) print(d[\u0026quot;a\u0026quot;]) d[\u0026quot;a\u0026quot;] = \u0026quot;aaa\u0026quot; print(d)    执行结果： {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} 1 {\u0026#39;a\u0026#39;: \u0026#39;aaa\u0026#39;, \u0026#39;b\u0026#39;: 2}    获取帮助 在 python 中一切都是对象，他们都有自己特定可操作的方法和属性，可以使用 dir 进行查看有哪些可使用的方法或属性。并且可以针对方法或属性使用 help 函数获得对应的 doc 文档。 In[54]: \u0026nbsp;  dir(\u0026quot;a\u0026quot;)    执行结果： [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getnewargs__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mod__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__rmod__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;capitalize\u0026#39;, \u0026#39;casefold\u0026#39;, \u0026#39;center\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;encode\u0026#39;, \u0026#39;endswith\u0026#39;, \u0026#39;expandtabs\u0026#39;, \u0026#39;find\u0026#39;, \u0026#39;format\u0026#39;, \u0026#39;format_map\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;isalnum\u0026#39;, \u0026#39;isalpha\u0026#39;, \u0026#39;isdecimal\u0026#39;, \u0026#39;isdigit\u0026#39;, \u0026#39;isidentifier\u0026#39;, \u0026#39;islower\u0026#39;, \u0026#39;isnumeric\u0026#39;, \u0026#39;isprintable\u0026#39;, \u0026#39;isspace\u0026#39;, \u0026#39;istitle\u0026#39;, \u0026#39;isupper\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;ljust\u0026#39;, \u0026#39;lower\u0026#39;, \u0026#39;lstrip\u0026#39;, \u0026#39;maketrans\u0026#39;, \u0026#39;partition\u0026#39;, \u0026#39;replace\u0026#39;, \u0026#39;rfind\u0026#39;, \u0026#39;rindex\u0026#39;, \u0026#39;rjust\u0026#39;, \u0026#39;rpartition\u0026#39;, \u0026#39;rsplit\u0026#39;, \u0026#39;rstrip\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;splitlines\u0026#39;, \u0026#39;startswith\u0026#39;, \u0026#39;strip\u0026#39;, \u0026#39;swapcase\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;translate\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;zfill\u0026#39;]   __add__ 是内部方法，实现了字符串的拼接操作和使用 + 运算符效果一样 In[55]: \u0026nbsp;  print(\u0026quot;a\u0026quot; + 'NI!') print(\u0026quot;a\u0026quot;.__add__('NI!'))    执行结果： aNI! aNI!    help 获取帮助文档 In[48]: \u0026nbsp;  help(\u0026quot;a\u0026quot;.replace)    执行结果： Help on built-in function replace: replace(...) method of builtins.str instance S.replace(old, new[, count]) -\u0026gt; str Return a copy of S with all occurrences of substring old replaced by new. If the optional argument count is given, only the first count occurrences are replaced.    试一试 将元组 ('a', 'bb') 拼接 a ，并输出结果 为字典 d 新增字段数据：键 'c'，值 'cc'  $(\".outputstextarea\").each(function(){ var el = $(this); console.log(el) el.parent().html(function (text) { return term2html(text .replace(/\\n/g,'br-and-br') .replace(/ /g, 'sp-and-sp')) .replace(/(br-and-br)/g,'') .replace(/(sp-and-sp)/g, '\u0026nbsp;') ; }(el.val())); }) "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-python/01_learn_env_install/",
	"title": "Python学习 01：学习环境搭建",
	"tags": ["python"],
	"description": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 python。",
	"content": "python 是一门使用很广的动态语言，不论是在系统运维、web开发、科学计算、机器学习、图像处理等领域都有 python 的身影。当然这些都不能作为你要学习 python 的理由，学习他的唯一理由就是：你热爱 python。他不是最快的语言，也不是使用最多的语言，但是 python 可以提高你日常处理琐事的效率，并且顺带可以干一些很酷的事情：人生苦短，我用 pytho。\n此系列文章主要聚焦在两方面的内容；\n 第一部分：python 基础支持\n第二部分：python 应用实践\n 由于第一部分我们聚焦在 python 的基础知识的学习上，主要是让大家的属性 python 语法知识上，且能方便记录学习的过程，所以搭建环境我选择最简单的方式。 对于后面在项目实践的时候，会搭建适合项目开发的 python 开发环境。\n这里使用 docker 方式搭建我们的学习环境，我们选择 jupyter/base-notebook 镜像，它同时兼顾了学习练习和笔记记录的功能，并且可以将学习比价导出，对于我们前期学习 python3 基础知识是最合适的方式，这里对于容器的管理我们使用 docker-compose，对于后面有更多需求的时候，也可以很方便的进行扩展或替换成其他版本。当然你也可以选择你喜欢的 docker 镜像版本：jupyter/docker-stack。这系列文章也是使用一个在线的类似 Jupyter 工具 Colaboratory 写的（后面会介绍）。\n\nDocker 安装 已经有 docker 环境的用户跳过\ndocker 安装 docker 安装可以查看docker 安装\ndocker-compose 安装 请参考官方文档：https://docs.docker.com/compose/install/\n本地 Jupyter Dockerfile FROM jupyter/base-notebook MAINTAINER threeq\u0026lt;threeq@foxmail.com\u0026gt;  docker-compose.yml version: '3' services: notebook: build: . ports: - 8888:8888 volumes: - ./work:/home/jovyan  将这两个文件放到同一个目录，使用 docker-compose up -d 启动 jupyter 服务器，然后使用 docker-compose logs 查看启动是否成功和登录使用的 token。看到日日志输入类似\nAttaching to nooblearnpython_notebook_1 notebook_1 | /usr/local/bin/start-notebook.sh: ignoring /usr/local/bin/start-notebook.d/* notebook_1 | notebook_1 | Container must be run with group \u0026quot;root\u0026quot; to update passwd file notebook_1 | Executing the command: jupyter notebook notebook_1 | [W 07:23:14.610 NotebookApp] WARNING: The notebook server is listening on all IP addresses and not using encryption. This is not recommended. notebook_1 | [I 07:23:14.686 NotebookApp] JupyterLab beta preview extension loaded from /opt/conda/lib/python3.6/site-packages/jupyterlab notebook_1 | [I 07:23:14.686 NotebookApp] JupyterLab application directory is /opt/conda/share/jupyter/lab notebook_1 | [I 07:23:14.693 NotebookApp] Serving notebooks from local directory: /home/jovyan notebook_1 | [I 07:23:14.694 NotebookApp] 0 active kernels notebook_1 | [I 07:23:14.694 NotebookApp] The Jupyter Notebook is running at: notebook_1 | [I 07:23:14.694 NotebookApp] http://f5a65ccd5cb8:8888/?token=ed3a63c025a0f44ba00a8cb4e39f28cadebc4d8f6679c603 notebook_1 | [I 07:23:14.695 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). notebook_1 | [C 07:23:14.703 NotebookApp] notebook_1 | notebook_1 | Copy/paste this URL into your browser when you connect for the first time, notebook_1 | to login with a token: notebook_1 | http://f5a65ccd5cb8:8888/?token=ed3a63c025a0f44ba00a8cb4e39f28cadebc4d8f6679c603\u0026amp;token=ed3a63c025a0f44ba00a8cb4e39f28cadebc4d8f6679c603  最后一行就是就是访问的地址和 token，打开本地浏览器输入地址：http://localhost:8888，会看到登录界面输入最后一行的 token，就能进入 jupyter 列表界面\n测试环境正确性 开始我们第一个 python 代码，也是经典的学习入门程序：Hello，World！\n 新建一个学习笔记（点击右上角的 New 按钮），在新打开的笔记本页面输入以下代码，按 Shift+Enter 执行  print(\u0026quot;Hello, World!\u0026quot;)  输出结果如下\nHello, World!  在线 Jupyter 对于可以访问 Google 服务的小伙伴，还可以使用 Google 的一个在线服务：Colaboratory，Colaboratory 本身是一个数据分析工具，但是这个完全满足我们对于 Python3 学习使用。访问地址：https://colab.research.google.com\n这个可以使我们更快速的学习实践，同时将我们的学习笔记存储 google 网盘，只是国内用户访问 google 服务需要使用科学方法。\n熟悉 Jupyter Jupyter 主界面  : 菜单栏，Files: 查看笔记列表；Running: 正在打开的笔记；Clusters: jupyter 集群信息 : 笔记列表，所有创建的笔记都在这里 : Upload 上传已有的笔记文件 : New 新建一个笔记，点开下列表可以建立不同类型的笔记本  Jupyter 笔记界面  : 笔记名称和保存状态，点击 笔记名称 可以对笔记名称进行修改 : 菜单栏和工具栏，可以做笔记导出、运行等操作 : 笔记内容区域 : 笔记块，我们的写的具体内容就在笔记块里面，笔记块有多种类型，我们常用的就是：Code 块和 Markdown 块 "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/12-procedure-function/",
	"title": "小白学 SQL 第十二天：存储过程和函数",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "之前我们已经学习了 SQL 的很多基础知识，最后一起看一下 存储过程和函数 ，这也是此系列的最后一篇。数据库系统有了存储过程和函数，才真正具备了编程的能力。\n知识要点\n 存储过程 存储过程和函数的区别  \n存储过程和函数定义 存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合。调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。MySQL的存储过程（stored procedure）和函数（stored function）统称为stored routines。\n虽然存储过程和函数可以简化应用开发难度和提升数据处理效率，但是存储过程本身比较复杂，对于应用后期维护和数据库迁移升级并不友好。对于是否应该采用存储过程，可以看文章Business Logic: To Store or not to Store that is the Question?中进行了详细分析和讨论。就我个人来说：在应用业务开发的时候，是很少使用存储过程和函数的，有时是甚至是禁止使用；往往是在在编写数据库升级脚本时使用存储过程和函数。\n存储过程和函数 创建语法：\nCREATE [DEFINER = { user | CURRENT_USER }] PROCEDURE sp_name ([proc_parameter[,...]]) [characteristic ...] routine_body CREATE [DEFINER = { user | CURRENT_USER }] FUNCTION func_name ([func_parameter[,...]]) RETURNS type [characteristic ...] routine_body proc_parameter: [ IN | OUT | INOUT ] param_name type func_parameter: param_name type type: Any valid MySQL data type characteristic: COMMENT 'string' | LANGUAGE SQL | [NOT] DETERMINISTIC | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } | SQL SECURITY { DEFINER | INVOKER } routine_body: Valid SQL routine statement  characteristic 特征值的部分进行简单的说明：\n LANGUAGE SQL 说明下面过程的 BODY 是使用 SQL 语言编写，这条是系统默认的，为今后 MySQL 会支持除 SQL 外的其他语言的存储过程而准备\nDETERMINISTIC 确定的，即每次输入一样输出也一样的程序\nNOT DETERMINISTIC 非确定的，默认是非确定的。当前，这个特征值还没有被优化程序使用。\n{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } 这些特征值提供子程序使用数据的内在信息，这些特征值目前只是提供给服务器，并没有根据这些特征值来约束过程实际使用数据的情况\n CONTAINS SQL 表示子程序不包含读或写数据的语句，没有明确指定时的默认值\nNO SQL 表示子程序不包含 SQL 语句\nREADS SQL DATA 表示子程序包含读数据的语句，但不包含写数据的语句\nMODIFIES SQL DATA 表示子程序包含写数据的语句。\n SQL SECURITY { DEFINER | INVOKER } 可以用来指定子程序该用创建子程序者的许可来执行，还是使用调用者的许可来执行。默认值是 DEFINER\nCOMMENT 'string' 存储过程或者函数的注释信息\n 详细的 SQL 语法说明，请参考 《MySQL 官方文档》 。\nMySQL 的存储过程和函数中允许包含 DDL 语句，也允许在存储过程中执行提交（Commit，即确认之前的修改）或者回滚（Rollback，即放弃之前的修改），但是存储过程和函数中不允许执行 LOAD DATA INFILE 语句。此外，存储过程和函数中可以调用其他的过程或者函数\n通常我们在执行创建过程和函数之前，都会通过 DELIMITER $$ 命令将语句的结束符从 ; 修改成其他符号，这里使用的是 $$，这样在过程和函数中的 ; 就不会被 MySQL 解释成语句的结束而提示错误。在存储过程或者函数创建完毕，通过 DELIMITER ; 命令再将结束符改回成 ;\n调用存储过程\nCALL sp_name([parameter[,...]]); -- 或 CALL sp_name[()]  调用函数\nselect func_name();  查看存储过程或者函数的状态\nSHOW {PROCEDURE | FUNCTION} STATUS [LIKE 'pattern']  查看存储过程或者函数的定义\nSHOW CREATE {PROCEDURE | FUNCTION} sp_name  通过查看 information_schema.Routines 了解存储过程和函数的信息\n删除存储过程或函数\nDROP {PROCEDURE | FUNCTION} [IF EXISTS] sp_name  变量的使用  存储过程和函数中可以使用变量，变量是不区分大小写的\n 通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中，可以用在嵌套的块中。变量的定义必须写在复合语句的开头，并且在任何其他语句的前面。可以一次声明多个相同类型的变量。如果需要，可以使用 DEFAULT 赋默认值\n定义一个变量的语法如下：\nDECLARE var_name[,...] type [DEFAULT value]  直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：\nSET var_name = expr [, var_name = expr] ...  也可以通过查询将结果赋给变量，这要求查询返回的结果必须只有一行，具体语法如下：\nSELECT col_name[,...] INTO var_name[,...] table_expr  定义条件和处理  条件的定义和处理可以用来定义在处理过程中遇到问题时相应的处理步骤\n 条件的定义\nDECLARE condition_name CONDITION FOR condition_value condition_value:SQLSTATE [VALUE] sqlstate_value | mysql_error_code  条件的处理\nDECLARE handler_type HANDLER FOR condition_value[,...] sp_statement handler_type:CONTINUE | EXIT | UNDO condition_value:SQLSTATE [VALUE] sqlstate_value | condition_name | SQLWARNING | NOT FOUND | SQLEXCEPTION | mysql_error_code   handler_type：CONTINUE 表示继续执行下面的语句，EXIT 则表示执行终止\ncondition_value 的值可以是通过 DECLARE 定义的 condition_name，可以是 SQLSTATE 的值或者 mysql-error-code 的值或者 SQLWARNING、NOT FOUND、SQLEXCEPTION，这 3 个值是 3 种定义好的错误类别，分别代表不同的含义：\n SQLWARNING 是对所有以 01 开头的 SQLSTATE 代码的速记 NOT FOUND 是对所有以 02 开头的 SQLSTATE 代码的速记 SQLEXCEPTION 是对所有没有被 SQLWARNING 或 NOT FOUND 捕获的 SQLSTATE 代码的速记   光标的使用 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明，OPEN， FETCH 和 CLOSE，其语法分别如下：\n 声明光标：   DECLARE cursor_name CURSOR FOR select_statement   OPEN 光标：   OPEN cursor_name   FETCH 光标：   FETCH cursor_name INTO var_name [, var_name] ...   CLOSE 光标：   CLOSE cursor_name   注意：变量、条件、处理程序、光标都是通过 DECLARE 定义的，它们之间是有先后顺序的要求的。变量和条件必须在最前面声明，然后才能是光标的声明，最后才可以是处理程序的声明\n 流程控制 if 语句\n if 实现条件判断，满足不同的条件执行不同的语句列表，具体语法如下：\nIF search_condition THEN statement_list [ELSEIF search_condition THEN statement_list] ... [ELSE statement_list] END IF   CASE 语句\n case 实现比 if 更复杂一些的条件构造，具体语法如下：\nCASE case_value WHEN when_value THEN statement_list [WHEN when_value THEN statement_list] ... [ELSE statement_list] END CASE  or\nCASE WHEN search_condition THEN statement_list [WHEN search_condition THEN statement_list] ... [ELSE statement_list] END CASE   loop 语句\n LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：\n[begin_label:] LOOP statement_list END LOOP [end_label]  如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环\n leave 语句\n 用来从标注的流程构造中退出，通常和 BEGIN \u0026hellip; END 或者循环一起使用\n iterate 语句\n iterate 语句必须用在循环中，作用是跳过当前循环的剩下的语句，直接进入下一轮循环\n repeat 语句\n 有条件的循环控制语句，当满足条件的时候退出循环，具体语法如下：\n[begin_label:] REPEAT statement_list UNTIL search_condition END REPEAT [end_label]   while 语句\n WHILE 语句实现的也是有条件的循环控制语句，即当满足条件时执行循环的内容，具体语法如下：\n[begin_label:] WHILE search_condition DO statement_listEND WHILE [end_label]  WHILE 循环和 REPEAT 循环的区别在于：WHILE 是满足条件才执行循环，REPEAT 是满足条件退出循环；WHILE 在首次循环执行之前就判断条件，所以循环最少执行 0 次，而 REPEAT 是在首次执行循环之后才判断条件，所以循环最少执行 1 次\n 事件调度器  事件调度器可以将数据库按自定义的时间周期触发某种操作，可以理解为时间触发器\n 下面是一个最简单的事件调度器，每 5 秒向表中插入数据\ncreate event myevent on schedule every 5 second do insert into tablename values(value1);   事件名称在 create event 关键字后指定 通过 on schedule 子句指定事件在何时执行及执行频次 通过 do 子句指定要执行的具体操作或事件  查看事件：show events;\n查看调度器：show variables like '%scheduler' 默认是关闭的\n打开调度器：set global event_scheduler=1;，事件才能启动\n查看后台进程：show processlist;\n禁用事件：alter event eventname disable;\n删掉事件：drop event eventname;\n存储过程和函数的比较 大家可以看到存储过程和函数，不论是从功能还是语法上都非常相识，那他们有什么区别呢？存储过程和函数的比较的简要说明参见Stored procedure vs. function。归纳如下：\n 函数只能通过return语句返回单个值或者表对象。而存储过程不允许执行return，但是可以通过out参数返回多个值。 函数是可以嵌入在sql中使用的,可以在select中调用，而存储过程不行。 函数限制比较多，比如不能用临时表，只能用表变量等等．而存储过程的限制相对就比较少 当存储过程和函数被执行的时候，SQL Manager会到procedure cache中去取相应的查询语句，如果在procedure cache里没有相应的查询语句，SQL Manager就会对存储过程和函数进行编译。 Procedure cache中保存的是执行计划 (execution plan) ，当编译好之后就执行procedure cache中的execution plan，之后SQL SERVER会根据每个execution plan的实际情况来考虑是否要在cache中保存这个plan，评判的标准一个是这个execution plan可能被使用的频率；其次是生成这个plan的代价，也就是编译的耗时。保存在cache中的plan在下次执行时就不用再编译了。  总结  存储过程：创建、调用、删除 函数：创建、调用、删除 存储过程和函数的比较  这篇是《小白学 SQL》第一阶段的最后一篇，自此大家应该对 SQL 的基础知识的整体结构的有所认知，同时应该能对问题分析和分解，且能写出对于的 SQL 语句。虽然此系列的 SQL 介绍结束了，但是对于 SQL 的学习和实践才正式开始。由于本人能力有限，不论是在分析、组织和书写方面都有错误，还希望你能指出。希望能得到你的反馈，你的反馈对我很重要，也是我不断前进的动力，望能和你共同进步。\n 目前正在规划 SQL 介绍的第二阶段，重点聚焦在三方面： 一 应用开发中数据库设计优化\n 二 如何写出高效的 SQL\n 三 如何建立有效的索引\n "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/11-view-index/",
	"title": "小白学 SQL 第十一天：索引和视图",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "已经介绍了 SQL 的查询、定义、插入、修改、删除等操作，接下来将介绍数据库另一个重要的知识点：索引，特别是在查询优化的时候，索引 将是优化的最重要手段之一。查询本身会随着我们的应用功能的增强，不断的增加复杂度，这时就需要管理复杂查询的手段：视图 。\n知识要点\n 索引 MySQL 索引操作语句 BTREE 和 HASH 视图  这里的内容可能有点难，有一定使用经验可能会更容易理解。不过没有关系只要知道索引的基本概念和操作语句就行，大家真的在使用到时再来看或查询相关资料就可以了。\n\n现代数据库无一不包含 索引。首先我们需要理解为什么？就像之前说的，数据库是用来做大量数据管理和查询的系统。在现在这个以数据为中心的时代，任意一个业务系统数据量也是动辄百万了，大部分业务系统都在千万到亿这个级别，现在大家平时接触到的系统在亿这个级别的很多。这么大的数据量存储在磁盘中，怎么能快速的获取我们所需要的数据？总不能每次都取出全部数据吧！（当然这里数据的高效存储也非常重要，不过这个已经超出了这里范围了不做介绍）\n索引 数据库中的所有数据都会持久化的磁盘中，磁盘读取速度是很慢的，并且数据库里的数据都会比较大，如果我们每次查询都从磁盘里面读入所有数据进行比较过滤，那将会是非常慢的。所以数据库为了更快的检索需要的数据，就需要使用一种高效的数据结构来组织编目原始数据，这就是这里介绍的： 索引。\n大家不要以为索引数据会很小，其实索引也是很大的。如果索引长度是 16字节，表数据量是 1亿，那表的这个索引存储需要的空间至少是15G（因为在存储的时候还需要存储索引结构的其他信息）。计算机的内存资源是很昂贵的，且索引数据也需要永久存储，所以索引结构数据也是存储在磁盘里面。数据库在读取数据时是按照每页读取的，数据库会以页为单位缓存已经读取的索引数据。关于如何估算页数量不在本文内容中，但是这个对于理解如何优化 SQL 会很重要，感兴趣的可以查询相关资料。\nMySQL 索引语法 MySQL 里面索引管理使用 alter 语句，对于创建索引还可以使用 create index 语句。\nCreate Index create index 语句只是 alter table 语句的另一种语法， 可以完全映射到 alter table 创建索引语句中。并且 create index 不能用于 主键 的创建，主键 的创建需要使用 alter 语句或在 create table 表结构创建语句中。\nCREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [index_type] ON tbl_name (index_col_name,...) [index_option] [algorithm_option | lock_option] ... index_col_name: col_name [(length)] [ASC | DESC] index_option: KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string' index_type: USING {BTREE | HASH} algorithm_option: ALGORITHM [=] {DEFAULT|INPLACE|COPY} lock_option: LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}  Alter 语句 使用ALTER 语句添加索引\nAlter TABLE tbl_name ADD [INDEX|UNIQUE|FULLTEXT|SPATIAL] index_name(index_col_name,...);  使用 ALTER 语句添加主键\nALTER TABLE tbl_name ADD PRIMARY KEY (index_col_name,...);  删除索引\nALTER TABLE tbl_name DROP INDEX index_name;  删除主键\nALTER TABLE tbl_name DROP PRIMARY KEY;  你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \\G 来格式化输出信息。\nSHOW INDEX FROM tbl_name; \\G  这里这里我把主键和外键也看做是索引，他们只是索引的 2 中特殊类型\n  索引分类：普通索引（默认）、唯一索引（unique）、全文索引（fulltext）、空间索引（spatial）、主键、外键 普通索引和唯一索引的数据结构类型可以有：BTree 和 Hash 空间索引使用 R-Tree，也叫 R-Tree 索引 主键一个表只能有一个，可以包含多个列，且列的数据(如果是多列，就是组合数据)必须唯一，且列值不能为 NULL 当遇到比较大的字符串字段，可以仅仅使用字段前面部分数据创建索引   索引类型 这里面 主键、外键、普通索引、唯一索引 比较常见，全文索引 和 空间索引 在一些特定的业务场景里面会使用到。\n针对 普通索引 和 唯一索引 ，底层的存储的数据类型可以有2个选择：一个是 B Tree，一个是 Hash。由于底层的数据结构不同，所以两种类型支持的操作也有所区别。并且不同的存储引擎对索引类型的支持也是不同的。全文索引的数据结构类型的实现依赖于存储引擎，空间索引使用 R-Tree 实现。\n   存储引擎类型 索引类型     InnoDB BTREE   MyISAM BTREE   MEMORY/HEAP HASH, BTREE   NDB HASH, BTREE    不同存储引擎对于索引类型支持的特性也是不同的。\nInnoDB 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No N/A N/A   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   FULLTEXT N/A Yes Yes Table Table   SPATIAL N/A No No N/A N/A    MyISAM 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No N/A N/A   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   FULLTEXT N/A Yes Yes Table Table   SPATIAL N/A No No N/A N/A    MEMORY 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No N/A N/A   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   Primary key HASH No No N/A N/A   Unique HASH Yes Yes Index Index   Key HASH Yes Yes Index Index    NDB 存储引擎支持特性\n   索引分类 索引类型 Null 值 多个 NULL值 IS NULL 扫描方式 IS NOT NULL 扫描方式     Primary key BTREE No No Index Index   Unique BTREE Yes Yes Index Index   Key BTREE Yes Yes Index Index   Primary key HASH No No Table (see note 1) Table (see note 1)   Unique HASH Yes Yes Table (see note 1) Table (see note 1)   Key HASH Yes Yes Table (see note 1) Table (see note 1)     注意\n  如果使用 HASH ，则可以防止创建隐式有序索引。   说了这么多 BTREE 和 Hash 对于我们平时使用有什么差异。\n  B-Tree 支持的操作有等于、不等于、小于、小于、Between、前缀 like，in Hash 支持支 等于和不等于 2 种操作。特别注意它是不支持 大于、小于之类的区间型条件的，因为 Hash 类型是无序的，并且对于 order by 排序操作不能使用 Hash 索引加快速度 like 操作如果不是前缀匹配是不能使用使用索引的。如 col_name like 'aa%' 是可以使用索引的，但是 col_name like '%aa' 和 col_name like '%aa%' 都不能使用索引。   索引使用分析 正所谓 过早优化是万恶之源 。我们 不应该在一创建表时就创建索引，应该是在查询真的慢的时候才创建索引 ，因为索引在提高查询速度的时候，也会使 insert、update、delete 语句的操作变慢，并且随着业务功能的迭代，索引也需要跟着优化和修改。这就需要有一定的索引分析手段。\n1、索引分析手段\n ① 针对单个 SQL 可以使用 执行计划 查看索引使用情况\n② 可以使用 show status like 'Handler_read%'; 查看 MySQL 索引使用率\n③ 针对数据库中未使用索引分析，可以收集一段时间内数据库执行的所有 SQL 语句，然后使用三方工具分析数据库中哪些索引已经 失效 。比如 pt-index-usage 等。\n 2、创建索引时需要注意\n ①主键自动建立唯一索引\n②频繁作为查询条件的字段应该创建索引\n③查询中与其他表关联的字段，外键关系建立索引\n④频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引\n⑤WHERE条件里用不到的字段不创建索引\n⑥单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)\n⑦查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度\n⑧查询中统计或者分组字段\n 3、哪些情况不要创建索引\n ①表记录太少\n②经常增删改的表\n　提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。\n　因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。\n　数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。\n③注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。\n 视图 什么是视图？ 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。可以简单的理解成：视图就是存储在数据库中并具有名字的 SQL 语句 ，它是管理复杂 SQL 查询的一种方式。\n视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。\n视图，一种虚拟的表，允许用户执行以下操作：\n 以用户或者某些类型的用户感觉自然或者直观的方式来组织数据； 限制对数据的访问，从而使得用户仅能够看到或者修改（某些情况下）他们需要的数据； 从多个表中汇总数据，以产生报表。  注释：数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。\nSQL 创建视图 CREATE VIEW view_name AS SELECT column_name(s)[,...] FROM table_name WHERE condition  注释：视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。\n可以从某个查询内部、某个存储过程内部，或者从另一个视图内部来使用视图。通过向视图添加函数、join 等等，我们可以向用户精确地提交我们希望提交的数据。\n以之前的学生表为例子，创建一个包含学生名字、学生参与班级名称、根据学生生日计算的年龄视图\nCREATE VIEW student_view AS SELECT s.s_name, year(now())-year(s.s_birthday), c.c_name FROM student s,class c, student_join_class sc where s.s_id=sc.s_id and c.c_id=sc.c_id  我们可以查询上面这个视图：\nSELECT * FROM student_view   试试\n [ ] 创建一个包含班级 id、班级名称、班主任、参与人员的视图，视图名称 class_view。（*注意统计函数所使用的字段*）\n  SQL 更新视图 视图可以在特定的情况下更新：\n SELECT 子句不能包含任何汇总函数（summary functions） SELECT 子句不能包含任何集合函数（set functions） SELECT 子句不能包含任何集合运算符（set operators） 查询语句中不能有 GROUP BY 或者 HAVING  如果视图满足以上所有的条件，该视图就可以被更新。当然如果需要通过视图使用 insert 语句，那还需要满足其他条件，不过个人不建议这样使用。\n您可以使用下面的语法来更新视图：\nCREATE OR REPLACE VIEW view_name AS SELECT column_name(s)[,...] FROM table_name WHERE condition  现在，向 student_view 中加入性别、地址信息：\nCREATE OR REPLACE VIEW student_view AS SELECT s.s_name, year(now())-year(s.s_birthday), c.c_name, s.s_sex, s.s_addr FROM student s,class c, student_join_class sc where s.s_id=sc.s_id and c.c_id=sc.c_id;  查询上面这个视图，看修改结果：\nSELECT * FROM student_view  SQL 删除视图 您可以通过 DROP VIEW 命令来删除视图。\nDROP VIEW view_name  :试试\n向 class_view 中加入参与学生的平均年龄。（需要先删除再创建）  总结  索引：索引创建、作用、分析索引使用情况 视图：视图创建、修改、删除、使用 "
},
{
	"uri": "https://blog.threeq.me/post/web/web-frontend-arch-practice/",
	"title": "前端分层架构实战（一）",
	"tags": ["架构", "前端"],
	"description": "随着微服务兴起前后端分离架构的越来越流行，前端的负责的开发任务越来越重，功能复杂度和代码量也越来越高，在同一个项目投入的前端人力也是越来越多，这个时候需要我们使用更加高效的方式来组织我们的代码结构。目前前端有很多框架帮我们做了很多这方面的工作，比如目前比较流行的的三大框架：angular、vue、react。但是我们在实际使用的时候往往发现，使用他们的命令行工具生成了一个工程，可以进行开发了，但是真正应用到真实项目中的时候，往往有力不从心的感觉，特别是企业及的项目中，这是由于它们做的只是从技术层面上解决了代码组织方式，并没有给出结合业务时项目里的组织结构和组织方法。本文介绍分层架构在前端开发中的实践。",
	"content": "整个《前端分层架构实战》分成两部分：\n 前端分层架构实战（一）：分层架构问题分析和结构设计 前端分层架构实战（二）：分层架构项目规划和工程实施  本文是其中的第一篇。\n随着微服务兴起前后端分离架构的越来越流行，前端的负责的开发任务越来越重，功能复杂度和代码量也越来越高，在同一个项目投入的前端人力也是越来越多，这个时候需要我们使用更加高效的方式来组织我们的代码结构。目前前端有很多框架帮我们做了很多这方面的工作，比如目前比较流行的的三大框架：angular、vue、react。但是我们在实际使用的时候往往发现，使用他们的命令行工具生成了一个工程，可以进行开发了，但是真正应用到真实项目中的时候，往往有力不从心的感觉，特别是企业及的项目中，这是由于它们做的只是从技术层面上解决了代码组织方式，并没有给出结合业务时项目里的组织结构和组织方法。而这些正是软件架构所解决的问题，软件架构正在后端开发中大放异彩，那我们能不能也在前端开发中引入软件架构方法，来解决前端日益复杂的开发需求呢？答案是肯定的，下面简单说一下我自己在这里面的实践总结，由于个人能力有限，有不正确的地方欢迎大家指正。\n\n先从我们实际看到的页面效果出发，对我们页面的内容进行分析、设计。以下 2 中页面是我们最常见页面结构，一个是 PC 端常见的页面版式，一个是移动端常见的页面版式，列举这 2 个的目的就是说明在分析层模式的时候，对于 PC 端和移动端都是适用的，也说明我们移动端的页面也在往不断复杂的方向上发展。\n  pc 端    移动端    这个是页面展示是呈现的具体效果，那我们如何对其进行分层设计呢？试想如果我们看到的浏览器页面是有厚度的，上面的图是我们正对浏览器看到的页面效果，如果我们从斜上方去看我们的这个页面会是什么样子？。以下是一种简单的划分设计方式，这个层的划分是按照 HTML 的逻辑功能划分的，属于 HTML 逻辑层结构。\n以上层的拆分是我们在浏览器里面看到内容分层。其实大家所熟悉的 CSS 逻辑层结构划分也是这样的，也即是说 HTML 和 CSS 共享逻辑层结构。这是是正确的，因为界面的呈现使用 HTML 和 CSS 共同完成的，所以它们应该共享相同的逻辑层划分。其实这个层逻辑结构就是通过 CSS 的 z-index 来实现的。其实在我们实际规划 CSS 和 HTML 逻辑层的时候，往往比上面会多一些，一般是4~5层，比如下面是项目中可能存在的一种划分方式\n在开发的项目工程中物理文件组织是没有按照这个逻辑层去组织的，如果按照逻辑层去组织的代码，当项目代码逐渐增多时代码管理起来将会非常麻烦，并且这个逻辑层结构并不适合 JS 代码结构划分，也并没有包含底层框架、项目管理和代码重用等方面的相关内容。这就要需要我们在项目文件物理存储这个层面上需要有新的层划分方式，这个时候我们将以 JS 角度出发，重点关心项目结构和文件组织方式，方面团队协作和长期维护等需求。以下层架构框图展示了项目中的一种可能划分，也是我们目前的项目结构\n整个代码功能上划分成 5 层，6个不同的功能块。当然这几个功能块并不是完全相互独立的，会由于基础框架的选型影响所有其他功能块的实现方式。\n 框架层：这个是最底层，包含最基础的依赖组件。我们常说的 angular、vue、react 包含在这个层级里，这里面基础框架的选择会对其他每个层造成重大影响，并且上面所有层的实现都会基于此做设计。 工具层：是基于框架层选型开发的一些通用公共组件（比如：对话框、警告提示、加载、上传等）。这里的组件可以是自己开发，也可以是使用三方封装，可能还会包含一些和具体业务相关的公共组件。 容器层：负责处理一些公共逻辑和存放公共数据（比如：页面启动流程、用户数据、页面状态数据等），一个系统往往只有一个容器，当然也可以有多个。现在大多数页面启动流程都会比较负责，如登录流程、权限处理等都会和页面启动流程相关，且用户的登录数据、页面的状态信息都需要全局、多模块共享。 视图层：是在容器层上将页面上的可视区域划分成不同的作用的显示区域。在每个显示区域都可以放入不同的内容，并且可以根据用户操作进行切换。针对不同终端的响应式规范，也是在这层进行定义。一个系统或网站往往会有多个不同的视图 内容层：是实现具体业务的层面，我们实现的每个模块都属于内容层的一个内容块。每个内容块都可以放入任意一个视图中，当然在实现内容布局显示的时候，要符合相应视图定义的规范。具体某个内容放入哪个视图中，可以做成动态配置（比如：使用 angular 时，可以选择通过路由配置），这样做到模块级重用。 管理工具：是对工程进行管理的工具，包括打包、依赖管理、单元测试、CI/CD等。这里的选择也会很多，且和我们具体的业务结构相对独立，流行的有 gulp、webpack、grunt 等。  这里除了框架层和容器层需要同步加载，其他所有层的内容都可以做成按需延迟加载。每个层和层里面内容所涉及到的所有资源（JS、CSS、HTML、Image） 都放在相同的目录中，减少开发过程中开发人员的心智负担。\n"
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/10-db-transaction-lock/",
	"title": "小白学 SQL 第十天：事务和锁",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "事务 是 DBMS 中一个非常重要的基本概念，主要用于处理操作量大，复杂度高的数据，比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！当我们在启动一个事务时，这里就引出了锁概念，并且这 2 个者对于初学者容易搞混淆。虽然事务和锁的基本原理是一样的，但是不同 RDBMS 的实现是有差别的，这里还是以 MySQL 中的事务和锁来讲解和说明基本操作。\n知识要点\n 事务基本概念 MySQL 事务操作 MySQL 锁  \n事物 像上面说的一样，在使用 MySQL 处理大量数据操作或负载数据操作时，就会启用事务！一般来说，事务是必须满足4个条件（ACID）： Atomicity（原子性）、Consistency（一致性）、Isolation（隔离性）、Durability（持久性）\n 原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 一致性 ： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。 隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。  在 MySQL 中要使用事务时，需要注意以下内容：\n 在MySQL中只有使用了 Innodb 数据库引擎的数据库或表才支持事务 事务处理可以用来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行 事务主要用来管理insert,update,delete语句   在我们使用 insert,update,delete 语句时，会自动启用事务。事务其实也会影响到 select 语句的查询结果，这个主要是受 MySQL 事务隔离级别决定的。对于表结构更改语句，不受事务控制，只要执行会立即提交当前更改。\n在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。\n 事务隔离级别 SQL 标准中定义了 4 个隔离级别：未提交读（Read uncommitted）、已提交读（Read committed）、可重复读（Repeatable read）、可序列化（Serializable）\n 未提交读（Read uncommitted）：一个事务修改了一行，另一个事务也可以读到该行。 已提交读（Read committed（RC））：试图通过只读取提交的值的方式来解决脏读的问题，但是这又引起了不可重复读取的问题。 可重复读（Repeatable read（RR））：在一个事务对数据行执行读取或写入操作时锁定了这些数据行，但是这种方式又引发了幻想读的问题。 因为只能锁定读取或写入的行，不能阻止另一个事务插入数据，后期执行同样的查询会产生更多的结果。InnoDB通过多版本并发控制机制（MVCC）解决的幻读的问题。 可序列化（Serializable）：事务被强制为依次执行。这是 SQL 标准建议的默认行为。  上面可以看到不同的隔离级别会导致数据的脏读、不可重复读或幻读，这个也是通常说的事务的级别，它们关系如下：\n   隔离级别/读数据一致性及允许的并发副作用 读数据一致性 脏读 不可重复读 幻读     未提交读（Read uncommitted） 最低级别，只能保证不读取物理上损坏的数据 是 是 是   已提交读（Read committed） 语句级 否 是 是   可重复读（Repeatable read） 事务级 否 否 是   可序列化（Serializable） 最高级别，事务级 否 否 否     比较常用的级别是：RC 和 RR。\n在 MySQL 中可以查看 当前会话的事务级别 和 系统当前事务 级别。\n MySQL 事务控制语句  BEGIN或START TRANSACTION；显式地开启一个事务； COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的； ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改； SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT； RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常； ROLLBACK TO identifier；把事务回滚到标记点； SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。  MySQL 事务处理的主要两种方式：\n 用 BEGIN, ROLLBACK, COMMIT来实现  BEGIN 开始一个事务 ROLLBACK 事务回滚 COMMIT 事务确认  直接用 SET 来改变 MySQL 的自动提交模式:  SET AUTOCOMMIT=0 禁止自动提交 SET AUTOCOMMIT=1 开启自动提交   测试  使用 navcat 打开 2 个查询页面，分别制定为 Query1 和 Query2\n 在 Query2 中查询班级所有信息，看现在表表中已有的数据，和后面做对比\nselect * from class;  在 Query1 启动一个事务，且插入一条数据，但是不要提交事务\n# 开启事务 begin; # 插入数据 INSERT INTO `sql-learn`.`class` VALUES (-1, '事务测试 1', '老师1', '2018-04-02', '2018-04-18', 1, '2018-04-18 14:16:22');  再在 Query2 中执行第 2 步中的查询语句，现在看到的数据，应该和第 2 步中的一样\n 现在在 Query1 提交事务\n# 提交事务 commit  最后在 Query2 中执行第 2 步中相同的查询语句，这时会在返回结果的第一行看到我们我们刚插入的测试数据。\n  锁 事务的隔离级别就是由锁实现的，理解清楚它们之间的关系对分析和理解问题会有很大帮助。\n共享锁和排他锁：在一般的应用中，为了应付大量并发，我们一般使用一次封锁法，在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。在这种方法在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）。\n 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。  大多数数据库的MVCC通过对数据版本的乐观锁实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。\n  MySQL 做种类很多，常见的有：表级锁、行级锁和页级索。不多存储引擎支持有所不同。 所有表类型都支持表级锁，但是 MyISAM 只支持表级锁 有两种类型的表级锁：读锁(共享锁)和写锁(排它锁)。  读锁是共享锁，支持并发读，写操作被锁。 写锁是独占锁，上锁期间其他线程不能读表或写表。    不同事务隔离级别，读和写的所操作有所不同，（在分析的时候还需要结合表存储引擎支持的锁种类进行）\n  在 RC 级别下，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。 RR 级别（InnoDB 默认使用此级别）  读：读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时，会看到同样的数据行。 写：针对需要修改的数据加入排它锁    总结  事务：事务基本特性、开始事务、事务提交、事务回滚 事务隔离级别 锁：MySQL锁类型和事务的关系 "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/9-insert-update-delete/",
	"title": "小白学 SQL 第九天：数据插入、修改、删除",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "前面七天主要聚焦在数据查询，就是怎么从表里面取出我们想要的数据。但是这些数据是如何录入到数据库的？如果数据错误了需要修改或删除数据怎么操作？我们如何快速的生产测试数据？这些就是这次我们需要讨论的内容。\n知识要点\n 插入数据 修改数据 删除数据  \n插入数据 插入数据使用 insert into 语句，在前面插入数据的时候我们已经使用。\n语法\ninsert into tbl_name [(field1, field2, ...fieldN)] values (value1, value2,...valueN)[,...];   这里的字段可以省略，如果省略就表示依次插入表中的 所有列 可以依次插入多行值，每个 () 表示一行数据，每行之间用,分隔 插入时对于NOT NULL(不能为空) 的列必须输入 如果数据是字符型或日期，必须使用单引号或者双引号，如：\u0026rdquo;value\u0026rdquo;  看一个我们之前使用过的插入语句：\nINSERT INTO student(s_id, s_name, s_sex, s_age, s_birthday, s_addr, s_created, s_status) VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  这个语句的意图是向学生表里面加入一条数据，这里是插入表的所有字段，所以也可以简化成下面这样:\nINSERT INTO student VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  insert into … select insert into … select 语句是select的查询结果加入到某张表中，这个语法是 MySQL 独有的，其他的 RDBMS 的语法略有不同。这个语句常用于数据汇总、存储过程里面的临时表数据插入等地方。也可以使用这个语句快速产生测试数据，下面我们就看如何快速产生测试数据。\n语法\ninsert into tbl_name[(field1, field2,...fieldN)] \u0026lt;select_clause\u0026gt;   \u0026lt;select_clause 是一个完整的select语句，和前面讲解的 select 语句完全一样 insert 中的列描述必须和 select 中的列描述对应：数量、位置和类型。  列数量必须一致； 列的对应关系是和位置依次对应； 每个对应位置的列数据类型必须一致。   快速生成学生测试数据\ninsert into student(`s_name`, `s_sex`, `s_age`, `s_birthday`, `s_addr`, `s_created`, `s_status`) select `s_name`, `s_sex`, `s_age`, `s_birthday`, `s_addr`, `s_created`, `s_status` from student;  不断执行上面这个语句，你的表中数据将会以指数倍增长。这里的 select 子句中的每个返回列，都可以替换成需要的表达式，以满足不同数据需求。\n修改数据 需改数据使用 update 语句来操作。\n语法\nupdate tbl_name set field1=value1, field2=value2 [where Clause]   可以同时更新一个或多个字段 where 子句中可以指定任何条件 可以在一个单独表中同时跟新多条数据 value 可以是一个表达式  计算学生的真实年龄 我们发现学生表中的生日数据和年龄数据是没有对应的，现在我们需要：根据学生的生日计算出实际年龄更新到年龄字段\n 分析：根据学生的生日计算出实际年龄更新到年龄字段\n 操作类型：update （ 更新） 到哪里更新数据：学生 跟新哪些信息：  学生年龄 = 根据生日计算学生真实年龄  过滤条件：无   update 学生 set\n学生年龄=真实年龄\n 真实年龄 的计算要求根据学生生日计算，只需要使用当前的年份减去生日的年份就可以了：year(now() - year(s_birthday)\n 根据以上分析可以得到 SQL\nupdate student set s_age=year(now())-year(s_birthday);  将年龄小于16岁学生年龄增加 5 岁 根据以上修改的年龄数据，将学生生日年份调整正确  删除数据 当我们数据表中的某些数据不再使用时，可以 delete 语句进行删除。\n语法\ndelete from tbl_name [where clause]   如果没有指定 where 子句，将删除表中所有数据 where 子句可以包含任何条件 可以一次删除多条数据   在没有指定 where 子句时，相当于清空表操作。MySQL 中清楚表操作还可以使用： truncate tbl_name\n 删除已结业的班级  分析：删除已结业的班级\n 操作类型：delete（删除） 删除哪里数据：班级 过滤条件：已结业   delete from 班级\nwhere 班级状态=已结业\n  得到以下 SQL\ndelete from class where c_status=4;   这里的 where 子句和查询中的 where 子句一样，可以使用子查询进行更复杂的删除操作。\n 试试\n删除处于异常状态的班级 删除没有学生参与的班级  总结  插入数据：insert 结构、insert select 结构 修改数据：update 语句 删除数据：delete 语句，清空表操作 "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/8-create-alert-table/",
	"title": "小白学 SQL 第八天：表结构管理",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "前面七天全部聚焦在数据查询，就是怎么从表里面取出我们想要的数据。但是这些表是如何建立？建立的时候需要注意哪些信息？如果修改或删除表结构？。这次就一起来讨论表结构的基本管理操作。\n知识要点\n 创建表 修改表 删除表  \n创建表 创建表所需要基本信息：\n 表名 字段名称 定义每个字段选项 定义表选项  其中 字段选项 和 表选项 每个数据库系统会有所不同。\n基础语法\ncreate [temporary] table table_name ( column_name column_type [column_options] [,...] ) [table_options];   temporary: 表示当前创建的表示临时表。临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。 table_name: 表名称 column_name： 列名称 data_type： 列数据类型。查看数据类型描述 column_options：列定义选项 table_options：表定义选项 [, …]: 表示可以有多个列定义，使用 , 分割  要看 MySQL 详细 create table 语法，请参考 《MySQL 官方手册》。\n首先我们来看一下我们前面用到的班级表的创建语句:\nCREATE TABLE `class` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，主键', `c_name` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班级名称', `c_head_teacher` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班主任名称', `c_start_time` date DEFAULT NULL COMMENT '开班日期', `c_end_time` date DEFAULT NULL COMMENT '结束日期', `c_status` int(11) NOT NULL COMMENT '班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】', `c_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`c_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表';  1 列定义分析: c_id int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，组件'\n c_id 列名 int(11) 列类型为整型。查看其他数据类型描述 not null 定义列不能为空（必须有值） AUTO_INCREMENT 列是否自动增长。一个表只能有一个自动增长列列，并且数据类型必须为数值型 COMMENT '班级 id，主键' 列注释（描述列的作用）  2 主键定义分析： PRIMARY KEY (c_id)\n 定义表的主键，可以同时包含多个列，使用 , 分隔  3 表选项分析：ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表'\n ENGINE=InnoDB 定义表的存储引擎 DEFAULT CHARSET=utf8mb4 表文本采用字符集为 utf8mb4。 COLLATE=utf8mb4_unicode_ci 表校对规则 utf8mb4_unicode_ci COMMENT='班级信息表' 表注释说明   当前数据库支持字符集和校对规则可以使用 SHOW CHARACTER SET; 查看。\n字符集详细信息请查看 MySQL 字符集说明文档\n create table learn_test ( col_1 int not null, col_2 varchar(12) default null, primary key(col_1) ) engine=InnoDB default charset=utf8 comment='学习测试';  使用 desc learn_test 查看表结构：\n修改表 修改表的 alter table 语句作用很多，里面的语法也比较多，这里只列举常见的用法，详细的使用和语法参考 《Mysql 官方文档》。\n增加列 语法\nALTER TABLE tbl_name ADD column_name column_type [column_options];  增加 col_3 列，数据类型为 int，其不能为空 :（执行过后可以使用desc learn_test 查看最新表结构）\nalter table learn_test add col_3 int not null;  删除列 语法\nALTER TABLE tbl_name DROP column_name;  删除 col_1 列\nalter table learn_test drop col_1;  请使用 desc learn_test 查看最新表结构。\n修改列名字和类型 语法\nALTER TABLE tbl_name CHANGE column_name new_column_name new_column_type [new_column_options];  修改 col_2 为 col_0 ，数据类型 bigint ,默认值 0 且不为空\nalter table learn_test change col_2 col_0 bigint not null default 0;  请使用 desc learn_test 查看最新表结构。\n 如果这里不修改列名可以使用 modify 关键字：ALTER TABLE tbl_name MODIFY column_name column_type [column_options];\n 修改表名 语法\nALTER TABLE tbl_name RENAME TO new_tbl_name;  修改 learn_test 为 learn_temp\nalter table learn_test rename to learn_temp;  可以使用 show tables; 查看修改结果。\n修改表存储类型 ALTER TABLE tbl_name TYPE = MYISAM;  其他的表选项语法相似：alter table table_name option_name=option_value\n修改表字符集 ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name;  删除表 DROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name] ... [RESTRICT | CASCADE]   TEMPORARY 表示删除的是临时表 IF EXISTS 如果表存在就删除，不存无操作。语句永远正确 RESTRICT 确保只有不存在相关视图和 完整性约束的表才能删除 CASCADE 任何相关视图和完整性约束一并被删除  drop table if exists learn_test, learn_temp;  可以再次执行上面的 sql 和 drop table learn_test, learn_temp; 看有什么不同返回信息。\n总结  创建表： create 语句语法、表存储引擎、字符集、列 修改表：增加/删除字段、重命名字段、修改字段类型 表删除：drop 语法 "
},
{
	"uri": "https://blog.threeq.me/post/ppt/integrate-impress/",
	"title": "Hugo 集成 impress.js 实现 ppt 播放效果",
	"tags": ["hugo"],
	"description": "impress.js 是一个使用 html 模拟 ppt 播放效果的 js 工具。将 impress.js 集成到 Hugo 主题中，可以在静态博客中快速做出演示效果，并且将精力集中在内容上，展示效果就交给 impress.js 吧。当然需要实现自定义效果也是非常方便的。",
	"content": "这是一个 Hugo Even 主题集成 impress.js 实现幻灯片效果和集成过程的演示。\n支持功能\n 支持 markdown 语法 支持 html 语法 支持 css 动画 支持自定义 js 交互逻辑  实现依赖工具\n impress.js showdown.js mermaid.js  \n开始演示 Your browser doesn't support the features required by impress.js, so you are presented with a simplified version of this presentation.\nFor the best experience please use the latest Chrome, Safari or Firefox browser.\n ----- --- data-x: -1000 data-y: -1500 --- # Hugo 中简单 PPT 效果演示 ## 使用 Impress.js 实现 * markdown 支持 * html 支持 * 依赖库 * [showdown](https://github.com/showdownjs/showdown) * impress.js ----- --- data-rel-x: 1000 data-rel-y: 0 --- # 支持 markdown 样式 * 可以使用常用 markdown 语法 * 例如：*italics* 、 **bold** 、 `code` ----- # 分页和配置语法 * 由于 markdown 本身没有分页支持，所以这里使用 `-----` 作为分页标志 * 每个页面都可以有自己的配置，配置必须放在页面的最前面放在 **两个 `---`** 之间 * 例如 ``` ----- --- data-rel-x: 1000 data-rel-y: 0 --- 你的内容 ``` ----- --- data-rel-x: 300 data-rel-y: 1100 data-rotate: 90 --- # html 和 动画支持 ## 这是一个 html 元素支持的演示。 Fly in\nFade in\nAnd zoom in\n*这个有点像 ppt。需要使用 css3 动画库.* **如果只要 html 解析，请加入配置选项： `html: true`** ----- --- id: acme --- # graph 演示        Q1￥234 Q2￥255 Q3￥(insert here) Q4￥  ----- # 2 ``` data-rel-x: 800 data-rel-y: 800 data-rotate: 60 ``` ----- --- data-x: 6200 data-y: 4300 data-z: -100 data-rotate-x: -40 data-rotate-y: 10 data-scale: 2 class: step slide markdown step-3d --- # This is 3D  have you noticed it’s in 3D*? * beat that, prezi ;) ----- # 子步骤演示 1 ## 多步骤显示  Press 'P' to open a presenter console. When you move the mouse, navigation controls are visible on your bottom left Autoplay makes the slides advance after a timeout Relative positioning plugin is often a more convenient way to position your slides when editing. (See html for this presentation.)  ----- # 子步骤演示 2 ## 单步骤显示 Press 'P' to open a presenter console. When you move the mouse, navigation controls are visible on your bottom left Autoplay makes the slides advance after a timeout Relative positioning plugin is often a more convenient way to position your slides when editing. (See html for this presentation.)              window.pptDefalutAttrs = JSON.parse(\"{\\\"data-rel-x\\\":0,\\\"data-rel-y\\\":900}\"); var api; var impressAttrs = JSON.parse(\"{\\\"data-autoplay\\\":10,\\\"data-transition-duration\\\":1000}\"); if(impressAttrs) { for(var key in impressAttrs) { $('#impress').attr(key, impressAttrs[key]); } } function pptstart() { $('#impress-mark-bg').show(); api = impress(); api.init(); $(\"#impress-toolbar\").append('关闭') setTimeout(function () { $('#impress').focus(); }, 100) } function pptclose(argument) { $('#impress-mark-bg').hide(); api.tear(); } function pptgoto(page){ api.goto(page); }  "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/7-query-multi-table/",
	"title": "小白学 SQL 第七天：多表查询",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "之前学习的查询都只涉及到单表，但在实际应用中还有很大一部分需求，只靠单表查询是实现不了的，比如：查询一个班上的所有人；统计每个班的人数等。那这些需求或问题应该怎么分析和实现，这就是今天要讲解的多表查询。\n知识要点：\n 子查询 表连接  \n 多表查询有两种形式：一种是子查询，一种表连接。那什么时候使用子查询？什么时候使用表连接呢？这里说一下我个人的分析和使用步骤 1. 如果所有需要获得信息列在一张表里可以找到，就用子查询；\n 2. 其他情况肯定需要表连接；\n 3. 如果数据量很大，先子查询再使用表连接\n 4. 使用性能工具分析 SQL 进行优化（执行计划和执行 profile）\n  子查询 子查询可以使用在 select 语句的 2 个地方，一个是在 from 子句中，一个是在 where 子句中，在使用的时候需要放在哪里就看是要从这个子句结果中返回信息，还是这个子句结果只是作为过滤条件。我们通过 2 个 sql 具体分析\n查询参与班级 id 为 1或2 的所有学生信息  分析：查询参与班级 id 为 1和2 的所有学生信息\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：所有学生信息 过滤条件：班级 id 为 1 或 2 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select * from 学生\nwhere 班级 id 为 1 或 2 ;\n 这里学生表里面是没有班级信息的，并且返回的信息只有学生信息，班级 id 只是作为过滤条件，所以这里能确定 where 条件为一个子查询。那这个子查询应该如何分析呢？我们回到最开始的 ER 图\n可以发现和学生信息有直接联系的是 参加 这个关系，同时它还和班级信息 最近 （这里是直接联系），就从 参加 这个关系入手。由于在转换成数据库物理存储的时候，参加 这个关系我们也是在一种独立的数据表中存储的，所以我们首先看这个表的实际物理存储\nCREATE TABLE student_join_class ( c_id int(11) NOT NULL COMMENT '班级 id', s_id int(11) NOT NULL COMMENT '学生 id', cs_created timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', PRIMARY KEY (c_id,s_id) ) COMMENT='学生班级关联表';  发现这个表里面已经了班级 id c_id ，同时还包含学生 id s_id ，这样就可以可以做到从 c_id -\u0026gt; s_id 的转换，在我们知道了 s_id 的情况下，上面分析的 sql 结构可以表示成，这里用 in 是由于通过 student_join_class 得到的 s_id 有可能是多个\n select * from 学生\nwhere s_id in (参加班级 1 或 2 的学生 id);\n 通过上面的分析知道：可以通过 student_join_class 表数据，用已知的班级 id c_id 数据查询出参与班级的学生 id s_id ，这个 sql 通过之前的单表分析方式，不能得到查询语句：\nselect s_id from student_join_class where c_id in (1,2)  将此语句放入分析得到的 sql 语句结构，就得到最终的查询 sql 语句。\n 通过上面的分析，得到如下 sql 语句\nselect * from student where s_id in ( select s_id from student_join_class where c_id in (1,2) );  执行得到如下结果\n查询参与人数大于 3 的班级个数  分析：查询参与人数大于 3 的班级个数\n 操作类型：select （查询） 到哪里取数据：未知 （由于没有任何一张物理表有班级参与人数信息） 得到哪些信息：班级个数 过滤条件：班级参与人数大于 3 排序字段：无 取多少数据：所有数据（无 limit）  通过上面分析得到如下查询结构\n select count(*) from 未知\nwhere 班级参与人数大于 3;\n  这里如果我们将 未知 理解成一张表的话，问题就转换成：分析 未知表 里面应该包含哪些信息？。其实从查询结构不难分析 未知表 只需要包含每个班级的参与人数就够了。因为返回的信息只是统计班级的数量(这里统计之关系有这条数据，不关心数据里的具体内容），但是过滤条件需要使用班级的参与人数进行比较，所以这里 未知表 的 最小信息就是 班级参与人数 。现在问题转变成 查询每个班级的参与人数 (未知表)\n  每个班级有哪些人参与的信息，全部都在关联表 student_join_class 里面，所以通过统计不难得出每个班级的参与人数 sql\nselect c_id, count(*) from student_join_class group by c_id  这里所有我们需要的条件都完成了，组合得到的查询结构和 sql 就行。\n 通过上面的分析得到如下是 SQL。注意：这里在组合的时候对 count(*) 使用了别名 (as 关键字)，这是由于需要在外部查询中使用结果值时，是不能直接用count（*）作为其列名称。其实所有的函数操作都不行。\n使用建议：对查询返回中使用的所有函数列操作都定义别名\nselect count(*) from ( select c_id, count(*) as number from student_join_class group by c_id ) a where number \u0026gt; 3;  执行的结果为：3 。\n 在分析的时候将 未知表 理解成一张表，这里数据库实际执行的时候确实会生成一张表，称作 临时表 。数据库在执行 sql 的时候，会为每一个子查询生成一个临时表（没有执行优化的情况），看数据库是否为一个 sql 查询生成临时表可以通过查询 SQL 执行计划 来判断。\n查询 SQL 执行计划使用 explain 关键字，执行以下 sql 查看结果输出\nexplain select count(*) from ( select c_id, count(*) as number from student_join_class group by c_id ) a where number \u0026gt; 3;   表连接 为了让大家更好的理解表连接，这里先讲解一下表连接的基本知识。这里假设我们有 A、B 两张表，表中的数据数量分别是 m 和 n。我们现在分别创建 A、B 两张表，并且录入一些数据\n-- ---------------------------- -- Table structure for A -- ---------------------------- CREATE TABLE `A` ( `a_id` int(11) NOT NULL ); -- ---------------------------- -- Records of A -- ---------------------------- BEGIN; INSERT INTO `A` VALUES (1),(2),(3),(4),(4),(5),(5); COMMIT; -- ---------------------------- -- Table structure for B -- ---------------------------- CREATE TABLE `B` ( `b_id` int(11) NOT NULL ); -- ---------------------------- -- Records of B -- ---------------------------- BEGIN; INSERT INTO `B` VALUES (2),(3),(5),(7),(4),(4),(4); COMMIT;  笛卡尔积  我们来看第一个基本概念：笛卡尔积（也叫全连接）。在数学中笛卡尔积的定义是 两个集合 X 和 Y 的笛卡儿积（Cartesian product），又称直积，表示为 X × *Y*，是其第一个对象是 X 的成员而第二个对象是 Y 的一个成员的所有可能的有序对 。\n  这个难以理解的定义在 SQL 里面怎么理解呢？我们链接 A、B 两个表的时候，不加入任何条件，让 A 表中的每一条数据都和 B 表中的每一条数据做关联，就是 A 和 B 的笛卡尔积，也叫全连接。具体 SQL 实现如下：\nselect * from A,B; select * from A join B; select * from A cross join B;  会发现上面的 3 个 sql 语句执行的结果是一样的。我们再看这 3 中链接形式过后的数据量\nselect count(*) from A,B; select count(*) from A join B; select count(*) from A cross join B;  我们会发现 2 点\n 全连接后的数据量是 m × n 全连接后的绝大部分数据是没有意义的  我们可以试想一下如果每个表的数据量都在 100w 这个数量级（在真实生产环境这个数据量是小的），那全连接过后的数据量将是 1亿 数量级，里面的绝大多数数据是没有意义的，并且这里才考虑了 2 个表，这个很可怕的。所以在使用表连接时尽量避免产生全连接。\n普通链接 既然上面说到使用 全连接后的绝大部分数据是没有意义的 ，那我们怎么产生有意义的链接呢？其实也很简单，我们只需要在链接的时候加上有意义的链接条件就行。以下 3 个语句其实是一样的，只是表现形式不同\nselect * from A,B where a_id=b_id; select * from A join B on a_id=b_id; select * from A join B where a_id=b_id;  大家可以发现这里出现的结果其实都在上面的 笛卡尔积 中，只是从 笛卡尔积 中按照 a_id=b_id 的过滤条件选出了少部分数据，这里的 a_id=b_id 就是 有意义的条件 。在解决实际的问题的时候，什么是有 意义的条件 要根据你的问题和设计仔细分析。\n明白了上面的 笛卡尔积 和 有意义的条件 ，我们来看一下最常用的 3 中连接方式：内连接、左连接、右连接。再具体说明之前，先看一下示意图。\n这个示意图和大家在网上使用集合表示的示意图有些不同，主要是我感觉使用集合的示意图不能完全诠释 左连接 和 右连接 的概念和数据量，所以这里根据我自己的理解画了这个示意图。\n  A表数据量 m，B 表数据量 n A、B 的数据量 m x n，这个笛卡尔积后的结果集和原来的 A、B 没有任何关系 在笛卡尔积中满足过滤条件的数据(a, b)，其中 a 是 A表满足过滤条件的数量，b 是 B 表满足过滤条件的数量。但是注意满足条件的数据量并不是 a x b A表中还有 m-a 条数据不满足过滤条件，B 表中还有 n-b 条数据不满足过滤条件   内连接 内连接使用 inner join 子句，表示笛卡尔积中满足过滤条件的数据，也是我们在有过滤条件时的默认方式。\nselect * from A inner join B on a_id=b_id;  这其实和普通连接里的 3 个语句是一样的。\n左连接 内连接使用 left join 子句，表示笛卡尔积中满足过滤条件的数据，在合并左表中不满足过滤条件的数据。\nselect * from A left join B on a_id=b_id;  这里就是表示返回图中满足过滤条件的 a x b 和 不满足过滤条件的 A(m-a)\n右连接 内连接使用 left join 子句，表示笛卡尔积中满足过滤条件的数据，在合并右表中不满足过滤条件的数据。\nselect * from A right join B on a_id=b_id;  这里就是表示返回图中满足过滤条件的 (a , b) 和 不满足过滤条件的 B(n-b)\n 在分析任何链接查询数据量的时候，都可以简单的把查询过程抽象成 3 个逻辑步骤：\n 现将需要链接的表（实体表或临时表）做笛卡尔积 根据过滤条件删选需要的数据 根据不同查询方式合并剩余数据  注意：这个抽象过程只针对数据量分析，并不是数据库的真实执行过程**\n 下面我们来看一下实际怎么在问题中分析使用\n查询学生的姓名、性别和参与班级名称  分析：查询学生的姓名、性别和参与班级名称\n 操作类型：select （查询） 到哪里取数据：学生、班级、学生参与班级表 得到哪些信息：学生姓名、学生性别、参与班级名称 过滤条件：学生参与的班级 排序字段：无 取多少数据：所有数据（无 limit）  通过上面分析得到如下查询结构\n select 学生姓名,学生性别,参与班级名称\nfrom 学生,班级,学生参与班级表\nwhere 学生参与的班级;\n 由上面关于表连接的方式知道，这里需要一个有意义的过滤条件：学生参与的班级 ，由于学生参与班级的信息存储在学生参与班级表 student_join_class 中，所以这里需要连接此表。并且有意的过滤条件也是通过关联表进行匹配的。\n select s.s_name, s.s_sex, c.c_name from student s, class c, student_join_class sjc where s.s_id=sjc.s_id and c.c_id=sjc.c_id;  执行 sql 得到如下结果\n思考：这里为什么 s.s_id=sjc.s_id and c.c_id=sjc.c_id 是有意义的 ？\n查询所有班级名称和参与学生数量  分析：查询所有班级名称和参与学生数量\n 操作类型：select （查询） 到哪里取数据：班级、未知 得到哪些信息：班级名称，参与学生数量 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  通过上面分析得到如下查询结构\n select 班级名称，参与学生数量\nfrom 班级，未知;\n 根据需求可以知道，这里所有的班级名称都需要获取到，不论这个班级有没有人参与，所以这里基本可以确定使用 左连接 。由上了 SQL 实例分析已经得到查询一个班级的人数只需要 student_join_class 就可以了，所以可以确定 班级表左连接学生参与表 就行。表之间的关联关系是使用的数据字段是班级 id，所以这里的有意义过滤条件就是 班级 id 相等。最后为了得到每个班级的参与人数需要根据 班级信息作为分组统计条件。\n select 班级名称，参与学生数量\nfrom 班级\nleft join 学生参与表 on 班级 id 相等\ngroup by 班级;\n  这里班级的区分是通过班级 id 进行唯一区分的，可以有相同的班级名称，所以不能只以班级名称作为分组或分类条件。\nselect c.c_id, c.c_name, count(sjc.c_id) from class c left join student_join_class sjc on sjc.c_id=c.c_id group by c.c_id, c.c_name;   注意：这里是 count(sjc.c_id) ，不能是 count(*) 。可以使用 count(*) 替换 count(sjc.c_id) 看看结果会有什么不同。 为什么请查看前面统计里面关于 count 函数的说明。\n 试试\n查询每个学生报了多少班级 查询有参与2个及以上班级的学生 查询所有班级信息和参与学生数量  总结  子查询：from 子查询、where 子查询 表连接：笛卡尔积、内连接、左连接、右连接 多表查询分析方法  SQL 里面的查询语句学习到这里就截止了，后面将学习 DDL(数据定义语句) 学习和数据据的插入、修改、删除操作，最后简要介绍表索引、试图和存储过程。\n"
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/6-query-statistics/",
	"title": "小白学 SQL 第六天：统计查询",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "今天我们来学习涉及单表查询的最后一种查询方式：统计查询，但让统计查询并不只能用于单表查询的，也可用于多表查询。其实我们前面所有的查询子句都可以用于单表和多表查询，具体多表查询中的使用将在第七天介绍。首先还是看看统计查询里面内容概要，也是今天的知识要点。\n知识要点：\n 统计函数 分组统计 过滤分组统计  \n统计函数 SQL聚集函数有 5 个\n   函数 说明     AVG() 返回某列的平均值   COUNT() 返回某列的函数   MIN() 返回某列的最小值   MAX() 返回某列的最大值   SUM() 返回某列值之和      对所有执行计算，指定ALL参数或不指定参数（因为ALL是默认行为）；只包含不同的值，指定distinct参数 使用 count(*) 对表中行的数目进行计数，不管表列中包含的是空值（null）还是非空值 使用 count(column) 对特定列中具有值得行进行计数，忽略null值。   查询班级总数和设置了开班时间的班级个数 select count(*), count(c_start_time) from class;  执行 SQL 得到结果。这里注意 count(*) 和 count(c_start_time) 的区别\n查询班主任的个数 select count(distinct c_head_teacher) from class;  得到如下结果\n 大家注意这里为什么使用 count(distinct c_head_teacher) 。大家可以执行下面语句，看两个之前的差别在哪里。\nselect count(c_head_teacher) from class;\n 查询生日在 2008-01-18 这天的学生数量 select count(*) from student where s_birthday='2008-01-18';  得到如下结果\n试试\n查询所有学生数量、平均年龄、最小年龄、最大年龄、年龄总和  分组统计：group 子句 在使用统计查询的时候，常常会遇到对数据进行分类排序的需求，这个时候就需要使用到 group 子句，子句格式:\n[GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]]  进行分组或分类的条件可以是一个，也可以是多个；既可以是列，也可以是表达式。\n 使用 group 子句时，select 返回的信息必须是统计信息或分组信息\n 统计不同性别的学生数量和平均年龄，返回性别信息(显示男或女)、数量信息、平均年龄 select case s_sex when 0 then '女' when 1 then '男' end, count(*), avg(s_age) from student group by s_sex  得到如下结果\n试试：去除平均年龄中的小数\n统计不同年龄段学生数量，每10岁为一个年龄段，数量最多的在前面，输出年龄段信息和数量 select concat((ceil(s_age / 10)-1)*10+1, '~', ceil(s_age / 10)*10, '岁') as seg, count(*) from student group by seg order by count(*) desc ;  得到如下结果\n试试\n查询负责班级最多的班主任和负责班级数量  过滤分组统计：having 子句 有时我们会遇到查找满足指定统计条件的数据，这个时候需要使用到 having 子句。having子句类似于where，having支持所有得where操作符，它们得句法是相同的，却别是：where是过滤行，having是过滤分组\n查询学生数量大于1排前三的地区 select s_addr, count(*) from student group by s_addr HAVING count(*)\u0026gt;1 order by count(*) desc limit 0,3 ;  执行结果\n试试\n查询负责2个班级的班主任  总计  统计函数：count、max、min、avg、sum 分组统计：group by 子句 过滤分组统计：having 子句  至此针对单表的常用查询讲解都完了，这里做一个 SQL 语句结构的整理。\nselect子句及其顺序\n   子句 说明 是否必须使用     select 要返回的列或表达式 是   from 从中检索数据的表 仅在从表中选择数据时使用   where 行级过滤 否   group by 分组说明 仅在按组计算聚集时使用   having 组级过滤 否   order by 输出排序顺序 否   limit 限定结果集大小 否    SELECT select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY {col_name | expr | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] ] "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/5-query-function/",
	"title": "小白学 SQL 第五天：数据操作函数",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "我们之前已经学习很多的 SQL 查询支持，但是这些查询只能原样返回数据库里存储的数据，那如果我们需要对这些数据做一个处理怎么办呢？比如：合并2个字段、返回的学生年龄2倍等。这就是今天要一起学习的内容：数据操作函数。每个 RDBMS 提供提供的函数操作都不一样，这里还是以 MySQL 为例子讲解，其他的 RDBMS 请查阅相关文档。由于数据处理函数比较多，这里没有办法全部覆盖，只会列举我们常用的一些操作函数，我把他们分成 5 类：字符串函数、数值函数、时间函数、统计函数、流程控制函数。想知道更多函数详情请参考 MySQL 官方文档。\n知识要点：\n 计算字段、计算列、虚拟列 常用字符串函数 常用数值计算、数值函数 常用日期时间函数 流程控制函数  这里列举的使平时常用的 4 中类型函数分类，另外的统计函数将在下次单独说明。\n\n在查询里面使用计算表达式或函数表达式的列称为计算列或计算字段。它是一个虚拟列，数据库并不实际存储在表中，计算列的表达式可以使用其他列中的数据来计算其所属列的值。\n字符串函数 下面是常用的一些字符处理函数\n   函数 描述 实例     concat() 拼接字符串 SELECT concat(\u0026lsquo;Hello\u0026rsquo;, \u0026lsquo;, \u0026lsquo;, \u0026lsquo;World\u0026rsquo;,\u0026lsquo;!\u0026rsquo;);   format() 格式化数字到字符串 SELECT format(12332.1,4);   length() 返回字符串长度 SELECT length(\u0026lsquo;xxx\u0026rsquo;);   lcase()/lower() 转换小写 SELECT lower(\u0026lsquo;ABcDef\u0026rsquo;);   ltrim() 去掉左边空白字符 SELECT ltrim(\u0026rsquo; AB cD f \u0026lsquo;);   repeat() 重复输出字符串 SELECT repeat(\u0026lsquo;A\u0026rsquo;, 3);   replace() 替换字符串 SELECT replace(\u0026lsquo;ABBCD\u0026rsquo;, \u0026lsquo;BB\u0026rsquo;, \u0026lsquo;W\u0026rsquo;);   reverse() 翻转输出字符串 SELECT reverse(\u0026lsquo;abcd\u0026rsquo;);   left() 返回左边字符串 SELECT left(\u0026lsquo;abcdf\u0026rsquo;, 2);   right() 返回右边字符串 SELECT right(\u0026lsquo;abcdf\u0026rsquo;, 2);   rtrim() 去掉右边空白字符 SELECT rtrim(\u0026rsquo; AB cD f \u0026lsquo;);   substr()/substring() 截取子字符串 SELECT substr(\u0026lsquo;Quadratically\u0026rsquo;,5);\nSELECT substr(\u0026lsquo;Quadratically\u0026rsquo;,5,6);   trim() 去掉空白字符 SELECT trim(\u0026rsquo; AB cD f \u0026lsquo;);   ucase()/upper() 转换大写 SELECT upper(\u0026lsquo;ABcDef\u0026rsquo;);    还是通过实例分析他们的使用\n查询班主任信息，输出3遍老师信息  分析：查询老师信息，输出3遍老师信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：3 遍班主任信息 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 班主任 * 3\nfrom 班级;\n  班主任 * 3 由于班主任存储的是字符串类型，重复3次表示为 repeat(c_head_teacher, 3)   得到如下 SQL\nselect repeat(c_head_teacher, 3) from class;  执行得到如下结果\n试试\n查询班级名称长度并将班级名称翻转输出  数值计算、数值函数 数值计算操作符\n   操作符 描述 实例     + 加 select 2+3;   - 减 或 取反 select 2-1, -2;   * 乘 select 2*3;   / 或 div 除 select 2\u0026frasl;4, 2 div 4;   % 或 mod 取余 或 取模 select 2%4, 2 mod 4;    数值计算函数\n   函数 描述 实例     abs() 绝对值 SELECT abs(-10), abs(9);   ceil()/ceilling() 上取整 SELECT ceiling(3.4), ceil(3.5), ceil(3.6);   conv() 进制转换 SELECT conv(10,10 ,2), conv(10,2 ,10);   exp() 自然数数 e 的 n 次方 SELECT exp(1), exp(0), exp(-1);   floor() 下取整 SELECT floor(3.4), floor(3.5), floor(3.6);   pow()/power() 指数函数 SELECT POW(1,3), pow(2,3), pow(4,2);   round() 四舍五入取整 SELECT round(3.4), round(3.5), round(3.6);   rand() 随机数 SELECT rand(), rand()*10;   mod() 取余/取模 SELECT mod(25, 7), 25 % 7, mod(25.4, 7), 25.4 % 7;   pi() PI 值 SELECT pi(), pi()+0.0000000000;    查询所有学生姓名和年龄，将所有学生的年龄翻倍，且年龄大的在后面  分析：查询所有学生信息，将所有学生的年龄翻倍，且年龄大的在后面\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：姓名、年龄翻倍 过滤条件：无 排序字段：龄大的在后面 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 姓名, 年龄翻倍\nfrom 学生\norder by 龄大的在后面;\n  得到如下 SQL\nselect s_name, s_age * 2 from student order by s_age * 2 asc;  执行得到如下结果\n查询学生年龄和姓名，并按照年龄的 1\u0026frasl;3 下取整输出  分析：查询学生年龄和姓名，并按照年龄的的 1\u0026frasl;3 下取整输出\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：姓名、年龄的 1\u0026frasl;3 下取整 过滤条件：无 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 姓名, 年龄的 1\u0026frasl;3 下取整\nfrom 学生\norder by 龄大的在后面;\n 年龄的 1\u0026frasl;3 下取整 先求出年龄的 1/3，再用 下取整函数处理\n 得到如下 SQL\nselect s_name, floor(s_age/3) from student;  执行得到如下结果\n试试\n查询所有10岁的学生姓名和年龄，要求输出2遍姓名和5年后的年龄  日期时间函数    函数 描述 实例     now() 当前日期时间 select now(), CURRENT_TIMESTAMP();   curtime() 当前时间 select curtime();   curdate() 当前日期 select curdate();   from_unixtime() 从时间戳到日期 select from_unixtime(1);   unix_timestamp() 返回日期时间戳 select unix_timestamp(now());   time() 从时间里面获取时间部分 select time(now())   date() 从时间里面获取日期部分 select now(), date(now());   date_format() 格式化日期/时间数据\ndate_format(date, format) select date_format(now(),\u0026lsquo;%b %d %Y %h:%i %p\u0026rsquo;),\ndate_format(now(),\u0026lsquo;%m-%d-%Y\u0026rsquo;);   adddate()/date_add() 向日期添加指定的时间间隔\nadddate(date, interval num unit) select date_add(now() ,interval 45 DAY), adddate(now() ,interval 45 DAY);   subdate()/date_sub() 向日期减去指定的时间间隔\nsubdate(date, interval num Type) select date_sub(now() ,interval 45 DAY), subdate(now() ,interval 45 DAY);   datediff() 返回两个日期之间的天数 SELECT datediff(\u0026lsquo;2018-01-30\u0026rsquo;,\u0026lsquo;2018-04-27\u0026rsquo;);    还有很多的时间获取函数，这里不再列举，在用到的时候查下文件就行 《MySQL 日期时间函数》\n时间 ADD 和 SUB 的 unit 可取值有    Type 值     MICROSECOND   SECOND   MINUTE   HOUR   DAY   WEEK   MONTH   QUARTER   YEAR   SECOND_MICROSECOND   MINUTE_MICROSECOND   MINUTE_SECOND   HOUR_MICROSECOND   HOUR_SECOND   HOUR_MINUTE   DAY_MICROSECOND   DAY_SECOND   DAY_MINUTE   DAY_HOUR   YEAR_MONTH    时间 format 可使用的格式有：    格式 描述     %a 缩写星期名   %b 缩写月名   %c 月，数值   %D 带有英文前缀的月中的天   %d 月的天，数值（00-31）   %e 月的天，数值（0-31）   %f 微秒   %H 小时（00-23）   %h 小时（01-12）   %I 小时（01-12）   %i 分钟，数值（00-59）   %j 年的天（001-366）   %k 小时（0-23）   %l 小时（1-12）   %M 月名   %m 月，数值（00-12）   %p AM 或 PM   %r 时间，12-小时（hh:mm:ss AM 或 PM）   %S 秒（00-59）   %s 秒（00-59）   %T 时间, 24-小时（hh:mm:ss）   %U 周（00-53）星期日是一周的第一天   %u 周（00-53）星期一是一周的第一天   %V 周（01-53）星期日是一周的第一天，与 %X 使用   %v 周（01-53）星期一是一周的第一天，与 %x 使用   %W 星期名   %w 周的天（0=星期日, 6=星期六）   %X 年，其中的星期日是周的第一天，4 位，与 %V 使用   %x 年，其中的星期一是周的第一天，4 位，与 %v 使用   %Y 年，4 位   %y 年，2 位    查询学生在哪一年出生，年份早的排在前面  分析：查询学生在哪一年出生，年份早的排在前面\n 操作类型：select （查询） 到哪里取数据：学生 得到哪些信息：在哪一年出生 过滤条件：无 排序字段：年份早的排在前面 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 在哪一年出生\nfrom 学生\norder by 年份早的排在前面;\n 在哪一年出生 这个信息是在生日字段里面，生日字段是包含了年月日信息，只需要使用 year 函数处理就能得到年了：year(s_birthday)\n 得到 SQL 语句\nselect year(s_birthday) from student order by year(s_birthday) asc;  执行得到如下结果\n试试\n大家发现学生表里面有年龄字段和生日字段，上面我们使用了生日计算出生年，现在使用年龄计算出生年，看看会是什么结果，应该是和生日不一样的（这里是故意的，后面在修改数据时候会改过来） 计算班级从开班时间到结束时间持续了多少天  流程控制函数 MySQL 流程控制函数有 4 个：CASE、IF()、IFNULL 、NULLIF ，我自己平时用的最多的是 CASE ，这里只演示 CASE 的使用，其他几个在一个特定的场景下使用，到时候遇到了查下文档吧。\nCASE 语法 CASE 语句有2中语法，一种是值判断，一种是条件判断。\n值判断语法 CASE value WHEN [compare_value] THEN result [WHEN [compare_value] THEN result ...] [ELSE result] END  条件判断语法 CASE WHEN [condition] THEN result [WHEN [condition] THEN result ...] [ELSE result] END  查询学生性别和姓名，性别输出文中文男和女（0：女，1：男） select s_name, case c_sex when 0 then '女' when 1 then '男' end as '性别' from student  查询学习性别和年龄段，年龄段输出为：1~10的为小，11~15的中，16~20的大 select s_name, case when s_age\u0026gt;=1 and s_age\u0026lt;=10 then '小' when s_age\u0026gt;=11 and s_age\u0026lt;=15 then '中' when s_age\u0026gt;=16 and s_age\u0026lt;=20 then '大' end as '年龄段' from student;  试试\n查询学生生日的月份，要求中文数值输出月份(比如：一月、二月、三月)   上面最后两个 SQL 没有给出详细的分析过程，对于这个分析过程可以自行按照之前的模式进行，这种分析模式掌握过后，不论多复杂的需求和 SQL 都可以做到游刃有余，所以大家一定要掌握。对于后面简单的 SQL 不再给出详细分析过程，分析过程只针对复杂 SQL 和关键部分，如果大家对于哪个问题和SQL 需要分析过程的，可以在后面留言或联系我。\n 总结  计算字段、计算列、虚拟列 常用字符串函数 常用数值计算、数值函数 常用日期时间函数 流程控制函数：case 语句的 2 种格式 "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/4-query-where/",
	"title": "小白学 SQL 第四天：数据过滤查询",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "在第三天的时候学习了数据的基本查询结构，包括：查询指定列，返回指定大小结果集，数据排序，数据去重。今天将学习查询里面另外一个基础且重要的查询结构：过滤查询（也叫条件查询），可以说现今你能看到的所有涉及到 RDBMS 软件一定都有 过滤查询 。所以今天的内容一定要掌握，也是一切用到 RDBMS 系统的所需掌握的基础知识之一。\n今天涉及到的知识要点：\n where子句子结构 数值、时间 字符串匹配： like、百分号（%）通配符、下划线（_）通配符 范围值检查：between 、in 空值查询：is null、not 组合查询：and、or、求值顺序  \nWHERE 子句结构 既然是子句就一定是跟在主句后面，where 子句可以用在 select、update、delete 语句中。今天只会讲解在 select 语句中的使用，update 和 delete 中的使用会在后面 数据插入、修改和删除 中讲解。首先还是来看一下 where 子句在 select 中的结构\nselect [distinct] 列1，列2，... from table_name [where 条件1 [and|or] 条件2 ...] [order by 列1 desc[, 列2 asc]] [limit offset, size];   where 条件1 [and|or] 条件2 … 过滤条件。可以使用逻辑连接符（and 或 or）连接多个条件。\n条件N 每个条件。格式： \u0026lt;列\u0026gt; \u0026lt;操作符\u0026gt; \u0026lt;值\u0026gt;\n 大家可以和前一天的 Select 语句做对比看有什么不同\n操作符    操作符 说明 操作符 说明     = 等于 \u0026gt; 大于   \u0026lt;\u0026gt; 不等于 \u0026gt;= 大于等于   != 不等于 !\u0026gt; 不大于   \u0026lt; 小于 between 在指定两个值之间   \u0026lt;= 小于等于 is null 为null的值   !\u0026lt; 不小于 like 匹配   and 逻辑与 or 逻辑或   not 逻辑非      数值、时间过滤 还记得之前在《数据表创建》时说明的数据类型吗？如果没有什么印象可以转过去浏览一遍。在做数据过滤查询的，我们要关注所使用过滤列的数据类型，判断我们所需要使用的操作符和数值表达方式，我们还是通过实例讲解。\n查询已开学班级的名称和班主任  分析：查询 已开学 班级 的 名称 和 班主任\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：名称、班主任 过滤条件：已开学 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,班主任\nfrom 班级\nwhere 已开学;\n  这里的 已开学 怎么表示呢？我们看班级的创建 SQL，会发现列 c_status 的描述是 班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】\n  在结合*条件格式： \u0026lt;列\u0026gt; \u0026lt;操作符\u0026gt; \u0026lt;值\u0026gt;，这时候就比较清晰了吧：班级状态 是/等于 已开学，班级状态在数据库存的数据类型是 数值型 ，这里也就是 3 。这个时候在将语言翻译成代码表达：c_status = 3 。\n 现在所有需要的信息都收集完成了，组装我们 SQL 语句：\nselect c_name, c_head_teacher from class where c_status = 3;  执行这个语句会的一下结果\n查询标识 id大于10 的班级的标识 id 和名称信息  分析：查询 标识 id大于10** 班级 的 标识 id 和 名称 信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：标识 id，名称 过滤条件：标识 id大于10 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,班主任\nfrom 班级\nwhere 标识 id 大于 10;\n 结合上面的操作符描述 标识 id 大于 10 的代码标识：c_id \u0026gt; 10\n 所以的 SQL 语句：\nselect c_name, c_head_teacher from class where c_id \u0026gt; 10;  执行这个语句会的一下结果\n查询在2018年4月2日开班的班级名称、标识 id和开班时间  分析：查询 在 在 2018年4月2日开班 的 班级名称 和 标识 id\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：标识 id，名称，开班时间 过滤条件：在 2018年4月2日开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称,标识 id,开班时间\nfrom 班级\nwhere 在 2018年4月2日开班;\n 在这里我们发现 开班时间 在表里面的存储类型是日期 date 类型，这里就涉及到日志的表示方式，以下是默认表示方式:\n    日志类型 表示格式 例子     year YYYY 或 YY 第一种是直接插入4位字符串或者4位数字（推荐）。\n第二种是插入2位字符串。如插入‘00’~‘69’，则相当于插入2000~2069；如果插入‘70’~‘99’，则相当于插入1970~1999。第二种情况下插入的如果是‘0’，则与插入‘00’效果相同，都是表示2000年。\n第三种是插入2位数字，它与第二种（插入两位字符串）不同之处仅在于：如果插入的是一位数字0，则表示的是0000，而不是2000年。所以在给YEAR类型赋值时，一定要分清0和‘0’，虽然两者相差个引号，但实际效果确实相差了2000年。   time HH:MM:SS 14:23:23   date YYYY-MM-DD 2018-04-23   datetime YYYY-MM-DD HH:MM:SS 2018-04-23 14:23:23   timestamp YYYY-MM-DD HH:MM:SS A、CURRENT_TIMESTAMP或 NULL或无任何输入 这时系统会自动填入当前 timestamp 值（这个需要创建列时设置）\nB、`2018-04-23 14:23:23\n注意： timestamp数值是与时区相关的。    通过以上分析，得到 SQL 语句：\nselect c_name, c_status, c_start_time, c_end_time from class where c_start_time='2018-04-02';  执行这个语句会的一下结果\n试试\n查找还未结束的且开始时间最晚的前6个班级的名称、状态、开始时间和结束时间信息  字符串匹配 首先字符串在 SQL 中需要单引号包裹起来，比如：'字符串1'、'hello world!'。\n查询班主任姓名为 老师10 的班级信息，结束时间最晚的在前面  分析：查询 在 班主任姓名为 老师10 的 班级信息，结束时间最晚的在前面\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：班主任姓名为 老师10 排序字段：结束时间 -\u0026gt; 倒序（结束时间最晚的在前面） 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 班主任姓名为 老师10\norder by 结束时间 倒序;\n  所以得到 SQL\nselect * from class where c_head_teacher = '老师10' order by c_end_time desc;  执行 sql 得到如下结果\n 在实际使用字符串匹配查询的时候，处理上面例子演示的 精确查找 以外，我们还会有 模糊查找 的需求（也叫 *模糊匹配*）。比如我们常常有 查找姓王的用户 、 查询名字中含有水字的用户 等需求。\n字符串的模糊匹配使用 like 关键字，既然是模式匹配就说明列里面的部分信息我们是不关心的，也不知道他们具体是什么值，这时对于这些不关心的数据我们使用 占位符 。MySQL 数据库支持的占位符有 2 个: % 和 _ ，这两个的比较说明如下：\n   占位符 说明 实例     % 一次匹配多个任意字符 王%：所有以 王 开头的任意长度的数据，例如：王，王x、王 xx\n%王：所有以 王 开头的任意长度的数据，例如：王，x王、xx王\n%王%：所有包含 王 的数据，不论王所在位置   _ 一次匹配一个任意字符 王_：所以以 王 开头的 2 个长度的数据，例如：王 x，王2    \n试试\n大家可以思考一下 %刘_ 是匹配什么样的数据   查询所有以老师开头的班主任信息，结果去重  分析：查询 所有 以老师开头 的 班主任信息，结果去重\n 操作类型：select （查询） 到哪里取数据：班级（班主任信息在班级表里） 得到哪些信息：班主任信息 过滤条件：以 \u0026ldquo;老师\u0026rdquo; 开头的班主任 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 去重 班主任\nfrom 班级\nwhere 以 \u0026ldquo;老师\u0026rdquo; 开头的班主任;\n  所得 SQL\nselect distinct c_head_teacher from class where c_head_teacher like '老师%';  直接结果\n试试\n查询所有姓张且姓名包含三个字的学生信息  空值查询 在数据库里面还存在一种类型：null ，他表示没有值，意味着我们什么都没有输入。注意这个值和 空字符串'' 的区别：'' 标识值是空字符串(有值)；null 标识无值。我们要查询一个列是否包含有无值得数据使用 is null 。大家可以执行下面这个 SQL ，大家可以自行分析一下这个 SQL 所表达的需求\nselect * from class where c_start_time is null;  由于我们现在数据库里面没有无值的数据，所以结果是空的\n现在我们在加入 2 条空值数据，请执行下面的插入 SQL\nINSERT INTO `sql-learn`.`class`(`c_id`, `c_name`, `c_head_teacher`, `c_start_time`, `c_end_time`, `c_status`, `c_created`) VALUES (17, '酱油班1', '酱油老师', NULL, NULL, 3, '2018-04-24 13:03:39'), (18, '酱油班2', '酱油老师', NULL, NULL, 2, '2018-04-24 13:03:33');  插入完成过后，再执行上面的查询 SQL ，这时候就会出现我们刚才插入的 2 条数据：酱油班1 和 酱油班2 。这时我们查询出了所有的 无值 数据，那我们怎么得到所有 有值 数据呢？这里只要我们对过滤条件取反（或叫取非）就可以了：关键字 not 。请大家执行下面 SQL 分析结果：\nselect * from class where not c_start_time is null;   not 关键字就是对某一过滤条件取反，它不仅仅是用在 is null 条件上面，可以用在任何一个过滤条件上，甚至后面的组合查询里面的组合条件也是可以使用的。大家可以将前面实验的 SQL 语句的查询条件上面加上 not 在执行看看结果，是否和你理解的一致。\n建议大家不要随意使用 not ，这个会导致你的 SQL 语句变复制、不易理解，同时导致后面优化 SQL 变得困难。建议只使用在 is null 和 like 操作上。\n 范围查询 前面的所有查询都是单个值查询，现在如果我们知道了 2 个班主任老师的名称：酱油老师 和 *会计老师1*，我们需要查询这 2 个老师的负责的所有班级怎么办呢？用我们的上面的查询都办不到，现在需要一种新的查询类型：范文查询。范围查询有 2 中格式：between start_value and end_value 和 in ，between 表示连续值范围查询，多用在数值和时间范围；in 表示非连续值范围，多用在字符串范围查询。具体我们通过实例分析\n查询 会计老师1 和 酱油老师 2个老师负责的所有班级信息  分析：查询 会计老师1 和 酱油老师 2个老师负责的所有班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：会计老师1 和 酱油老师 (使用 in) 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 会计老师1 和 酱油老师;\n 在这里我们可以看到同时有 2 个值，同时这两个值没有相关性和连续性，所以这里使用 in\n 得到以下 SQL\nselect * from class where c_head_teacher in ('会计老师1', '酱油老师');  执行 SQL 得到以下结果\n查询开班时间在2017-12-03到2018-04-01之间的所有班级信息  分析：查询开班时间在2017-12-03到2018-04-01之间的所有班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：开班时间在2017-12-03到2018-04-01之间（使用 between） 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 开班时间在2017-12-03到2018-04-01之间;\n 在这里我们发现也是 2 个条件值，但是这次的要求是找到 2017-12-03到2018-04-01之间 的所有班级，因为在我们查询数据之前没有办法知道每个班级的具体开班时间，同时从2017-12-03到2018-04-01之间 的所有日期时间点我们没有办法穷举出来（这里可能有人会说可以列举出来，这之间也没有多少天，但是如果我们这里存入的不是天，而是需要精确到秒呢，更进一步这里需要精确到毫秒呢（如创建时间）），所以这里我们就不能用 in 了，需要使用 between\n 通过上面分析，得到如下 SQL\nselect * from class where c_start_time between '2017-12-03' and '2018-04-01';  得到如下结果\n试试\n查询开班时间是 2017-10-09 和 2018-04-02 的班级信息 在 between 语句中的 2 值有包含在查询结果集里面吗？写出 SQL 验证你的结论  组合查询 在前面我们已经学习了很多的过滤条件，但是大家会发现这些条件都是基于某一个属性的单个值或多个值进行查询，那我们如果我们需要同时匹配多个属性的值查询应该怎么办呢？这个时候就需要用到我们接下来学习的 组合查询 了。组合查询顾名思义就是组合了多个过滤条件的查询语句，其中组合的方式有 2 中：and 和 or 。这两个的含义和区别如下：\n   组合方式 含义 实例     and 逻辑与（同时满足） A and B and C：A、B、C 3个条件必须全部为真才满足   or 逻辑或（满足其一） A or B or C：A、B、C 3个条件 只要其中一个为真就满足    下面我们还是通过 2 个实例来具体学习\n查询老师10在2018-04-02这天开班的班级信息  分析：查询老师10在2018-04-02这天开班的班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：老师10 、2018-04-02开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 老师10 、2018-04-02开班;\n 这这里我们看到有 老师10 和 2018-04-02开班 2 个值，我们发现 老师10 是班主任信息字段，而 2018-04-02开班 是开班时间字段，两个不是同一个字段，这样就不能使用上面的范围查询了(between 和 in)。既然是 2 个字段条件，那我们就来分开分析：\n 老师10：要求班主任是老师10 =\u0026gt; c_head_teacher='老师10' 2018-04-02开班：开班时间在2018-04-02 =\u0026gt; c_start_time='2018-04-02'  现在两个条件都分析清楚了，那这两个条件的组合方式是什么呢？根据问题 *老师10在 2018-04-02这天开班*： 必须需要 老师10 在 2018-04-02 这天开班的班级信息，老师和开班时间 2 个条件必须满足，所以组合方式是 and，组合得到的过滤条件就是:c_head_teacher='老师10' and c_start_time='2018-04-02' 。现在所有的分析都完成了，来看我们得到的 SQL 语句\n 所得 SQL 语句\nselect * from class where c_head_teacher='老师10' and c_start_time='2018-04-02';  执行得到以下结果\n查询老师5 或 2018-04-02这天开班的班级信息  分析：查询老师10在2018-04-02这天开班的班级信息\n 操作类型：select （查询） 到哪里取数据：班级 得到哪些信息：所有信息 过滤条件：老师10 或 2018-04-02开班 排序字段：无 取多少数据：所有数据（无 limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select *\nfrom 班级\nwhere 老师10 或 2018-04-02开班;\n 根据之前的分析这里的两个条件\n c_head_teacher='老师5' c_start_time='2018-04-02'  但是这里这里的组合方式和上面会不一样，有发现吗？这里的需求是: 老师5 或 2018-04-02 ，应该使用的组合方式是 or。\n所以组合得到的过滤条件就是:c_head_teacher='老师5' or c_start_time='2018-04-02'\n 所得 SQL 语句\nselect * from class where c_head_teacher='老师5' or c_start_time='2018-04-02';  执行得到以下结果\n  当组合多个过滤的时候如果同时有 and 和 or 的组合方式，需要注意执行的优先级和先后顺序 sql语句中not and or的执行优先级从高到低依次为: not \u0026gt; and \u0026gt; or\n 执行时从左到右依次执行\n 重要建议 对于不能确定的时候可以使用小括号 () 改变或指明优先级\n 对于同时又 not、and、or 的组合查询始终使用 () 指明优先级\n   试试\n试着把上面使用 in 的查询改成组合查询：查询 会计老师1和酱油老师2个老师负责的所有班级信息 查询姓王且年龄在16岁以下学生和在西安的学生，年龄最小的排在前面  总结 这次的东西有点多，特别是组合查询需要多多联系和实践，\n where子句子结构，操作符 数值、时间：时间的表示方法 字符串匹配： like、百分号（%）通配符、下划线（_）通配符 范围值检查：between … and … 、in 空值查询：is null、not 组合查询：and、or、优先级和求值顺序 "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/3-query-data/",
	"title": "小白学 SQL 第三天：单表数据查询",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "《小白学 SQL》第三天\n数据查询应该是我们平时用得最多的数据库操作，所以我们优先学习数据查询，今天我们就来看看基础的数据查询操作：单表数据查询，涉及到的知识点有：\n 检索单个列 检索多个列 数据去重 返回定量数据集 排序检索数据  \n先启动联系环境，具体启动方式和步骤请参看《小白学 SQL 第二天：数据表创建》。\nSELECT 语句结构 查询数据使用的到时 SELECT 语句，首先一起看一下今天用到 SELECT 语句结构：（这里不能理解没有关系，有个印象就行，稍后我们通过后面的例子理解）\nselect [distinct] 列1，列2，... from table_name [order by 列1 desc[, 列2 asc]] [limit offset, size];   列1、列2 列。在实际使用的时候，就是表示我们需要得到的信息，就是 E-R 图里面 椭圆 的部分\ntable_name 表名。在实际使用的时候，就是表示我们需要到哪里获得数据，就是 E-R 图里面 矩形 的部分\ndistinct 去重标识。如果多条数据完全相同的时候，只保留一条数据结果\norder by 排序语句。指定查询结果集按照特定列排序，可以同时多个列排序用,分割。排序可以正序(asc)或倒序(desc)\nlimit offset, size 数据限定。在实际使用的时候，就是表示我们需要获得多少数据，就是常说的分页查询。当没有 limit 限定时，表示取到所有数据\n 要学习详细完整的 SELECT 语句结构请查看 MySQL 官方文档。\n查询实例 我们的学习主要是以实际使用为主，所以所有的 SQL 语句之前都会给出命题和分析。\n还记得我们之前建立的数据表结构吧，这里我们会用到班级表，建议大家回顾一个班级的 E-R 图和创建表 SQL。\n查询所有班级的所有信息  分析：查询 所有 班级 的 所有信息\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：所有信息 （所有的*椭圆*） 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 班级所有信息 from 班级;\n 由于 班级所有信息 的所有椭圆是：标识 id、名称、班主任、开班时间、结束时间、状态、创建时间，这样我们可以得到下面的分析结果：\n select 标识 id,名称,班主任,开班时间,结束时间,状态,创建时间 from 班级;\n  通过上面的分析我们得到了和 E-R 图对应的类 SQL 语句，现在需要把这个 sql 翻译成数据库可以执行的正式 SQL。在从 E-R 图到数据表的过程中我们在名字上有这样的对应的关系：\n   E-R 图中的名称 数据库中的对应名称     班级 class   表示 id c_id   名称 c_name   班主任 c_head_teacher   开班时间 c_start_time   结束时间 c_end_time   状态 c_status   创建时间 c_created    按照这个对应表我们替换上面的类 SQL，得到下面的真实可执行 SQL：\nselect c_id,c_name,c_head_teacher,c_start_time,c_end_time,c_status,c_created from class;  copy 到 Navicat 的 SQL 执行其中会得到如下结果：\n执行下面这个 SQL 应该会得到和上面一样的结果\nselect * from calss;  这里的* 表示返回所有列信息，在实际使用中查询所有列或所有信息时，我们常常是用*代替。\n查询所有班级的名称  分析：查询 所有 班级 的 名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：名称 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 名称 from 班级;\n 这里名称已经是一个存在的特定列（属性）了，所以不再替换分析了。\n 对照上面的映射表，我们很容易得到真实可执行 SQL：\nselect c_name from class;  执行 SQL 语句会得到如下结果\n试试\n查询所有班级的名称和班主任信息  查询前5个班级的标识 id和名称  分析：查询 前5个 班级 的 标识 id和名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id 、名称 取多少数据：5 (前5个) 从哪里开始取：0（前5个）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称 from 班级 limit 0,5;\n  limit 0,5 说明: 我们可以建档的理解成：数据库在执行的时候，先执行没有 limit 限定的 SQL，得到所有的结果；然后在根据 limit 限定条件对数据进行 裁剪 返回。必须这里的limit 0,5: 从第 0 个(不包含 0)开始的 5 条数据（就是前 5 条数据）。大家可以想象 limit 3,4 的含义，并执行看看会有什么结果。\n   对照上面的映射表，转换得到真实可执行 SQL：\nselect c_id,c_name from class limit 0,5;  执行 SQL 语句会得到如下结果\nlimit 在实际使用的时候往往是用在分页数据查询，比如大家逛淘宝、京东都会不断翻页的查找数据。这个时候我们常常使用的表达是：按照每页4条数据大小 分页查询 第3页 班级数据的标识 id 和名称。我们来简单分析一下这个 SQL\n 分析：按照每页4条数据大小 分页查询 第3页 班级数据的标识 id 和名称\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id 、名称 取多少数据：4 (按照每页4条数据大小 ) 从哪里开始取：4 x (3-1) = 8（第3页，跳过前面2页数据，从第 2 页最后一条数据开始(不包含)往后取）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称 from 班级 limit 8,4;\n 所以得到 SQL\n select c_id, c_name from class limit 8,4;\n 大家执行上面的 SQL 看看结果。\n 试试\n按照每页3条数据大小分页查询第4页班级数据的标识 id 、名称和班主任  数据去重 请执这条 SQL\nselect c_name from class;  大家可以看到里面有2条 会计考试班 2 数据，在实际使用的时候我们常常会遇到去掉重复数据需求，这是往往大家描述的时候会出现 去掉重复、去重 等修饰词。这个时候我们需要使用 SQL 的 distinct 关键字，请大家只想下面的 SQL\nselect distinct c_name from class;   注意: distinct 去重试会比较所有 返回数据列 。请大家执行下面两个 SQL，然后看结果和之前的 2 个 SQL 进行对比，就比较好理解了\n select c_id, c_name from class;\nselect distinct c_id, c_name from class;\n  排序检索 排序我们通过 2 个实例讲解，分别讲解单列排序和多列排序\n查询所有班级信息，标识 id 大的在前面  分析：查询 所有 班级信息，标识 id 大的在前面\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：全部 排序字段：标识 id -\u0026gt; 倒序（大的在前面） 取多少数据：不做限制  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select * from 班级\norder by 标识 id desc;\n 还记得吗！如果返回所有的列，我们可以使用 * 标识\n 现在结合E-R 图到表的映射，我们得到如下SQL\nselect * from class order by c_id desc;  执行这个结果我们会得到如下结果\n大家可以将 desc 改变成 asc 查看一下效果\n查询班级的标识 id、名称、开班时间，按照开班时间先后排列，开班时间相同的标识 id 倒序返回  分析：查询班级的标识 id、名称、开班时间，按照开班时间倒序，开班时间相同的标识 id 倒序返回\n 查询：select 到哪里取数据：班级 得到哪些信息(列)：标识 id、名称、开班时间 排序字段1：开班时间 -\u0026gt; 正序 排序字段2：标识 id -\u0026gt; 倒序 取多少数据：所有班级 （没有limit）  我们将这些信息套入到 SELECT 语句结构会得到如下：\n select 标识 id, 名称, 开班时间 from 班级\norder by 开班时间 正序, 标识 id 倒序;\n  现在结合E-R 图到表的映射，我们得到如下SQL\nselect c_id,c_name,c_start_time from class order by c_start_time asc, c_id desc;  执行这个结果我们会得到如下结果\n 当使用多个列排序的时候，排序的处理顺序是从左到右，对于左边列值相同的行数据才会使用后面的列对其排序操作。\n 试试（综合实例）\n查询结束时间最早的 10 个班级的标识 id、名称、开班时间、结束时间；如果结束时间相同，就返回开发时间最好的；如果结束时间和开班时间都相同，就返回标识 id 最大的。查询结果应该如下：  按每页6条数据查询第 3 页班级信息，按照创建时间最大的排在前面，如果创建时间一样就按照 班主任 信息顺序排列。查询结果应该如下：  总结  SELECT 语句基本基本结构 查询需求或问题分析方法：综合 需求或问题描述、E-R 图 和 表结构 3方信息实施从问题到可执行 SQL 的分析设计 查询单列、多列、所有列数据 使用 limit 子句限定返回结果集中的数据的数量(结果集大小) 使用关键字 distinct 进行查询结果去重，注意取重时是比较所有查询列 使用 order by 子句对结果进行排序，可以是单列或多列，每列可以指定自己的排序方式：正序(asc)或倒序(desc)   大家会发现我们这里交替出现 属性、字段、列 如果没有特殊说明，这三个词语表达的含义是一样的，都不是标识数据表列或 ER 图属性。\n"
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/2-create-table/",
	"title": "小白学 SQL 第二天：数据表创建",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "《小白学 SQL》第二天\n今天我们来学习数据表（table）的建立，涉及到的内容可能大家还不能完全理解，这里主要是为后面的查询语句做些基本准备和数据准备，后面还会专门学习 DDL（数据学习语言），所以没有关系这里大家只要能执行得到正确结果就行。\n今天涉及到的内容有：\n 表创建语句（create） 数据插入语句（insert ） MySQL 基本数据类型 E-R图（实体关系图）  \n启动学习环境 这里假设你的 docker 服务由于某些原因停止了（如：开关机），需要手动启动相关服务。如果你的 docker 服务和 sql-learn 已经正常启动，请跳过此章节（什么？你还没有 docker 和 sql-learn，请看这里）。这里所有的操作都可以参考第一天的内容，在这里。\n 启动 docker 服务   A、windows 通过桌面图标 或 系统菜单来启动\nB、Mac 通过 Launchpad 面板来图标启动\nC、Linux 通过命令行启动，不同版本会有所不同，可以查看第一天学的内容。\n  启动数据库服务器 (sql-learn 容器)   打开命令行工具输入一下命令，启动 sql-learn 容器\ndocker start sql-learn  输入一下命令查看启动状态\ndocker ps  结果如下：\n 启动数据库客户端（Navicat）  打开 Navicat 软件，通过左边的连接收藏栏，双击 sql-learn 连接，连接到数据库服务器（图中 ）。然后打开 sql-learn 数据库，就是双击 sql-learn 数据库（图中 ）。打开结果如下图：\n 通过以上 3 步，我们就打开了我们的学习环境，对于我们以后的每次学习进来的操作步骤都是一样的，所以这里大家一定要会，如果有什么问题可以给我留言。\n 创建数据表 create table (创建表)语句结构 以下是上面 SQL 语句的简单模板说明，具体完整的 CREATE TABLE 语句语法请参考 MySQL 官方文档。我们这里使用的足够了\nCREATE TABLE \u0026lt;table_name\u0026gt; ( \u0026lt;column_name\u0026gt; \u0026lt;data_type\u0026gt; [column_options] [COMMENT '\u0026lt;comment\u0026gt;'] [, ...] ) [table_options]   table_name: 表名称 column_name： 列名称 data_type： 列数据类型 column_options：列定义选项 comment ：注释 table_options：表定义选项 [, …]: 表示可以有多个列定义，使用 , 分割  设计并创建表 这里我们构想一个培训班的业务场景：\n 一个培训班有很多学生\n每个学生可以参加多个培训班\n 班级信息表 班级表创建 SQL ：\nCREATE TABLE `class` ( `c_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班级 id，组件', `c_name` varchar(512) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班级名称', `c_head_teacher` varchar(64) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '班主任名称', `c_start_time` date DEFAULT NULL COMMENT '开班日期', `c_end_time` date DEFAULT NULL COMMENT '结束日期', `c_status` int(11) NOT NULL COMMENT '班级状态【0：报名未开始，1：报名中，2：报名完成，3：已开学，4：已结业】', `c_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`c_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='班级信息表';  学生信息表 学生表创建 SQL：\nCREATE TABLE `student` ( `s_id` int(11) NOT NULL AUTO_INCREMENT COMMENT ' 学生 id', `s_name` varchar(64) NOT NULL COMMENT '学生名称', `s_sex` tinyint(4) DEFAULT NULL COMMENT '学生性别', `s_age` int(11) DEFAULT NULL COMMENT '学生年龄', `s_birthday` date NOT NULL COMMENT '学生生日', `s_addr` varchar(512) DEFAULT NULL COMMENT '学生地址', `s_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', `s_status` int(11) DEFAULT NULL COMMENT '状态（0：禁用，1：可用）', PRIMARY KEY (`s_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生信息表';  学生班级关联表 学生班级关联表(记录学生参加了那些培训班) SQL：\nCREATE TABLE `student_join_class` ( `c_id` int(11) NOT NULL COMMENT '班级 id', `s_id` int(11) NOT NULL COMMENT '学生表', `cs_created` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '加入时间', PRIMARY KEY (`c_id`,`s_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生班级关联表';  对于以上 SQL 语句可以在 这里下载.\n数据类型说明 在我们的数据表创建语句里面，有个很重要的概念，也是数据库重要概念之一：数据类型（如：int(11)、timestamp、date等）。列的数据类型是描述了列可以接受保持的数据和如何存储数据。每种数据库管理系统的数据类型定义有略微不同，这里我们以 MySQL 数据类型为例说明，其他数据库的请查询相关文档。这里的数据类型大家不用全部记住，只要用到的时候查询参考文档就行。\n在 MySQL 中，有三种主要的类型：文本、数字、和日期/时间类型。\n文本类型（Text）    数据类型 描述     CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。   VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。注释：如果值的长度大于 255，则被转换为 TEXT 类型。   TINYTEXT 存放最大长度为 255 个字符的字符串。   TEXT 存放最大长度为 65,535 个字符的字符串。   BLOB 用于 BLOBs (Binary Large OBjects)。存放最多 65,535 字节的数据。   MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。   MEDIUMBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 16,777,215 字节的数据。   LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。   LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。   ENUM(x,y,z,etc.) 允许你输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。注释：这些值是按照你输入的顺序存储的。可以按照此格式输入可能的值：ENUM(\u0026lsquo;X\u0026rsquo;,\u0026lsquo;Y\u0026rsquo;,\u0026lsquo;Z\u0026rsquo;)   SET 与 ENUM 类似，SET 最多只能包含 64 个列表项，不过 SET 可存储一个以上的值。    数字类型（Number）    数据类型 描述     TINYINT(size) -128 到 127 常规。0 到 255 无符号*。在括号中规定最大位数。   SMALLINT(size) -32768 到 32767 常规。0 到 65535 无符号*。在括号中规定最大位数。   MEDIUMINT(size) -8388608 到 8388607 普通。0 到 16777215 无符号*。在括号中规定最大位数。   INT(size) -2147483648 到 2147483647 常规。0 到 4294967295 无符号*。在括号中规定最大位数。   BIGINT(size) -9223372036854775808 到 9223372036854775807 常规。0 到 18446744073709551615 无符号*。在括号中规定最大位数。   FLOAT(size,d) 带有浮动小数点的小数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。   DOUBLE(size,d) 带有浮动小数点的大数字。在括号中规定最大位数。在 d 参数中规定小数点右侧的最大位数。   DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。     这些整数类型拥有额外的选项 UNSIGNED。通常，整数可以是负数或正数。如果添加 UNSIGNED 属性，那么范围将从 0 开始，而不是某个负数。\n 日期/时间类型（Date）    数据类型 描述     DATE() 日期。格式：YYYY-MM-DD注释：支持的范围是从 \u0026lsquo;1000-01-01\u0026rsquo; 到 \u0026lsquo;9999-12-31\u0026rsquo;   DATETIME() *日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 \u0026lsquo;1000-01-01 00:00:00\u0026rsquo; 到 \u0026lsquo;9999-12-31 23:59:59\u0026rsquo;   TIMESTAMP() *时间戳。TIMESTAMP 值使用 Unix 纪元(\u0026lsquo;1970-01-01 00:00:00\u0026rsquo; UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS注释：支持的范围是从 \u0026lsquo;1970-01-01 00:00:01\u0026rsquo; UTC 到 \u0026lsquo;2038-01-09 03:14:07\u0026rsquo; UTC   TIME() 时间。格式：HH:MM:SS 注释：支持的范围是从 \u0026lsquo;-838:59:59\u0026rsquo; 到 \u0026lsquo;838:59:59\u0026rsquo;   YEAR() 2 位或 4 位格式的年。注释：4 位格式所允许的值：1901 到 2155。2 位格式所允许的值：70 到 69，表示从 1970 到 2069。     即便 DATETIME 和 TIMESTAMP 返回相同的格式，它们的工作方式很不同。在 INSERT 或 UPDATE 查询中，TIMESTAMP 自动把自身设置为当前的日期和时间。TIMESTAMP 也接受不同的格式，比如 YYYYMMDDHHMMSS、YYMMDDHHMMSS、YYYYMMDD 或 YYMMDD。\n 录入数据 数据库插入数据使用 insert 语句，我们使用到的所有数据插入 sql 到 这里下载。下载下来过后将里面所有 SQL 语句拷贝到 Navicat 客户端的查询窗口里面，如下图：\n点击执行，会得到一下结果：\n这时打开左边 Tables 里面 class 表 会看到如下图数据已经进去了\n里面涉及到的 insert 有一下如下两种格式\n语法格式一\nINSERT INTO [数据库名.]表名称[(列1,列2,...)] VALUES (值1, 值2,....)  实例：\nINSERT INTO student(s_id, s_name, s_sex, s_age, s_birthday, s_addr, s_created, s_status) VALUES (1, '王 1', 1, 16, '2007-04-18', '重庆', '2018-04-18 22:29:27', 1);  语法格式二（批量插入）\nINSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....) [,...]  实例：\nINSERT INTO `sql-learn`.`student_join_class`(`c_id`, `s_id`, `cs_created`) VALUES (1, 2, '2018-03-18 10:37:00'), (1, 3, '2018-02-18 09:41:41'), (1, 4, '2017-04-03 12:10:00'), (1, 5, '2018-01-28 14:30:00'), (1, 10, '2018-04-18 22:26:41');  详细语法格式参考 MySQL 官方文档。\nE-R 图（实体关系图） E-R 图是我个人感觉学习数据库必须掌握的一个技能，它是学习和分析数据库的一个有力工具，能让我们很快的对数据表之间关系形成一个全局观，对我们编写、分析 SQL 也是一个有力的工具。今天先简单讲解一下 E-R 图的基本内容，让大家可以看懂后面出现的 ER 图，后面会有专门的章节详解讲解 E-R 图。\nER图分为实体、属性、关系三个核心部分。实体是长方形体现，而属性则是椭圆形，关系为菱形。\nER图的实体（entity）即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象，用长方体来表示，每个实体都有自己的实体成员（entity member）或者说实体对象（entity instance），例如学生实体里包括张三、李四等，实体成员（entity member）/实体实例（entity instance） 不需要出现在ER图中。\nER图的属性（attribute）即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性，用椭圆形表示，属性分为唯一属性（ unique attribute）和非唯一属性，唯一属性指的是唯一可用来标识该实体实例或者成员的属性，用下划线表示，一般来讲实体都至少有一个唯一属性。\nER图的关系（relationship）用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系，关系用菱形来表示。\nER图中关联关系有三种：\n 1对1（1:1） ：1对1关系是指对于实体集A与实体集B，A中的每一个实体至多与B中一个实体有关系；反之，在实体集B中的每个实体至多与实体集A中一个实体有关系。 1对多（1:N） ：1对多关系是指实体集A与实体集B中至少有N(N\u0026gt;0)个实体有关系；并且实体集B中每一个实体至多与实体集A中一个实体有关系。 多对多（M:N） ：多对多关系是指实体集A中的每一个实体与实体集B中至少有M(M\u0026gt;0)个实体有关系，并且实体集B中的每一个实体与实体集A中的至少N（N\u0026gt;0）个实体有关系。  实例讲解：这个是上面创建的班级、学生 ER 图（注意：此图的部分画法不是标准的，不过不影响大家理解，也建议大家平时多多手画 ER 图，不是那么标准也没有关系，只要不影响理解就行） 班级、学生 是实体。一个学生一个参加多个(M)班级，一个班级可以包含多个(N)学生。 班级名称、学生性别 是属性。每个实体(班级或学生)都可以有多个属性。 参加 是关系，参见关系本身还包含有 参加时间 属性。学生加入班级的时候有 参加时间 。  有兴趣的可以自己手动画一下下面的 ER 图：有一个 班级 的实体，包含属性：课程名称、课程学分、授课老师。一个班级只授一门课程，但是班级的学生可以多次参加这么课程的考试。\n大家可能已经发现这里和我们实际建立的数据库表有所区别，这里表示的实体只有 2 个，但是我们时间建立的表却有 3 个。这里是我有意为之的，因为我发现很多初学者往往会有一个误区：误认为数据库的每个数据表都会对应 ER 图中的一个实体，其实这个是错误的。\n这是由于我们在实际建立数据库表的时候，会将 多对多（M:N） 关系拆分成 1对多（1:N） 关系，中间会多建立一个 关联表 （关联表也是物理数据表）。所以这里大家记住： ER图 转换成物理数据表的时候，可能会有所不同，但是他们的关系结构一定是一致的。我们有时还会把一个 实体 拆分成多个数据表进行存储，只要到家记住这个误区就行，具体为什么这个不属于这次内容范围，有兴趣的可以自行查找相关文档。\n总结  完成数据表创建和数据导入，知道 create 语句和 insert 语句基本结构和用户（可以看懂别人写的语句程度） 知道数据库基本类型，并且类型是描述列的 E-R 图基本知识：实体、属性、关系。可以看懂别人给出的 E-R 图，可以自己手绘简单 E-R 图，能够分析简单的数据表 E-R 图 "
},
{
	"uri": "https://blog.threeq.me/post/team-communication/agile-practice-record/",
	"title": "Scrum + 看板 开发实践：记录",
	"tags": ["Scrum", "看板", "敏捷开发", "团队管理"],
	"description": "",
	"content": "目前我们团队正实践 Scrum 框架 和 看板管理，这边文章正是对我们自己的实践的记录。这里的记录并不是按照时间顺序进行的，而是按照我自己的针对实践目标的先后进行的。目前我们团队还没有完全实现以上所有目标，对 Scrum 框架 理解和使用也还在初级阶段，所以有很多不足的地方，并且还有很多地方还在聊胜于无的状态，欢迎大家指正。\n我们现在正在进行的实践有：\n 统一团队对“完成”的定义 看板管理流程 每日晨会 迭代回顾会议 迭代计划会议 code review  我们团队刚开始的时候管理、开发混乱完全没有章法，大家各种打架、各种撕逼、各种甩锅。没有哪一次迭代不通宵，没有哪一次迭代不延期，没有哪一次迭代质量过关，没有哪一次上线不出问题，这种状态持续了很长一段时间。我感觉不行了，再这样下去还能做个啥产品，开始寻找各种解决方案并且不断反思团队遇到问题的本质，后来学习了敏捷，接触到 Scrum 和 看板，里面的方法论和实践操作不正是我们团队需要的吗？于是坚决决定团队开始敏捷实践，当然正所谓：软件开发没有银弹，实践证明 Scrum 和 看板并不能解决我们团队所有问题，但是确实可以让团队慢慢变好。\n\n团队目标一致：完成定义 虽然决定引入 Scrum 和 看板，但是从哪里开始呢？这么多团队问题，应该从哪个或哪几个问题开始引入解决呢？还是团队全面调整引入？这些问题是任何团队在开始引入的时候都会遇到的，但是我相信每个团队最后的答案都是不一样的。Scrum 框架建议团队全面调整和引入，这样团队提升效果最明显，但是这个需要团队和公司整体努力才能达到。通过沟通和分析我们当时的团队内外情况，全面引入条件还不成熟，所以只能逐步引入。通过分析我们团队自身情况，决定优先引入能最大化解决团队 撕逼和甩锅 情况的实践。这里我们选着了：\n 统一团队对“完成”的定义  在某次迭代完成过后，选在了一个下午时间，我们整个团队发起了《针对“完成”定义的讨论会议》，会议分成 5 个阶段：\n 说明会议原则   谦虚、尊重、信任原则\n会议期间尽量不被“打扰”，手机或者其他任何事情\n  收集大家对“完成”的想法：   使用便签箱收集大家的想法，每个参会成员使用便签写下自己的想法，然后读出来，最后将便签投入便签箱中，可以是新想法，也可以是对别人的补充。便签箱不断在成员之间循环传递，就会有越来越多的想法，直到大家所有想法都收集完了，一般在 3 轮后基本就完了。\n  整理大家想法   将搜集到的想法全部贴在版本上，记住是全部并且最好能大家一起做，同时将重复的便签贴在一起。然后移动便签，将意思相近的便签挨在一起，这样就形成了初略的分类。\n  讨论“完成”   对白板上的便签和初步形成的分类进行讨论和提炼，在过程中不断调整分类和精炼完成解释\n  总结得到最新“完成”定义   总结大家对分类和完成的讨论，结果形成 SMART 目标\n 在整个过程中需要保持谦虚、尊重、信任的原则，这样才能保持平等公平，让团队在微小的声音都被听到。最总我们得出了我们对于迭代完成的定义:\n团队信息透明：看板 为了做到团队信息透明，我们引入了看板方法，目标是尽量做到迭代过程中：所有人员对团队的任何信息“信息触手可及”。第一次引入看板我们没有进行全员参与，是由我直接给出了一个初始看板设计。\n 这里如果大家团队有时间建议还是全员参与看板设计，这样大家对流程理解会更清晰。如果做不到全员参与设计关系也不大，因为看板本身是跟着团队不断进化的，在你团队感觉他不合适的时候，再来改进也是可以的。比如我们团队现在看板是这样的（这个是在后来团队所有成员一起改进了 2 次后的）\n 及时有效沟通：每日晨会 每日例会我们称为晨会，因为我们是规定在早上进行。我们会选择一位主持人来主持晨会，晨会上每个人主要回答三个问题：\n 昨天做了什么？ 今天计划做什么？ 有没有遇到问题？  主持人也可以在这个3个主要问题之上加入自己的内容，主持人要引导大家回答出这3个问题。通过这样的方式让团队成员对团队做出承诺，并让团队监督你的承诺是否有被实现和你是否做出了过度承诺，同时也让团队人员思考团队其他人员是否需要帮助，我可以帮助哪些人。\n现在我们晨会形式也有所改变，主持人逐渐改变成一个迭代统一一个主持人，而不是原来的一天换一个主持人。并且主持的形式也可以有第二种选择\n 主持人对看板上每一个 未完成 的任务进行询问一下问题\n 任务现在什么状态？ 任务有无人在跟踪？ 有无阻力导致任务无法进行？ 完成任务还需要什么协助？   在每次晨会的时候，如果团队有发现需要改进的点（比如时间方法、沟通模式等），可以在会后来一个小的及时讨论，针对好的方案可以记录下来，留到回顾会议的时候详细讨论。\n迭代质量提升：迭代计划会议 迭代计划会议我们现在是由迭代学习会议和迭代评估会议 2 个会议组成。\n迭代学习会议 迭代backlog在我们开始一个迭代之前会由产品人员提前提取到迭代规划中（我们现在展现在TAPD中），并且和开发负责人确认好这个个迭代的开发范围。这个工作基本上是在上个迭代中后期完成的，产品人员在做的过程中需要和开发人员进行相关沟通，特别是开发负责人，所以这个时期的开发人员积极支持也是很关键的。在这个backlog里面，每个需求必须写明业务逻辑和验收标准，如果有必要还需要补充使用场景说明和功能的UI设计。\n迭代评估会议 迭代计划主要是围绕迭代backlog进行，我们对迭代计划会议做了不少调整。我们首先在迭代计划中进行业务学习会议，在这个过程中我们要求每个开发人员和测试人员对本次迭代范围内的业务进行宣讲，其他没有参与宣讲的人员需要对宣讲人员的疑问进行解答，特别是产品人员。在这个过程中让我们每个开发人员对业务目标达成共识，识别迭代中的重点和难点。同时这个过程可以对迭代范围提出质疑，如果有质疑，团队则必须在会议中决策出迭代范围。然后我们会在业务学习会议过后，立即召开难点设计会议，这个会议目前主要是开发人员参与，在会议上开发人员要针对迭代中的难点和重点进行详细设计，这个过程中如果有必要会协调产品人员一起参与（如范围调整，实现复杂度导致业务功能的变化等），得出详细设计中需要的必要结果（如：ER图，流程图，时序图等），如果有需要会后形成详细的设计说明书，一般情况下将会议中形成的白板图形成文档即可。最后所有人员对业务目标和重难点的设计达成一致后，开发人员进行估算会议，我们现在才用的形式是卡牌游戏对任务进行评估，目前通过卡牌游戏可以在一定程度上规避个人经验主义和单点故障问题。进过迭代计划会议团队对整个迭代的业务范围和迭代时间做出承诺，当然这个迭代计划会议持续的时间会随着迭代范围和难度有很大变化，目前我们团队最长的一次时间是5个工作日。\n迭代质量提升：code review 每日分享会我们之前叫做每日code review 或 集体代码解释（只有开发人员参与），但是由于近期产品人员和测试人员的参与，发现之前的名字已经不合适了，就改成了每日分享会。每日分享会紧跟在每日例会后进行，也像每日例会一样选定一个分享者（之前是2个）来完成一个30分钟的分享，并且对于开发人员做了特定规定只能做code review，目前规定这个主持人和每日例会主持人为同一人。并且在每日分享会过后，观察者（目前是项目负责人）有义务并且也是必须和当天主持人一起对当天他自己的表现做一个简单的评估和回顾，并做相关记录。这里不只是包括人员的技术，还包括人员的沟通、演讲等能力。\n目前这个会议也在调整，之前一个分享者很多时候不能达到 30 分钟，并且现在团队的情况让产品、开发和测试一起做分享已经不再合适。\n高效学习团队：迭代回顾会议 迭代会议必须准守 2 个基本原则：\n 无论我们发现了什么，考虑到当时的已知情况、个人的技术水平和能力、可用的资源，以及现实情况，我们理解并坚信：每个人对自己的工作都已全力以赴。 我们的目标是发现改进的机会，而不是去责备某个人  迭代回顾会议在整个迭代上线完成过后进行，迭代会议也和我们的晨会一样，选定一位主持人。主持人负责引导团队回顾在本次迭代中：\n 团队实践回顾（这里有很多方法，如：时间轴法，团队情绪表等） 团队做得好的地方； 有哪些地方我们可以做得更好； 我们可以做哪些实践来让我们改善。  在操作过程中我们会让团队所有人员对我们可以做得更好的事情，进行投票选举出团队认为最急迫、最重要的前面3个出来，我们进行讨论得出我们需要的实践。在得出实践的过程中，最重要的是团队可以看到实际可执行的实践，也就是这个实践最好有明确的结果和判断好坏的标准，能形成 SMART 目标最好。主持人在这个会议中，也可以加入自己的元素，但是需要遵守2个原则：\n 不能偏离主题内容； 必须是针对整个团队的内容。  以下是我们一次在迭代会议中进行的团队情绪表实践：\n在这里回顾会议中 Master 角色的人(观察者)员需要记录会议全过程，并且需要把会议记录同步到所有人，一下使我们使用的记录末班\n   记录项 内容     记录 记录这次会议的内容   历史问题跟踪 前一次会议总结内容，需要提醒住持人让团队评估上次的目标是否完成   总结 记录这次会议得出的结论 和 目标   观察 观察这次迭代回顾会议本省的情况，并在会后主持人和团队交流可以改进的地方    迭代回顾会议可以让我们及时发现团队需要改进的地方，也可以让我们发现团队里面需要继续维持的地方，让我们不断调整团队步伐和实践，让团队里面正确的、好的事情不断发生。\n未来 我们目前正在引入的实践\n TDD（测试驱动开发） 迭代演示 CI/CD 迭代跟踪者  同时也在不断调整我们现在的部分实践，如完成的定义、团队卓越（高效绩）的定义和目标。这就意味着团队会是一个持续变化和持续学习的过程，同时团队所在的外界因素也在不断的变化，这就需要团队的每个人都需要做到“学习学习再学习，实践实践再实践”，让团队不断的成长来适应各种变化。\n总结 管理方法论改变和进化的驱动力是项目利益的最大化，但是改变的本质是项目的沟通模式。沟通模式的改变可以是信息的展现形式、信息的载体、信息的传递方式、信息流转和反馈方式。这些改变都会对我们项目管理中其他方面产生直接影响，并且也直接影响到我们的管理模式。在项目进行过程中既需要一对一的精细沟通，也需要针对项目成功目标的宏观沟通。\n我们上面谈到了项目沟通中模式的改变，其实由于沟通模式的改变，会引发项目中其他管理方面的改变。\n在这个过程中团队负责人要保证团队是在正确的道路上，并且要让正确的事情不断的发生。及时识别团队的所处阶段，识别为团队引入变化的时机，及时引入变化；不断通过实践结果总结团队的失败模式和成功模式，促进成功模式不断出现，让团队在不断出现的失败模式中恢复。同时和团队一起不断提高自己，做好对自我掌控，定义好自己的成功，接受团队比自己更好的想法。\n推荐给大家几本团队和管理方法的书：\n 《Scrum 敏捷软件开发》 《Scrum 实战：故事、模型与成功秘诀》 《Scrum 精髓：敏捷转型指南》 《敏捷软件开发实践：估算与计划》 《敏捷教练：如何打造优秀的敏捷团队》 《如何构建敏捷项目管理团队》 《看板方法》 《看板实战》 《架构即未来》 "
},
{
	"uri": "https://blog.threeq.me/post/notes/hugo-site-search/",
	"title": "Hugo 网站增加搜索功能：Lunrjs 和 Algolia",
	"tags": ["Hugo"],
	"description": "本文是总结我自己在使用 Hugo 进行建站的时候给网站增加内容检索功能的结果。做这个功能的一个原因也是由于自己使用的 Even 主题没有带检索功能，所有只有自己上手撸一把。使用的检索方案包括 Lunrjs 和 Algolia，本文的处理方式可以同时支持 2 中方式，可以根据自己的情况自由选择或切换。",
	"content": "本文是总结我自己在使用 Hugo 进行建站的时候给网站增加内容检索功能的结果。做这个功能的一个原因也是由于自己使用的 Even 主题没有带检索功能，所有只有自己上手撸一把。使用的检索方案包括 Lunrjs 和 Algolia，本文的处理方式可以同时支持 2 中方式，可以根据自己的情况自由选择或切换。\n\n很多的 Hugo 主题是没有自带搜索功能的，但是们为了方便用户浏览和查找内容是需要在网站上提供搜索功能。大家可以查看 Hugo 官方推荐的搜索方案，我在使用的时候选择的是 Lunr 和 Algolial，以下是我的方案记录。\n生产网站 JSON 数据 由于 Lunr 和 Algolia 都同时对 JSON 数据格式的支持，所以这里我们选用网站的 JSON 数据格式。\n首先需要在 config.toml 里面增加配置\n[outputs] home = [ \u0026quot;HTML\u0026quot;, \u0026quot;RSS\u0026quot;, \u0026quot;JSON\u0026quot;]  其次需要在你的主题目录里面新建 themes/\u0026lt;your themme name\u0026gt;/layouts/index.json 文件，输入一下内容\n[{{ range $index, $page := .Site.Pages }} {{- if ne $page.Type \u0026quot;json\u0026quot; -}} {{- if and $index (gt $index 0) -}},{{- end }} { \u0026quot;uri\u0026quot;: \u0026quot;{{ $page.Permalink }}\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;{{ htmlEscape $page.Title}}\u0026quot;, \u0026quot;tags\u0026quot;: [{{ range $tindex, $tag := $page.Params.tags }}{{ if $tindex }}, {{ end }}\u0026quot;{{ $tag| htmlEscape }}\u0026quot;{{ end }}], \u0026quot;description\u0026quot;: \u0026quot;{{ htmlEscape .Description}}\u0026quot;, \u0026quot;content\u0026quot;: {{$page.Plain | jsonify}} } {{- end -}} {{- end -}}]  这个时候我们使用 hugo 生成网站的时候会多生成一个 public/index.json 的数据文件，我们的所有操作都围绕这个数据文件进行。\n搜索框添加  这里的搜索框 HTML、CSS 代码添加会根据你自己的主题会有所不同\n 首先为了支持不同的搜索解决方案，我们需要在 config.toml 里面增加如下配置，这样我们在使用的时候就可以自由的开关和切换搜索功能\n[params.Search] enable = true # true or false type = 'algolia' # lunr or algolia index = 'algolia_index' # algolia enabled appID = 'algolia_application_id' # algolia enabled searchKey = 'algolia_search_only_key' # algolia enabled  然后将一下代码加入到你主题的相应位置\n{{- if .Site.Params.Search.Enable }} \u0026lt;link href=\u0026quot;{{\u0026quot;lib/search/auto-complete.css\u0026quot; | relURL}}\u0026quot; rel=\u0026quot;stylesheet\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;search-wrapper\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;searchbox\u0026quot;\u0026gt; \u0026lt;div id='inputfield'\u0026gt; \u0026lt;i class='fa fa-search icon-search'\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;input id=\u0026quot;search-by\u0026quot; autocomplete='off' autocorrect='off' name='address' placeholder=\u0026quot;{{T \u0026quot;Search-placeholder\u0026quot;}}\u0026quot; spellcheck='false' type='text'\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{- if (eq .Site.Params.Search.type \u0026quot;lunr\u0026quot;) }} \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; {{ if .Site.IsMultiLingual }} var baseurl = \u0026quot;{{.Site.BaseURL}}{{.Site.LanguagePrefix}}\u0026quot;; {{ else }} var baseurl = \u0026quot;{{.Site.BaseURL}}\u0026quot;; {{ end }} \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;{{\u0026quot;lib/search/lunr/lunr.js\u0026quot; | relURL}}\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;{{\u0026quot;lib/search/lunr/auto-complete.js\u0026quot; | relURL}}\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;{{\u0026quot;lib/search/lunr/search.js\u0026quot; | relURL}}\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; {{- else }} \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var lagoliaIndex = \u0026quot;{{.Site.Params.Search.index}}\u0026quot; var lagoliaAppID = \u0026quot;{{.Site.Params.Search.appID}}\u0026quot; var lagoliaSearchKey = \u0026quot;{{.Site.Params.Search.searchKey}}\u0026quot; \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;//cdn.jsdelivr.net/autocomplete.js/0/autocomplete.jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026quot;//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot; src=\u0026quot;{{\u0026quot;lib/search/algolia/search-bar.js\u0026quot; | relURL}}\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; {{- end}} {{- end}}  这里用到的一些 JS文件 和 CSS 文件请到此地址下载：https://github.com/threeq/blog.threeq.me/tree/master/themes/even/static/lib/search，放到 static/lib/search 目录下。\n到这里我们为网站所加入的 Lunr 搜索功能就完成了，由于 Lunr 对于中文检索支持很差，我们需要手动处理一下我们的 public/index.josn，进行中文分词。同时这里需要使 Algolia 支持的话，也需要将我们的 JSON 数据提交到 Algolia 数据库中。\n搜索数据预处理 这里为了同时能将 public/index.josn 数据进行中文分词和提交到 Algolia 中，我这里自己写了一个 Python 脚本，方便处理和后续集成自动发布。在网站根目录新建文件 search_process.py，输入一下内容（你也可以到 这里下载）：\n# encoding=utf-8 \u0026quot;\u0026quot;\u0026quot; Hugo 网站使用 Lunr 和 Algolia 搜索方案数据处理 数据处理需要用到 algoliasearch 和 jieba 库，先安装 pip install algoliasearch pip install jieba \u0026quot;\u0026quot;\u0026quot; import sys reload(sys) sys.setdefaultencoding('utf-8') import os from algoliasearch import algoliasearch import jieba import json import argparse parser = argparse.ArgumentParser(description=\u0026quot;site search data process.\u0026quot;) parser.add_argument('--managehKey', '-k', required=False, help='algolia manage key') args = parser.parse_args() def sign_version(data): \u0026quot;\u0026quot;\u0026quot; 计算版本签名 \u0026quot;\u0026quot;\u0026quot; return hash(data['uri'] + '__' + data['title'] + '__' + data['content'])\tdef push_data(items): \u0026quot;\u0026quot;\u0026quot; 提交数据变更 \u0026quot;\u0026quot;\u0026quot; client = algoliasearch.Client(\u0026quot;NIACONWTKJ\u0026quot;, args.managehKey) index = client.init_index('blog.threeq.me') res = index.add_objects(items) print(\u0026quot;push count: %d. items:\\n%s\u0026quot; % (len(res), json.dumps(res, ensure_ascii=False, indent=2))) def delete_data(items): \u0026quot;\u0026quot;\u0026quot; 删除数据 \u0026quot;\u0026quot;\u0026quot; client = algoliasearch.Client(\u0026quot;NIACONWTKJ\u0026quot;, args.managehKey) index = client.init_index('blog.threeq.me') res = index.delete_objects(items) print(\u0026quot;delete count: %d. items:\\n%s\u0026quot; % (len(res), json.dumps(res, ensure_ascii=False, indent=2))) def algolia_push(): \u0026quot;\u0026quot;\u0026quot; algolia 数据提交 \u0026quot;\u0026quot;\u0026quot; # 得到已经 push 的数据 if os.path.isfile('public/index.push_version.json'): with open('public/index.push_version.json', 'r') as f: push_version_data = json.load(f) print(\u0026quot;read version push data\u0026quot;) else: push_version_data = dict() # 计算需要修改的数据 new_items = dict() add_items = [] del_items = [] for index in range(len(data_dict)): data = data_dict[index] data['objectID'] = data['uri'] new_items[(data['objectID'])] = True curr_version = sign_version(data) if push_version_data.has_key(data['objectID']): prev_version = push_version_data[data['objectID']] else: prev_version = None if curr_version != prev_version: add_items.append(data) push_version_data[data['objectID']] = curr_version for old_item in push_version_data.keys(): if not new_items.has_key(old_item): del_items.append(old_item) del push_version_data[old_item] # 需要删除数据 print(\u0026quot;Delete lagolia items count： %d.\u0026quot; % len(del_items)) if len(del_items) \u0026gt; 0: delete_data(del_items) # 处理需要 push 的对象 if len(add_items) \u0026gt; 0: push_data(add_items) else: print(\u0026quot;Don't content Add or Modify. skipped lagolia push.\u0026quot;) # 记录最新提交数据 with open('public/index.push_version.json', 'w') as f: json.dump(push_version_data,f, ensure_ascii=False) print(\u0026quot;write recored push data\u0026quot;) ###### # load public/index.json data ##### with open('public/index.json', 'r') as f: data_dict = json.load(f) print(\u0026quot;load public/index.json complete.\u0026quot;) ###### # algolia search process ###### if len(args.managehKey)\u0026gt;0: algolia_push() else: print(\u0026quot;skipped algolia push.\u0026quot;) ###### # lunr search process # use jieba lib ###### for index in range(len(data_dict)): data = data_dict[index] data['title_s'] = \u0026quot; \u0026quot;.join(jieba.cut_for_search(data['title'])) data['content_s'] = \u0026quot; \u0026quot;.join(jieba.cut_for_search(data['content'])) print(\u0026quot;word segmentation complete.\u0026quot;) with open('public/index.json', 'w') as f: json.dump(data_dict,f, ensure_ascii=False) print(\u0026quot;search process complete.\u0026quot;)  这是可以使用如下命令进行操作\n$ python search_process.py -h # 查看帮助文档 $ python search_process.py -k '' # 只支持 Lunr 处理，中文分词 $ python search_process.py -k \u0026lt;algolia manage key\u0026gt; # 同时进行 Lunr 和 Algolia 处理 $ python search_process.py --managehKey \u0026lt;algolia manage key\u0026gt; # 同时进行 Lunr 和 Algolia 处理  加入发布流程 最后我们还可以很方便和发布流程集成，比如下面的 deploy.sh 脚本\n#!/bin/bash echo -e \u0026quot;\\033[0;32mDeploying updates to GitHub...\\033[0m\u0026quot; fail() { echo \u0026quot;$1\u0026quot; exit 1 } # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` echo \u0026quot;search key $2\u0026quot; searchKey=\u0026quot;$2\u0026quot; python2 search_process.py -k \u0026quot;${searchKey}\u0026quot; || fail \u0026quot;site search data process fail. Error Code: [ $? ]\u0026quot; # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026quot;rebuilding site `date`\u0026quot; if [ $# -ge 1 ] then msg=\u0026quot;$1\u0026quot; fi git commit -m \u0026quot;$msg\u0026quot; # Push source and build repos. git push origin master # Come Back up to the Project Root cd ..  使用时如下：\n$./deploy.sh $./deploy.sh \u0026quot;this is message\u0026quot; \u0026lt;algolia manage key\u0026gt; $./deploy.sh '' \u0026lt;algolia manage key\u0026gt;  参考：\n hugo-lunr-zh "
},
{
	"uri": "https://blog.threeq.me/post/articles/noob-learn-sql/1-install-tools/",
	"title": "小白学 SQL 第一天：环境搭建",
	"tags": ["数据库", "SQL"],
	"description": "数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。同时会对数据库中的一些基础原理和设计工具进行介绍：ER 图、数据类型、范式等。适合小白用户（初学者和刚入门）。",
	"content": "《小白学 SQL》第一天\n本篇文章是《小白学 SQL》系列的开篇，也是学习的第一天。这个系列的文章是之前的学习笔记整理，同时再加入我自己在使用使用的一些使用经验，属于比较初级的知识整理，适合小白用户（初学者和刚入门）。\n数据库管理系统（DBMS）是 IT 从业者必备工具之一，你能在市面上看到的任何一个软件系统，在后面支持的一定有它的身影。 而这里面关系型数据库管理系统（RDBMS） 目前暂居了绝大部分，操作 RDBMS 的基础就是今天我们要开始学习的 SQL（结构化查询语言），所以我们有必要针对 SQL 进行系统全面的学习。\n作为学习的第一天我们将从搭建环境开始，今天实践涉及到的工具有：\n MySQL Docker ConEmuSetup（windows 版本命令行工具，Linux 和 Mac 不需要） Navicat  \n工具选择和说明 可能大家有些奇怪，为什么这里会选用 Docker，这个和我们 SQL 完全没有关系。这里 Docker 确实和我们学习的 SQL 完全没有关系，但就我个人使用来说 ：\n一、docker 作为基础环境，在上面安装 MySQL 服务比我们在自己裸机上装 MySQL 方便得多，并且不易且不怕出错；\n二、目前整个 IT 行业容器化正在如火如荼的进行，这个是未来不可逆转的趋势，Dcoker 正式这个大军里面的主力军；\n三、MySQL 安装跨平台化，使用 Docker 过后你在任何一个系统里面（Windows、Linux、Mac OS）安装 MySQL 操作都是完全一样的\n基于以上三点原因，所以这里我选择了 Docker 作为数据库运行基础环境。\n软件作用：\n   软件 作用说明     Docker 提供跨平台的软件运行基础环境   MySQL 最常用的 RDBMS 之一，作为我们学习 SQL 的数据库服务器   Navicat 一个被广泛使用的数据库客户端，作为我们主要的 SQL 编辑器   ConEmuSetup 一个 Window 命令行终端（Linux、Mac 使用自带的足以）    安装 Windows 安装 ConEmuSetup  到 ConEmuSetup 下载页面 现在对应软件版本 然后一路 “Next” 就好  Docker 安装 Docker 这里我们使用 Community Edition 版本，请到这里下载：下载地址。\n 对于 Windows 版和 Mac 版，下载下来后双击文件运行，剩下的几乎就是一路 \u0026ldquo;Next\u0026rdquo; 点下去就完了，最后双击桌面图标启动 Docker 服务，这里就不在说明了 对于 Linux 版本，由于不同发行版的需求不同，安装步骤略有不同，但是基本也和常用软件安装差不多，并且官方文档也和齐全这里就直接放官方的安装连接地址了（是英文的哟，如果有好的中文教程推荐，请留言我尽快放上来）: Ubuntu CentOS Fedora Debian  加速器配置：Windows、Mac 对于 Docker 安装完成过后，国内用户还有一步需要操作：指定 docker 加速器（原因不多说）。Windows 和 Mac 系统具体操作如下：\n 找到 Docker 运行系统托盘图片，右击打开菜单如下    点击 Preferences 菜单，打开设置界面如下   点击 Daemon 标签项，再 Rgistry mirrors 中输入镜像加速器网址 https://docker.mirrors.ustc.edu.cn。如下图  对于 Linux 系统配置需要修改相关配置文件，不同系统版本有所不同。\n加速器配置：Ubuntu 14.04、Debian 7 Wheezy 对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS中配置加速器地址：\nDOCKER_OPTS=\u0026quot;--registry-mirror=https://docker.mirrors.ustc.edu.cn\u0026quot;  重启 Docker 服务：\n$ sudo service docker restart  加速器配置：Ubuntu 16.04+、Debian 8+、CentOS 7 对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）\n{ \u0026quot;registry-mirrors\u0026quot;: [ \u0026quot;https://docker.mirrors.ustc.edu.cn\u0026quot; ] }   注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。\n 重启 Docker 服务：\n$ sudo systemctl daemon-reload $ sudo systemctl restart docker  检查加速器是否生效 打开终端（命令行工具）输入 docker info 命令，如果从结果中看到了如下内容，说明配置成功。\nRegistry Mirrors: https://docker.mirrors.ustc.edu.cn/  其他可用的加速服务有很多，这里列举几个方便大家查找：\n Docker 官方提供的中国 registry mirror DaoCloud 加速器 阿里云加速器  MySQL 服务安装 在安装完成 Docker 过后，MySQL 服务的安装就很简单了。在你的终端命令行里面输入如下命令启动 MySQL 服务：\n$ docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql  查看 MySQL 服务运行状态\n$ docker ps  这里不要被命令吓着了，Docker 本身的命令不少，包括以后的所有操作，我们总共用到 docker 命令就4、5个。这里先列出来，大家可以操作一下\n$ docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql # 创建一个名为 sql-learn MySQL 容器 $ docker ps # 查看容器运行状态 $ docker stop sql-learn # 停止 sql-learn 容器 $ docker rm sql-learn # 删除 sql-learn 容器，必须先停止  Navicat 安装 安装和 ConEmuSetup 类似\n 到 Navicat 下载页面 现在对应软件版本。推荐 Navicat Premium 然后一路 “Next” 就好  验证环境安装完成  双击桌面 “Navicat” 应用图标，打开 Navicat 软件  ​  点击 “链接” 增加到 sql-learn 的数据库链接。输入截图里面的内容，这里密码输入 toor ，点击 “Test Connection” 出现绿点没有错误表示成功，如下图   双击 “左边导航列表” 里的 sql-learn 得到如下结果   创建一个用于我们以后学习使用的数据库。点击 “New Query” 新建一个查询窗口  输入一下 SQL 语句\ncreate database `sql-learn` default charset=utf8mb4;  点击执行得到如下结果，表示成功\n支持我们的环境安装和验证全部结束。\n总结 我们学习一下几点：\n 如何安装 Docker 服务\n 如何在 Docker 里面启动 MySQL 服务器\n   docker run --name sql-learn -e MYSQL_ROOT_PASSWORD=toor -p3306:3306 -d mysql # 无 sql-learn 容器时 或 docker start sql-learn # 已有 sql-learn 容器时   我们在使用数据库系统的时候需要一个数据库服务器（这里是 MySQL），还需要一个数据库客户端（这里是 Navicat）\n 在链接 MySQL 服务器之前需要先启动 MySQL 服务器\n 在连接一个 MySQL 服务器是需要提供的基本信息有：服务器 IP、服务器端口、用户名、密码\n "
},
{
	"uri": "https://blog.threeq.me/post/db/mysql-slow-query-analyse/",
	"title": "mysql 查询优化：慢查询分析工具 pt-query-digest",
	"tags": ["Mysql", "数据库", "查询优化", "percona", "pt-query-digest"],
	"description": "",
	"content": "在系统刚上线的时候，经常会出现慢 SQL 的情况，并且有时候系统会在特定的时间点变慢。这个时候的慢 SQL 查询语句往往是大量出现，MySQL 的慢查询日志文件也会比较大。这个时候我们往往需要从哪些查询最多、耗时最长的 sql 开始优化，以提升我们的处理效益。这个时候就需要我们能对慢日志进行统计分析，在上 M ，甚至 几十 M 的日志文件里面使用手工的方式明显是不可能的，这个时候就需要有专门的统计分析工具来帮我们做统计、分析哪些慢查询日志。percona-toolkit 就是一个提供统计和分析的工具集，这里重点介绍里面的 pt-query-digest 工具。\n\npercona-toolkit 安装 percona-toolkit 首页 文档 下载地址\nmac 安装 可以使用 brew 直接安装\nbrew install percona-toolkit  Linux 安装 详细信息参考 官方安装文档\n源码安装 # 下载源码 wget https://www.percona.com/downloads/percona-toolkit/3.0.8/source/tarball/percona-toolkit-3.0.8.tar.gz # 解压 tar xf percona-toolkit-3.0.8.tar.gz #进入目录安装 cd percona-toolkit-3.0.8 #开始编译安装 perl Makefile.PL make make install #安装完了就有命令了 ll /usr/local/bin/pt-*  pt-query-digest 基本使用 在使用 pt-query-digest 前需要有 MySQL 慢查询日志文件，这里为了大家方便实验提供了一份 MySQL 慢查询日实验数据 供大家下载测试（slow-sql-test.sql.zip 点击我下载，里面包含2018.04.01～2018.04.04 和 2018.04.06 的日志数据）。\n 查看使用帮助  \u0026gt; pt-query-digest --help   默认分析参数  \u0026gt; pt-query-digest slow-sql-test.sql   总体概要信息：\n   信息字段 说明     Exec Time 执行时间   Lock Time 锁时间   Row sent 发送行大小   Row examine 检查行大小   Query size 查询大小   Rank SQL 编号   Query ID 查询 id   Response time sql 总共执行时间 和 时间比例   Calls sql 执行次数   R/Call sql 平均每次执行时间   V/M    Item sql 类型和涉及到的表    单个 SQL 信息：\n ​ 分析结果说明：\n 分析最近一段时间内的慢查询  \u0026gt; pt-query-digest --since=12h slow-sql-test.sql # 最近 12 小时的慢查询   分析指定时间段内的慢查询  \u0026gt; pt-query-digest slow-sql-test.sql --since '2018-04-01 09:30:00' --until '2018-04-02 10:00:00'   分析还有指定特征的慢查询 SQL  \u0026gt; pt-query-digest --filter '$event-\u0026gt;{fingerprint} =~ m/^select/i' slow-sql-test.sql   分析针对某个用户的慢查询  \u0026gt; pt-query-digest --filter '($event-\u0026gt;{member} || \u0026quot;\u0026quot;) =~ m/^root/i' slow-sql-test.sql   ​  pt-query-digest进阶使用 有时候我们会遇到针对慢 SQL 进行长期的跟踪分析，这个时候我们就需要将我们的每次的分析结果进行汇总、对比分析。同时对于部分环境我们是不能直接得到慢 SQL 日志的，这个时候我们可以通过抓取 TCP 协议数据或 binlog 进行分析\n 将分析结果保存到数据库  \u0026gt; pt-query-digest --user=root –password=abc123 --review h=localhost,D=test,t=query_review--create-review-table slow-sql-test.sql   通过抓取 TCP 协议数据分析  \u0026gt; tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 \u0026gt; mysql.tcp.txt \u0026gt; pt-query-digest --type tcpdump mysql.tcp.txt\u0026gt; slow_report9.log   通过 binlog 日志分析  \u0026gt; mysqlbinlog mysql-bin.000093 \u0026gt; mysql-bin000093.sql \u0026gt; pt-query-digest --type=binlog mysql-bin000093.sql \u0026gt; slow_report10.log  单条 SQL 优化基本分析 通过上面的方法就可以找出系统里面所有的慢 SQL 语句了，并且在分析报告里面会排好序，剩下的就是我们针对每条 SQL 语句的分析调优工作了。针对 SQL 的具体优化方式内容很多，建议大家系统的学习，后面我也会写一些我常用的方法。这里说一下单条 SQL 的基础分析方法，好让大家有个开头。\n 查看 SQL 执行计划  EXPLAIN select ep_name as '企业名称', count(*) as '企业人数', FROM_UNIXTIME(ep_created/1000, GET_FORMAT(DATE,'ISO')) as '注册时间' from uc_member u left join uc_enterprise e on u.ep_id=e.ep_id where ep_domain='yq.vchangyi.com' and mem_status\u0026lt;3 group by u.ep_id order by 企业人数 desc;\t 对于上面每一列的的意义这里不再详细介绍，有兴趣的同学可以查看 MySQL 文档，或者关注我后续的文章，会有专门介绍。\n 查询 SQL 执行信息  查看 MySQL 语句执行信息需要首先开启 profiling 选线\nset profiling = 1;  然后执行完 SQL 过后使用 show profiles; 语句查看执行 SQL 的记录id\nselect ep_name as '企业名称', count(*) as '企业人数', FROM_UNIXTIME(ep_created/1000, GET_FORMAT(DATE,'ISO')) as '注册时间' from uc_member u left join uc_enterprise e on u.ep_id=e.ep_id where ep_domain='yq.vchangyi.com' and mem_status\u0026lt;3 group by u.ep_id order by 企业人数 desc; show profiles;  使用 show profile 查看 SQL 的执行信息\nshow profile ALL for query 3;  语法格式：\nshow profile [type] for query \u0026lt;query_id\u0026gt;;  如果没有指定 FOR QUERY 则显示最近一条查询的详细信息。type 是可选的，有以下几个选项：\n ALL 显示所有性能信息 BLOCK IO 显示块IO操作的次数 CONTEXT SWITCHES 显示上下文切换次数，不管是主动还是被动 CPU 显示用户CPU时间、系统CPU时间 IPC 显示发送和接收的消息数量 MEMORY [暂未实现] PAGE FAULTS 显示页错误数量 SOURCE 显示源码中的函数名称与位置 SWAPS 显示SWAP的次数 "
},
{
	"uri": "https://blog.threeq.me/post/db/mysql-sql-index-analyse-tool/",
	"title": "mysql 查询优化：索引优化",
	"tags": ["Mysql", "数据库", "查询优化"],
	"description": "",
	"content": "我们在产品中使用 MySQL 数据库的时候，肯定会用到索引的，或是在前期建立一些初始索引，或是在后期 SQL 优化的时候根据系统运行状态逐渐增加索引。不论是以什么方式建立的索引，他们都会影响我们对数据库做的操作，并且是对我们所有的数据操作都有影响，包括 增加、删除、修改、查询、统计 操作。这时如果线上有部分索引在系统升级已经失效了，我们怎么知道，怎么及时的排查和删除，需要我们持续的跟踪和分析。今天我就介绍几款针对线上数据库索引的分析工具。\n pt-index-usage userstat check-unused-keys  \n1. pt-index-usage pt-index-usage 从日志里面读取查询，并且分析它们是如何使用索引的。它需要 MySQL 的慢查询日志，在实际分析中我们可以讲 MySQL 的慢查询参数设置为 0 ，这样就可以得到所有的执行 SQL。\npt-index-uage 的安装请参考 [mysql 查询优化：慢查询分析工具 pt-query-digest]\n使用：\n\u0026gt; pt-index-usage [OPTIONS] [FILES]  分析 slow.log 的所有查询语句，并打印报告\n\u0026gt; pt-index-usage /path/to/slow.log --host localhost  不打印报告，同时把分析后的结果存入 percona 数据库\n\u0026gt; pt-index-usage slow.log --no-report --save-results-database percona  详情参考 pt-index-uage 官方文档 和 使用手册 [pt-index-uage --help]\n2. userstat MySQL 设置：\nmysql\u0026gt; SET GLOBAL userstat=ON; mysql\u0026gt; SET GLOBAL `thread_statistics`=1; mysql\u0026gt; SHOW GLOBAL VARIABLES LIKE \u0026quot;userstat\u0026quot;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | userstat | ON | +---------------+-------+ 1 row in set (0.00 sec)  查询客户端连接信息\nmysql\u0026gt; SELECT * FROM INFORMATION_SCHEMA.CLIENT_STATISTICS\\G *************************** 1. row *************************** CLIENT: 10.1.12.30 TOTAL_CONNECTIONS: 20 CONCURRENT_CONNECTIONS: 0 CONNECTED_TIME: 0 BUSY_TIME: 93 CPU_TIME: 48 BYTES_RECEIVED: 5031 BYTES_SENT: 276926 BINLOG_BYTES_WRITTEN: 217 ROWS_FETCHED: 81 ROWS_UPDATED: 0 TABLE_ROWS_READ: 52836023 SELECT_COMMANDS: 26 UPDATE_COMMANDS: 1 OTHER_COMMANDS: 145 COMMIT_TRANSACTIONS: 1 ROLLBACK_TRANSACTIONS: 0 DENIED_CONNECTIONS: 0 LOST_CONNECTIONS: 0 ACCESS_DENIED: 0 EMPTY_QUERIES: 0 TOTAL_SSL_CONNECTIONS: 0  查询索引使用信息：\nmysql\u0026gt; SELECT * FROM INFORMATION_SCHEMA.INDEX_STATISTICS WHERE TABLE_NAME='tables_priv'; +--------------+-----------------------+--------------------+-----------+ | TABLE_SCHEMA | TABLE_NAME | INDEX_NAME | ROWS_READ | +--------------+-----------------------+--------------------+-----------+ | mysql | tables_priv | PRIMARY | 2 | +--------------+-----------------------+--------------------+-----------+  查询表的使用信息：\nmysql\u0026gt; SELECT * FROM INFORMATION_SCHEMA.TABLE_STATISTICS WHERE TABLE_NAME=``tables_priv``; +--------------+-------------------------------+-----------+--------------+------------------------+ | TABLE_SCHEMA | TABLE_NAME | ROWS_READ | ROWS_CHANGED | ROWS_CHANGED_X_INDEXES | +--------------+-------------------------------+-----------+--------------+------------------------+ | mysql | tables_priv | 2 | 0 | 0 | +--------------+-------------------------------+-----------+--------------+------------------------+  具体详情请参考文档：https://www.percona.com/doc/percona-server/5.7/diagnostics/user_stats.html\n3. check-unused-keys check-unused-keys 是 Ryan Lowe 编写的基于 userstat 的一个 perl 脚本。能够比较方便输出需要删除的索引。\n下载地址：https://code.google.com/archive/p/check-unused-keys/downloads / 备份地址\nMySQL 设置：\nmysql\u0026gt; SET GLOBAL userstat=ON; mysql\u0026gt; SET GLOBAL `thread_statistics`=1; mysql\u0026gt; SHOW GLOBAL VARIABLES LIKE \u0026quot;userstat\u0026quot;; +---------------+-------+ | Variable_name | Value | +---------------+-------+ | userstat | ON | +---------------+-------+ 1 row in set (0.00 sec)  语法：\n\u0026gt; ./check-unused-keys --help  使用：\n./check-unused-keys --host=127.0.0.1 --username=root --password=toor --port=3306 --create-alter  参考：\nhttps://www.percona.com/blog/2009/06/26/check-unused-keys-a-tool-to-interact-with-index_statistics/\nhttps://www.percona.com/blog/2008/09/12/googles-user_statistics-v2-port-and-changes/\nhttps://code.google.com/archive/p/check-unused-keys/\nhttps://www.percona.com/blog/2012/12/05/quickly-finding-unused-indexes-and-estimating-their-size/\nhttps://yq.aliyun.com/articles/308518\n"
},
{
	"uri": "https://blog.threeq.me/post/git-branch-flow/",
	"title": "Git 代码库分之管理",
	"tags": ["git"],
	"description": "",
	"content": "代码版本库使用git管理，以下是git版本使用规范\n流程图说明 \n分支使用说明    分支名称 名字 说明 实例     master 线上分支 不用于开发，使用tag功能标记版本。只能由beta和hotfix合并，合并同时打上发布版本tag v1.0.2   beta 灰度分支组 灰度分之只能由test合并master产生，在测试通过后进入灰度阶段产生；灰度通过后合并进入master beta/sign   test(release) 测试分支组 只能用于测试和修改bug，只能由由master合并进feature产生。对于测试通过的test，使用merge合并方式合并master产生beta分之；合并后的release需要删除 test/sign; release/active   feature 功能分支组 从最新master检出用于开发一个新功能，一旦完成开发，合并master进入下一个test，删除本次feature分支；负责开发中多开发者代码同步使用 feature/news; feature/vote   topic 本地开发分支组 开发人员基于feature/release/hotfix检出自己本地开发(或修改bug)分支，在开发(或修改bug)中使用rebase合并方式和feature/release/hotfix进行同步。原则上一个feature/release/hotfix分支对应一个topic分支，开发完成的feature/release/hotfix删除对应的topic分支 topic/feature-news-wlp; topic/release-new-wlp; topic/hotfix-news-wlp   hotfix 修补分支组 对于线上紧急bug修改，产生一个hotfix分支，只能由master上的tag标签签出。修改完成的hotfix合并回master，并且必须删除 hotfix/v1.0.2     注意： 1. 个人开发分支除特殊情况，不允许提交到远程服务器中。\n 代码提交/合并说明 这个是开发人在日常开发中使用最多的操作。\n获取代码库 $ git clone \u0026lt;版本库地址\u0026gt; $ cd \u0026lt;代码目录\u0026gt; $ git fetch origin feature/\u0026lt;功能分支\u0026gt;:feature/\u0026lt;功能分支\u0026gt;  建立自己的本地开发分支 $ git checkout feature/\u0026lt;功能分支\u0026gt; $ git checkout -b topic/\u0026lt;功能分支\u0026gt;-\u0026lt;你的标识\u0026gt;  提交修改 $ git status $ git add . $ git commit -am '修改描述'  发布你的修改 $ git fetch origin feature/\u0026lt;功能分支\u0026gt;:feature/\u0026lt;功能分支\u0026gt; $ git rebase feature/\u0026lt;功能分支\u0026gt; # 这里可能会产生合并操作 $ git push origin topic/\u0026lt;功能分支\u0026gt;-\u0026lt;你的标识\u0026gt;:feature/\u0026lt;功能分支\u0026gt;  代码发布说明 发布代码是针对功能发布而定的，发布又分为测试发布和上线发布。对于发布操作，必须是先到测试环境(test)，再从测试环境(test)到灰度环境(beta)，最后从灰度环境(beta)到生产环境(master)，对于线上每次发布都必须有标签记录，可以回退。 原则上从beta到master只会产生 fast-forward 类型操作。以下所有操作都在自己的开发分支中完成。\n发布到测试环境 # 合并feature分支 $ git fetch origin master:master $ git fetch origin feature/\u0026lt;功能分支\u0026gt;:feature/\u0026lt;功能分支\u0026gt; $ git checkout feature/\u0026lt;功能分支\u0026gt; $ git merge master ~~解决冲突~~ # 生产test分支 $ git checkout -b test/\u0026lt;功能分支\u0026gt; $ git push origin test/\u0026lt;功能分支\u0026gt;: test/\u0026lt;功能分支\u0026gt; # 清理feature分支 $ git push origin :feature/\u0026lt;功能分支\u0026gt; $ git branch -D feature/\u0026lt;功能分支\u0026gt;  发布到灰度环境 # 合并master到测试 $ git fetch origin test/\u0026lt;功能分支\u0026gt;:test/\u0026lt;功能分支\u0026gt; $ git fetch origin master:master $ git checkout test/\u0026lt;功能分支\u0026gt; $ git merge master ~~解决冲突~~ # 生成beta分支 $ git checkout -b beta/\u0026lt;功能分支\u0026gt; $ git push origin beta/\u0026lt;功能分支\u0026gt;:beta/\u0026lt;功能名称\u0026gt; # 清理 test $ git push origin :test/\u0026lt;版本\u0026gt; $ git branch -D test/\u0026lt;版本\u0026gt;  发布到生产环境 # 合并到master $ git fetch origin beta/\u0026lt;版本\u0026gt;:beta/\u0026lt;版本\u0026gt; $ git fetch origin master:master $ git checkout master $ git merge beta/\u0026lt;版本\u0026gt; $ git tag -a \u0026lt;发布版本号\u0026gt; -m \u0026quot;发布功能描述\u0026quot; $ git push origin --tags $ git push origin master:master # 清理 beta $ git push origin :beta/\u0026lt;版本\u0026gt; $ git branch -D beta/\u0026lt;版本\u0026gt;  修改生产环境bug # 创建补丁版本，进行修改 $ git fetch origin --tag $ git checkout -b hotfix/\u0026lt;版本号\u0026gt; \u0026lt;版本号\u0026gt; # 修改完成发布 # 1. 合并到master $ git fetch origin master:master $ git checkout master $ git merge hotfix/\u0026lt;版本号\u0026gt; $ git tag -a \u0026lt;发布版本号\u0026gt; -m \u0026quot;发布功能描述\u0026quot; $ git push origin --tag $ git push origin master:master # 清理 hotfix $ git push origin :hotfix/\u0026lt;版本号\u0026gt; $ git branch -D hotfix/\u0026lt;版本号\u0026gt; "
},
{
	"uri": "https://blog.threeq.me/post/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/gtd-flow/",
	"title": "让网络更好为我们服务",
	"tags": ["GTD", "时间管理"],
	"description": "",
	"content": "你每天早上一醒来有没有立即想拿起手机赶紧看一下（facebook、twitter、微信），无论里面有没有信息都要打开一下才安心？并且在上班之前还要想办法挤出时间看一下各大新闻网站，查收邮件在各种邮件信息中找出今天需要处理的事情。并且在工作的时候，一出现一个消息弹框马上点击进去看，害怕自己遗漏哪怕一次消息。\n这些在一个信息爆炸的时代是正常的，被称为信息饥渴。其实出现这个情况是由于我们没有很好获取信息方式和管理信息方法。这篇文章就介绍如何更好的利用网络工具来为我们管理信息。 这里我先把这些网络工具分为：\n 信息产生工具\ngithub、facebook、twitter、rss博客、linkedin、微信服务号  信息收集转换器\nzapier、ifttt、smooch、feedly、pocket、buffer  时间/任务/信息管理工具（GTD）\nEvernote、todoist、kanbanflow、自己博客、bearychat、slack    作为一个有态度的程序员肯定是从我最爱的github开始了，我们在github上面肯定少不了有自己的开源代码，当有人给我们提交一个issue、发起一个pull request等信息时我们\ngithub --\u0026gt; kanbanflow  我把看书作为一项任务来对待，在我看完一本书的时候自动在 Evernote 里面创建一个书评的待完成的笔记，并在 todolist 中建立一个任务放入到待计划中\nkanbanflow --\u0026gt; Evernote --\u0026gt; kanbanflow  对于facebook、twitter等社交工具中有新信息的时候，全部集中到 slack\nfacebook/twitter --\u0026gt; slack  对于各种新闻信息进行快速过滤，对于感兴趣的放入到pocket,同时建立阅读任务；后面在整理pocket的时候需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。\npocket --\u0026gt; todoist pocket --\u0026gt; Evernote --\u0026gt; kanbanflow  对于自己关注的新闻、博客、论坛等信息，订阅rss信息到feedly，如果有信息时自在todolist建立阅读任务；在阅读过程中需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。\nrss/feedly --\u0026gt; kanbanflow rss/feedly --\u0026gt; Evernote --\u0026gt; kanbanflow  对于自己博客更新，会自动同步到twitter、facebook等账户中，并且保存到 Evernote\n自己博客 --\u0026gt; facebook --\u0026gt; twitter --\u0026gt; Evernote  在工作中我们会用到 gitlab、jenkins 等工具，我把这些信息全都收集到 bearychat 中\ngitlab/jenkins --\u0026gt; bearychat  "
},
{
	"uri": "https://blog.threeq.me/post/ci-cd-tool/",
	"title": "项目持续集成工具",
	"tags": ["jenkins", "gerrit", "gitlab", "redmine", "CI/CD"],
	"description": "",
	"content": " 每个项目管理中都有自己的管理工具集合，这里分享一下我用过的工具集合，这里面有些工具的实践时间可能并不是很长时间，列在这里意味这下一个阶段的实践计划。同时也分享一下我自己在选择工具集合的时候考虑的点(关于每类工具如何比较它们最后做出选择我后面会慢慢补上)。在这里不会详细介绍每种工具的安装、连接和使用过程，如果后面有时间我会专门写这些工具的安装、配置和配合使用。 O 首先列出我认为在项目管理中比较重要的工具，同时这些也是我在实践中用得比较多的一套工具集：\n   工具 职责 描述     git  网上有个在线教程很好《pro git》中文版   gerrit 代码库服务器工具/代码审核工具 基于git的在线代码审查工具，围绕它建立代码审核平台和流程   gitlab 版本库展示平台 gitlab这里只作为代码展示平台和最终的发布代码库   jenkins 自动化持续集成平台 jenkins自动测试/集成/发布，围绕它建立可持续集成平台   redmine 任务管理平台/缺陷跟踪平台    sonar 代码质量报告聚合工具 围绕它搭建一个代码质量监控平台    关于上面工具的安装过程不做描述，不过个人建议可以把每个服务都做成docker容器，这样如果需要再次搭建环境就方便了。\n下面对这套工具集合的流程介绍 工具流程 整理流程 {% plantuml %} ACTOR 开发人员 control gerrit control jenkins ACTOR 审核人员 database sonar database gitlab control redmine\n开发人员-\u0026gt;gerrit: 提交代码审核 gerrit-\u0026gt;jenkins: 触发持续集成测试 jenkins-\u0026gt;jenkins: 执行集成测试 jenkins-\u0026gt;sonar: 收集代码质量报告 gerrit\u0026lt;--jenkins: 返回测试结果 gerrit-\u0026gt;审核人员: 通知人工审核 gerrit\u0026lt;--审核人员: 人工审核反馈 gerrit-\u0026gt;gerrit: 验证代码审核结果/代码合并 gerrit-\u0026gt;gitlab: 合并的代码提交到gitlab gitlab-\u0026gt;redmine: 自动更新redmine的缺陷 开发人员\u0026lt;--gerrit: 通知开发人员审核结果  {% endplantuml %}\ngerrit代码审查流程 选择工具的思考 首先要明确一点：不论多么智能的工具，都是为我们程序员服务的，只是为我们提供一个更好工作的环境，让我们可以更愉快的coding。所以在选择一个项目的基础平台环境时，一定要考虑到项目团队的人员情况。\n* 平台工具集可以引导团队成员不断提高自己 * 方便团队任务分配、跟踪 * 团队成员可以随时随地，在自己想看代码的时候方便得到 * 代码质量可视化、可跟踪 * 一切和编码不相关的内容，尽量自动化 * 可持续集成 * 方便文档的编写  同时在项目中哪些方面是需要引入工具的呢？这个答案在每一个团队都会不一样，这里写一些我自己的想法：\n* 代码管理环境 * 任务/缺陷管理环境 * 自动化测试/持续集成环境 * 代码质量监控环境 * 文档编辑环境 * 协作/沟通环境 * 集成开发环境  下面我会对这几方面的工具进行一个简单的考量，说明我自己在这方面的考虑点，但是不会做非常细致的比较，原因有2个： 1. 有很多工具我自己也没有亲身使用过； 2. 每个人或团队对工具的思考都会不同，同时网上有很多的关于它们比拼的文章，最重要的是自己的使用感受和思考\n代码管理环境 代码版本库的管理我相信这个大家都会用工具来管理（如果你还没有使用版本库管理或者还在自己手动管理，我只能呵呵。。。了）。对于不同的版本控制需求，我们需要不同的管理策略，当然这个和团队的协作方式有很大的关系。同时现在的代码版本管理工具也很多：VSS、SVN、GIT、CVS(完全可以用SVN代替)、ClearCase等。那对于代码管理环境需要考虑那些因素： * 安全性(如果你是开源的忠诚粉丝，可以完全忽略这个) * 易用性 * 总体成本 * 技术支持 * 周边产品（衍生工具/其他产品集成工具） * 是否离线操作（这个这里作为考虑条件是因为网络有时确实是一个坑,不解释） * 支持代码审查\n这里我主要比较了git和svn。VSS支持平台有限（感觉只有win）果断干掉（我不好意思让兄弟们把mac换成win吧，呵呵。。。）；ClearCase看到网上介绍感觉功能很强大的，但是看了一下价格果断干掉（原因不要深究。。。）。\nGIT git这个现在很火，用的人很多，包括我自己现在也是完全使用这个。\n 安全性\n 使用这个可以说你的代码都没有什么安全性了(一些专业的git服务器除外)，他对安全性的控制你完全可以忽略。这个也没有办法，谁让他的作者就是开源狂热份子呢 由于他们分布式管理方式，任何一个开发人员本地都有一份完整的代码库克隆，所以任何一个人员或服务器损坏了，也不会对开发有任何影响，同时找回来也是非常方便的，基本不用成本  易用性\n 这个可能就要因人而已了，如果之前对命令行的模式比较熟悉，那这个基本上就没有任何学习曲线了，只是自己的命令集合里面多了一个叫git的命令而已；但是对于之前比较习惯图形界面的童鞋就有学习成本了(实际上从我和兄弟们的使用情况来看，其实不是学习git命令花费时间，而是要让自己习惯命令行工作方式)，不过成本其实是很低的，比如我们团队的兄弟们在一周之内都实用的很溜了(这里给兄弟们赞一个)。 后面就是关于分支的管理、合并、冲突的解决等协作方面的问题，这个从我个人的使用来看问题基本不大，只要把网上的那本《pro git》跟着操作完成，你能需要遇到的问题基本OK了。 最后就是规划团队的代码管理流程了，让代码版本管理在团队不断扩大、项目越来越多的过程中不至于失控 还有一个不经常会用到的操作，就是迁移代码库。这个对于git来说就太容易了，就是2、3个命令的事  总体成本\n 因为是开源的，所以从软件费用来说是0成本 剩下的就是我们自己搭建服务器的成本了，如果感觉自己服务器也不想出，那就找网上的云服务就好了，所以这个成本也是相对叫低的了。这里列举几个我用过的：github、coding.net、Git@OSC具体谁更适合你，都去用一边就好了 最后就是团队的学习成本了，从我在易用性里面介绍，我感觉一个团队学习的成本不会超过1周 同时git的周边产品大多都是免费的或者提供免费版本，所以他的配套产品成本其实很低  技术支持\n 开源的东西就只有社区，这个不要想太多，任何东西都需要你自己去发现，当然如果你选择三方平台，他们会有服务器平台部分支持的  周边产品\n 现在基于git的衍生产品太多了，上面所列举的都是，随便baidu和google都是一大把 其他平台对于git的支持我个人感觉很不错，不论是IDE、持续集成环境、bug跟踪系统都有响应的插件支持git版本库  离线操作\n 这个离线操作也是我之前考虑使用它的一个重要原因，每个人只需要在本地编写好、提交好你的代码，然后找一个网络环境的地方，把代码同步一下就好了   SVN(有这个没有必要CVS了) svn现在用的团队很多，是一种集中式版本管理工具，我之前也是用这个很长一段时间。\n 安全性\n svn的目标就管理团队代码，所以可以很精确的控制每个人远能访问的权限，目录分支等 由于是集中式管理，所以svn服务器千万不能挂掉，如果挂了大家都不能工作了，同时找回代码也是一件费劲的事情  易用性\n svn提供图形化客户端(非linux系统)，所以大家看一下就可以使用了 svn分支、合并、冲突解决都是图形化操作，大家用起来问题不大 大家都习惯了图形操作的方式，所以学习很快 但是在团队不断变大、项目越来越多的时候，对svn的管理就需要有点技巧了  总体成本\n svn软件本身是免费的，所以软件本身费用是0成本 如果自己搭建服务器，那就需要服务器成本了，不过你可以选择网上云服务，如google代码库（国内的就别想了）、svn china、RiouxSVN等。因为我自己以前只使用过google，所以对这些云服务需要自己去体验了 团队学习我们忽略吧 svn的目标毕竟是代替老牌的cvs，周边产品的支持那是杠杠的，其他和软件开发相关的环境和平台，肯定都是支持svn的，如果你选择的基础环境工具中还有不支持svn的，那肯定是你出问题了。但是很多优秀svn的周边产品都是需要收费的  技术支持\n 社区绝对是一个神奇的存在，你遇到的问题，肯定有人解决了，至少我当时是这样的 同时可以买专业的svn产品，这样可以得到专业团队的技术支持，当然这个成本肯定是有的  周边产品\n 刚刚就说了它的目标是代替老牌的cvs，所以周边产品自然不用说，只是成本的问题  离线操作\n 这个是我当时最郁闷的一点，如果你没有网络，你就不能提交了。很不好做历史记录管理   git服务器 这里只介绍git版本库管理中其他的思考。只介绍git是因为我现在使用的git，其实是之前在使用svn的时候没有考虑那么多，自己也没有好好去研究svn的一套体系。\n要使用git作为团队代码管理，就需要git服务器（当然对那些单兵作战的兄弟们，最好也有一个git服务器，这样至少可以做到你在哪里都可以作战）。这里git服务器的选择就有两种方式了：1、使用三方托管平台；2、自己搭建git服务器。这里主要讨论第2种方式，自家搭建服务器。\ngit是基于ssh的，所以如果不要复杂功能只需要一个git-shell就可以是服务器了，不过我们可不想重复找轮子，别人已经弄好的工具，我们为什么不直接用呢！！！Gitosis、 Gitolite（这个东西的权限管理很不错）等。如果要高级功能的(如：web访问)，那gitlab和gerrit（下载需要翻墙）将是不二之选。这里我同时选用了2者，它们的不同在于gerrit是一个更偏向代码审查工具和权限控制。虽然gitlab也可以做代码审查，但是gerrit是做提交前审查，同时对代码权限的控制更细力度；而gitlab是代码提交后审查，同时必须有开发人员手动发起审查，不能自动发起审查操作。这导致他们两个的操作流程有很大区别。我个人更倾向于gerrit的方式，这样可以强迫大家把自己的代码质量提上去，所以我这里选择了两者结合，gerrit这里做权限和质量把控，gitlab做为集成测试和发布版本库。\n任务/缺陷管理环境 缺陷跟踪系统redmine、Bugzilla、BugZero、Trac、jira、trello、bugfree、禅道、coding.net等，现在不论是收费的还是免费的都有很多，我相信任何一个都能解决bug跟踪问题。从我的使用过程中发现这些系统都有各自的有点，同时也有很多不足的地方，最终一个工具是不是符合你们团队，只有试用过才知道。以下是我在使用过程中发现的一些特点，感觉如果从这些点出发去试用和思考一个系统或工具，可以很快判断这个系统或工具是否适合团队，里面有些特性是我使用过的工具里面都没有的，但是这些特点我感觉确实很有用：\n 跨平台客户端（现在大多是web，这个大部分都满足） 可以和其他种类系统集成（如：代码库，测试平台、持续集成环境等） 界面易操作性 多项目管理 自定义流程 当然成本决定算一个 系统更新速度 支持多种开发模式 分级统计功能 移动端支持  持续集成环境 持续集成环境对团队和项目的自动化有一定要求，同时可以也是对团队自动化的一种推进；同时对团队的开发流程和编码风格都会有推动作用。当然至于用什么工具那是其次的，总点是要让团队养成持续集成的习惯和节奏。\n持续集成至应该做到一下几点：\n 自动构建：要求无人值守，如果人工来操作，那就没有持续集成的必要了 发现版本库的变更：通过轮询或者定时，或者程序员使用命令，处罚持续集成发现版本库的变更 反馈机制：在出现问题时，能及时的把问题反馈给正确的人（提交者、测试者、管理者） 回滚：在出现问题后，拥有回滚到可交付的能力 纯净的构建环境：每一次都应该把之前的环境删除干净，让每一次构建都是一个新的构建 完善的集成功能：代码的测试，审查都应该做到完善。如果单纯的利用它做持续的编译，那就是大材小用了 为了避免每次过多出现问题的构建，开发者在提交代码的时候，最好在本地独立的构建一次。可以自行运行构建脚本，模拟构建 由于数据库与编码的分离，最好把数据库相关的DDL\\DML等脚本一起放入版本库中，这样CI进行构建的时候，可以连同数据库一起重新构建 能和我们的代码管理库、任务/缺陷跟踪等其他平台交互  推荐书籍《持续集成：软件质量改进和风险降低之道》\n集成工具：jenkins（前身是Hudson）、gitlab-ci、Apache Continuum、CruiseControl、Luntbuild、drone、shippable\n集成的配置是必不可少的，就是让你定义如何集成构建的构建脚本啦，如果没有一个可配置的构建过程，那持续集成从何说起呢。ant、maven、gradle、make、shell\n由于集成是基于测试之上的，所以一个好的测试工具比不可少，但是这个和团队使用的语言息息相关，每中语言都有自己的测试工具。简单举例已达到抛砖引玉的效果：各种Unit（Junit，HtmlUnit，cppUnit，SQLUnit等）、karma、mocha。。。（手软\u0026gt;_\u0026lt;）\n自动代码审查是提高代码质量，养成代码习惯比可少的，同时这些事情可以自动的做掉，可以让我们更加关注于我们的代码 checkstyle、javaNcss、PMD、siminan、jsHint、jsLint、Emma。。。\n集成反馈和报告这个可以让我们可以实时得到集成结果，失败快速找原因，成功我们就可以安心睡觉了。邮件通知、Jabber、JSCoverage、GCOV、python coverage、JCoverage、Cobertura。。。\n代码质量监控环境 代码质量监控平台其实就是让我们的代码质量可视化、可管理，让我们的代码质量形成历史记录。同时可以非常方便的工全部人员查看。\n 质量可视化 跟踪质量走向（需要历史记录） 可以自动从持续集成环境、代码审查中搜集质量信息 可以和代码管理环境打通，这个的目的是最好能看到每个人代码质量 可以和其他工程管理工具打通  SonarQube、前面介绍的自动代码审查工具\n文档编辑环境 我们的程序员往往都不喜欢写文档，你让他写文档，还不如让他写2倍的代码。但是文档确是我们项目中不可缺少的部分，那怎么让我们的程序员可以高效的写文档呢！其实我们程序员在写文档的时候，往往是被文档的格式所折磨，不能专心的写内容，从而出发对写文档的抵触情绪。所以结合以上我任务文档编写环境应该有一下几点：\n 不用关心格式，重点在内容，格式自动 能从代码中自动生成文档 文档能实时共享、自动共享，像现在用的邮件、QQ之类的其实很影响心情 文档格式足够简单，在写的时候要做到双手不脱离键盘最好  markdown、各种语言doc工具了（jsdoc、javadoc等）、wiki、shpinx\n沟通环境 上面所说的说有东西的最终目的其实都是为了解决我们协作的问题，至少是或多或少都会涉及到协作沟通问题。像现在大家用的最多的沟通工具应该变成QQ、微信之类的了吧，加上邮件、电话、各种协作平台或者其他通讯工具，但是这些工具都有一个特点：在使用的时候都会有一个长时间打断我们思维，或者需要我们专门准备一个时间去做；这些其实都会造成浪费。其实最有效的沟通就是面对面交流，所以构建一个良好的沟通环境，对我们的项目进度起着至关重要的作用：\n 沟通资源随手可得（易于获得），可以在30秒内获得 兄弟们可以采取自己认为高效的方式沟通，同时沟通方式的资源易于获得 沟通历史和结果易于记录，最好能在不察觉的情况下记录起来  项目开发环境 项目开发环境可以分为：工程管理工具和工程开发工具。项目开发环境每个团队都有差别，同时团队内部每个人肯定都有差异，因为它受到的影响因数最多，比如：使用语言，工作内容，个人习惯，操作系统，可能还和心情有关等。因此团队在选择项目开发环境的时候，既要根据团队的定位选定基础开发环境（工程管理工具），同时出一些选择辅助开发环境的选择指导规则；也要考虑每个成员的习惯，开放出来辅助开发环境，让每个成员可以根据自己的习惯，选择一套他自己最高效的项目开发环境集合。下面我列举我认为在选择工程管理工具和工程开发工具应该具备的几点特征：\n工程管理工具  可以和工程开发工具高效集成 可以测试 可以做质量检查 可以和质量管理系统集成  ant，maven，gradle，gulp，grunt，make，cmake。。。\n项目开发工具 项目开发工具也叫做集成开发环境，很多集成开发环境都带有自己的工程管理工具\n 可以和代码管理工具集成 测试必须 可以做本地质量检查 可以方便实现重构手法，关于重构推荐《重构：改变既有代码设计》 最好能和缺陷跟踪系统集成 可以和工程管理工具集成  eclipse、webstorm、vs、idea等\n需求/产品管理环境 对于需求/产品管理环境我自己现在还没有在具体项目中实践过，所以这里就不在阐述了，如果你有好的想法可以给我留言，或者给我连接地址，我连接过去\n测试管理环境 测试管理环境其实应该在持续集成环境里面，但是由于上面写持续集成环境的时候过于偏向开发人员的使用角度介绍了，并且这两套系统确实也是独立存在的。这个测试管理环境更多面向于测试人员，而我认为测试工具本身也是分为测试管理工具和测试执行工具两类别，所以我会从测试管理和测试执行两个方面来说我观点（这里的划分是按照工具的分类划分，并不是按照软件方法的方式划分），同时对于测试我想后面会有专门的一篇文章来介绍，所以这里就这样了，大家见谅我的不专业\n测试管理工具 测试管理我认为比较重要的是：测试计划，测试用例，测试跟踪，缺陷管理(这个和任务/缺陷管理环境一样)\n 可以管理测试计划 可以管理测试用例 可以跟踪每个测试用例的状态 可以和缺陷系统集成 可以和持续集成系统集成  QC(Quality Center)，TestLink，oKit，TD（TestDirector）上面提到的缺陷管理系统\n测试执行工具 测试执行的方式都很多了，并且测试执行种类也很多，比如：自动化测试，性能测试，安全测试，白盒测试等。这里面不同的测试方式所使用的工具都是不一样的：\nselenium，jmeter，jprofile，Wireshark，AppCan，Metasploit，Nmap，Acunetix，Burp Suite，apache ab，Gatling\n还是那句话工具只能给我们提供一个更专心、更快速做事的环境，但是最终这个事情能不能做成、能不能做好完全是取决我们自己。所以不论使用任何工具都行，前提是我们有自己提高的意识和习惯，比如：编码风格、编程习惯、测试习惯、重构习惯、沟通能力、协作能力等，这些才是真真决定项目成败的关键。\n"
},
{
	"uri": "https://blog.threeq.me/post/web/css3-added-selector/",
	"title": "CSS3 新增选择器",
	"tags": ["css3"],
	"description": "",
	"content": "现代前端开发中css3已经是不可其他的一部分，早已成为每个web开发人员必备技能之一。 而选择器又是css中最基础、最重要的知识点，对于我们页面结构和代码接口都有着举足轻重的作用。 今天我们就来看看css3所支持的和新增的选择器。\n\n1. CSS1定义的选择器    选择器 类型 说明     E 类型选择器 选择指定类型的元素   E#id ID选择器 选择匹配E的元素，且匹配元素的id为“id”，E选择符可以省略。   E.class 类选择器 选择匹配E的元素，且匹配元素的class属性值为“class”，E选择符可以省略。   E F 包含选择器 选择匹配F的元素，且该元素被包含在匹配E的元素内。   E:link 链接伪类选择器 选择匹配E的元素，且匹配元素被定义了超链接并未被访问。例：a:link、#a_id:link   E:visited 链接伪类选择器 选择匹配E的元素，且匹配元素被定义了超链接并已被访问。例：a:visited   E:active 用户操作伪类选择器 选择匹配E的元素，且匹配元素被激活   E:hover 用户操作伪类选择器 选择匹配E的元素，且匹配元素正被鼠标经过   E:focus 用户操作伪类选择器 选择匹配E的元素，且匹配元素获取了焦点   E:first-line 伪元素选择器 选择匹配E元素内的第一行文本   E:first-letter 伪元素选择器 选择匹配E元素内的第一个字符    2. CSS2定义的选择器    选择器 类型 说明     * 通配选择器 选择文档中所有元素   E[foo] 属性选择器 选择匹配E的元素，且该元素定义了foo属性。E选择符可以省略，表示选择定义了foo属性的任意类型的元素。   E[foo=\u0026ldquo;bar\u0026rdquo;] 属性选择器 选择匹配E的元素，且该元素foo属性值为“bar”   E[foo~=\u0026ldquo;bar\u0026rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个以空格符分隔的列表，其中一个列表的值为“bar”，E选择符可以省略。   E[foo!=\u0026ldquo;en\u0026rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个用连字符（-）分隔的列表，值以“en”开头。   E:first-child 结构伪类选择器 选择匹配E的元素，且该元素为父元素的第一个子元素   E:before 伪元素选择器 在匹配E的元素前面插入内容   E:after 伪元素选择器 在匹配E的元素后面插入内容   E \u0026gt; F 子包含选择器 选择匹配F的元素，且该元素为所匹配E元素的子元素。   E + F 相邻兄弟选择器 选择匹配F的元素，且该元素为所匹配E元素后面相邻的位置。   E:lang(language) 语言选择器 例如：p:lang(it) 选择带有以 \u0026ldquo;it\u0026rdquo; 开头的 lang 属性值的每个  元素。    3. CSS3新增属性选择器    选择器 类型 说明     E[foo^=\u0026ldquo;bar\u0026rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”开始。E选择符可以省略，表示可匹配任意类型的元素。   E[foo$=\u0026ldquo;bar\u0026rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”结束。E选择符可以省略，表示可匹配任意类型的元素。   E[foo*=\u0026ldquo;bar\u0026rdquo;] 属性选择器 选择匹配E的元素，且该元素定义了foo属性，foo属性值包含“bar”。E选择符可以省略，表示可匹配任意类型的元素。   E:root 结构伪类选择器 选择匹配E所在文档的根元素。在（X）HTML文档中，根元素就是html元素，此时该选择器与html类型选择器匹配的内容相同。   E:nth-child(n) 结构伪类选择器 选择所有在其父元素中第n个位置的匹配E的子元素。\n注意，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始。\ntr:nth-child(3)匹配所有表格中第3排的tr；\ntr:nth-child(2n+1)匹配所有表格的奇数行；\ntr:nth-child(2n)匹配所有表格的偶数行；\ntr:nth-child(odd)匹配所有表格的奇数行；\ntr:nth-child(even)匹配所有表格的偶数行；   E:nth-last-child(n) 结构伪类选择器 选择所有在其父元素中倒数第n个位置的匹配E的子元素   E:nth-of-type(n) 结构伪类选择器 选择父元素中第n个位置，且匹配E的子元素。\n注意，所有匹配E的子元素被分离出来单独排序。非E的子元素不参与排序。参数n可以是数字，关键字、公式。\n例：p:nth-of-type(1)   E:nth-last-of-type(n) 结构伪类选择器 选择父元素中倒数第n个位置，且匹配E的子元素。   E:last-child 结构伪类选择器 选择位于其父元素中最后一个位置，且匹配E的子元素。   E:first-of-type 结构伪类选择器 选择位于其父元素中且匹配E的第一个同类型的子元素。\n该选择器的功能类似于 E:nth-of-type(1)   E:last-of-type 结构伪类选择器 选择位于其父元素中且匹配E的最后第一个同类型的子元素。\n该选择器的功能类似于 E:nth-last-of-type(1)   E:only-child 结构伪类选择器 选择其父元素只包含一个子元素，且该子元素匹配E。   E:only-of-type 结构伪类选择器 选择其父元素只包含一个同类型的子元素，且该子元素匹配E。   E:empty 结构伪类选择器 选择匹配E的元素，且该元素不包含子节点   E:enabled UI状态伪类选择器 选择匹配E的所有可用UI元素。   E:disabled UI状态伪类选择器 选择匹配E的所有不可用UI元素。   E:checked UI状态伪类选择器 选择匹配E的所有可用UI元素。\n例：input:checked匹配input type为radio及checkbox元素   ::selection UI状态伪类选择器 选择被用户选取的元素部分。   E ~ F 相邻兄弟选择器 选择匹配F的所有元素，且匹配元素位于匹配E的元素后面。在DOM结构树中，E和F所匹配的元素应该在同一级结构上。   E:not(s) 否定伪类选择器 选择匹配E的所有元素，且过滤掉匹配s选择符的任意元素。s是一个简单结构的选择器，不能使用符合选择器，   E:target 目标伪类选择器 选择匹配E的所有元素，且匹配元素被相关URL指向。\n注意：该选择器是动态选择器，只有存在URL指向该匹配元素时，样式才起效果。\n例：demo.html#id    参考：http://www.w3school.com.cn/cssref/css_selectors.asp\n"
},
{
	"uri": "https://blog.threeq.me/about/",
	"title": "关于 Threeq - 出井的青蛙",
	"tags": [],
	"description": "Threeq - 出井的青蛙介绍",
	"content": " Threeq - 出井的青蛙  快乐的程序员、老司机。\n喜欢专研、思考和专研遇到的难题，不论是技术上还是团队管理上。\n对新技术保持好奇、热爱和谨慎的态度。坚信技术能让明天更美好。\n喜欢分享，开源追随者，崇尚敏捷开发实践。\n常用语言 Java、Python、Golang、Javascript\n目前正在实践 Scrum + 看板 + 领域驱动设计（DDD） + 微服务\n目前正在学 习机器学习（ML）、分布式系统架构设计、k8s 技术栈\n欢迎一起交流学习（非诚勿扰）    扫码关注订阅号    联系我    "
},
{
	"uri": "https://blog.threeq.me/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/ci/cd/",
	"title": "Ci/Cd",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/css3/",
	"title": "Css3",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/gerrit/",
	"title": "Gerrit",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/gitlab/",
	"title": "Gitlab",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/gtd/",
	"title": "Gtd",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/hugo/",
	"title": "Hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/jenkins/",
	"title": "Jenkins",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/mysql/",
	"title": "Mysql",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/percona/",
	"title": "Percona",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/post/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/pt-query-digest/",
	"title": "Pt Query Digest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/python/",
	"title": "Python",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/redmine/",
	"title": "Redmine",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/scrum/",
	"title": "Scrum",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/sql/",
	"title": "Sql",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/",
	"title": "Threeq - 出井的青蛙",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/web/",
	"title": "Web",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/",
	"title": "个人管理",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E5%89%8D%E7%AB%AF/",
	"title": "前端",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/",
	"title": "团队管理",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/%E5%B7%A5%E5%85%B7/",
	"title": "工具",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/",
	"title": "敏捷开发",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/",
	"title": "敏捷开发",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/",
	"title": "数据库",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/",
	"title": "数据库",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/",
	"title": "时间管理",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E6%9E%B6%E6%9E%84/",
	"title": "架构",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/",
	"title": "查询优化",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/tags/%E7%9C%8B%E6%9D%BF/",
	"title": "看板",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://blog.threeq.me/categories/%E7%AC%94%E8%AE%B0/",
	"title": "笔记",
	"tags": [],
	"description": "",
	"content": ""
}]