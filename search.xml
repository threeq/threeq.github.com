<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[hexo tag 插件，git版本分支图]]></title>
      <url>%2F2017%2F03%2F08%2Fhexo%2Fhexo-tag-gitgraph%2F</url>
      <content type="text"><![CDATA[将 git 命令生成版本库分支图。源代码如下：1234567891011121314151617181920git commit -am &apos;aaaaa&apos;git commit -m &apos;bbbb&apos;git checkout -b testgit checkout -b test1 git checkout -b test1 sdfsfagit checkout test2 sdfsfagit checkout test2 dfdfsdfsfagit commit -m &apos;ccccc&apos;git merge mastergit commit -m &apos;ccccc&apos;git merge master -m &apos;dfdfsfsfsfa&apos;git commit -am &apos;dddddd&apos;git commit -am \&quot;eeeee\&quot;git tag -a v1.2.3 -m &apos;sfdsfsdfa&apos;git commit -m \&quot;fffff\&quot;git checkout -b test2 git commit -am &apos;test2&apos;git checkout mastergit merge test1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 博客搭建实践]]></title>
      <url>%2F2017%2F03%2F08%2Fhexo%2Fhexo-blog-config%2F</url>
      <content type="text"><![CDATA[Hexo是一个基于nodejs的博客信息，使用markdown做为编写语言，非常适合程序员，你们懂的（&gt;_&lt;）!hexo 环境搭建nodejs安装nodejs 下载地址 http://nodejs.cn/download/hexo 安装1$ sudo npm install -g hexo-cligit 安装git下载地址 http://git-scm.com/download/快速开始生成博客1$ hexo init创建一个新的文章1$ hexo new post "My New Post"创建一个新页面1$ hexo new page "My New Page"创建一个草稿1$ hexo new draft "new draft"更多信息: Writing运行服务1$ hexo server更多信息: Server生成静态文件1$ hexo generate更多信息: Generating发布到远程服务1$ hexo deploy更多信息: Deployment博客设置更多信息: Configurationtag 插件uml插件（plantUML）123456&#123;% plantuml %&#125; Bob-&gt;Alice : hello world Alice-&gt;dd: dddxxxx dd-&gt;ee: aaa ee-&gt;ff: nihao&#123;% endplantuml %&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小团队开发基础平台工具推荐]]></title>
      <url>%2F2017%2F02%2F24%2Fproject-manage%2Fproject-manage-tool-01%2F</url>
      <content type="text"><![CDATA[每个项目管理中都有自己的管理工具集合，这里分享一下我用过的工具集合，这里面有些工具的实践时间可能并不是很长时间，列在这里意味这下一个阶段的实践计划。同时也分享一下我自己在选择工具集合的时候考虑的点(关于每类工具如何比较它们最后做出选择我后面会慢慢补上)。在这里不会详细介绍每种工具的安装、连接和使用过程，如果后面有时间我会专门写这些工具的安装、配置和配合使用。首先列出我认为在项目管理中比较重要的工具，同时这些也是我在实践中用得比较多的一套工具集：工具职责描述git网上有个在线教程很好《pro git》中文版gerrit代码库服务器工具/代码审核工具基于git的在线代码审查工具，围绕它建立代码审核平台和流程gitlab版本库展示平台gitlab这里只作为代码展示平台和最终的发布代码库jenkins自动化持续集成平台jenkins自动测试/集成/发布，围绕它建立可持续集成平台redmine任务管理平台/缺陷跟踪平台sonar代码质量报告聚合工具围绕它搭建一个代码质量监控平台关于上面工具的安装过程不做描述，不过个人建议可以把每个服务都做成docker容器，这样如果需要再次搭建环境就方便了。下面对这套工具集合的流程介绍工具流程整理流程gerrit代码审查流程选择工具的思考首先要明确一点：不论多么智能的工具，都是为我们程序员服务的，只是为我们提供一个更好工作的环境，让我们可以更愉快的coding。所以在选择一个项目的基础平台环境时，一定要考虑到项目团队的人员情况。* 平台工具集可以引导团队成员不断提高自己 * 方便团队任务分配、跟踪 * 团队成员可以随时随地，在自己想看代码的时候方便得到 * 代码质量可视化、可跟踪 * 一切和编码不相关的内容，尽量自动化 * 可持续集成 * 方便文档的编写 同时在项目中哪些方面是需要引入工具的呢？这个答案在每一个团队都会不一样，这里写一些我自己的想法：* 代码管理环境 * 任务/缺陷管理环境 * 自动化测试/持续集成环境 * 代码质量监控环境 * 文档编辑环境 * 协作/沟通环境 * 集成开发环境 下面我会对这几方面的工具进行一个简单的考量，说明我自己在这方面的考虑点，但是不会做非常细致的比较，原因有2个：有很多工具我自己也没有亲身使用过；每个人或团队对工具的思考都会不同，同时网上有很多的关于它们比拼的文章，最重要的是自己的使用感受和思考代码管理环境代码版本库的管理我相信这个大家都会用工具来管理（如果你还没有使用版本库管理或者还在自己手动管理，我只能呵呵。。。了）。对于不同的版本控制需求，我们需要不同的管理策略，当然这个和团队的协作方式有很大的关系。同时现在的代码版本管理工具也很多：VSS、SVN、GIT、CVS(完全可以用SVN代替)、ClearCase等。那对于代码管理环境需要考虑那些因素：* 安全性(如果你是开源的忠诚粉丝，可以完全忽略这个) * 易用性 * 总体成本 * 技术支持 * 周边产品（衍生工具/其他产品集成工具） * 是否离线操作（这个这里作为考虑条件是因为网络有时确实是一个坑,不解释） * 支持代码审查 这里我主要比较了git和svn。VSS支持平台有限（感觉只有win）果断干掉（我不好意思让兄弟们把mac换成win吧，呵呵。。。）；ClearCase看到网上介绍感觉功能很强大的，但是看了一下价格果断干掉（原因不要深究。。。）。GITgit这个现在很火，用的人很多，包括我自己现在也是完全使用这个。安全性使用这个可以说你的代码都没有什么安全性了(一些专业的git服务器除外)，他对安全性的控制你完全可以忽略。这个也没有办法，谁让他的作者就是开源狂热份子呢由于他们分布式管理方式，任何一个开发人员本地都有一份完整的代码库克隆，所以任何一个人员或服务器损坏了，也不会对开发有任何影响，同时找回来也是非常方便的，基本不用成本易用性这个可能就要因人而已了，如果之前对命令行的模式比较熟悉，那这个基本上就没有任何学习曲线了，只是自己的命令集合里面多了一个叫git的命令而已；但是对于之前比较习惯图形界面的童鞋就有学习成本了(实际上从我和兄弟们的使用情况来看，其实不是学习git命令花费时间，而是要让自己习惯命令行工作方式)，不过成本其实是很低的，比如我们团队的兄弟们在一周之内都实用的很溜了(这里给兄弟们赞一个)。后面就是关于分支的管理、合并、冲突的解决等协作方面的问题，这个从我个人的使用来看问题基本不大，只要把网上的那本《pro git》跟着操作完成，你能需要遇到的问题基本OK了。最后就是规划团队的代码管理流程了，让代码版本管理在团队不断扩大、项目越来越多的过程中不至于失控还有一个不经常会用到的操作，就是迁移代码库。这个对于git来说就太容易了，就是2、3个命令的事总体成本因为是开源的，所以从软件费用来说是0成本剩下的就是我们自己搭建服务器的成本了，如果感觉自己服务器也不想出，那就找网上的云服务就好了，所以这个成本也是相对叫低的了。这里列举几个我用过的：github、coding.net、Git@OSC具体谁更适合你，都去用一边就好了最后就是团队的学习成本了，从我在易用性里面介绍，我感觉一个团队学习的成本不会超过1周同时git的周边产品大多都是免费的或者提供免费版本，所以他的配套产品成本其实很低技术支持开源的东西就只有社区，这个不要想太多，任何东西都需要你自己去发现，当然如果你选择三方平台，他们会有服务器平台部分支持的周边产品现在基于git的衍生产品太多了，上面所列举的都是，随便baidu和google都是一大把其他平台对于git的支持我个人感觉很不错，不论是IDE、持续集成环境、bug跟踪系统都有响应的插件支持git版本库离线操作这个离线操作也是我之前考虑使用它的一个重要原因，每个人只需要在本地编写好、提交好你的代码，然后找一个网络环境的地方，把代码同步一下就好了SVN(有这个没有必要CVS了)svn现在用的团队很多，是一种集中式版本管理工具，我之前也是用这个很长一段时间。安全性svn的目标就管理团队代码，所以可以很精确的控制每个人远能访问的权限，目录分支等由于是集中式管理，所以svn服务器千万不能挂掉，如果挂了大家都不能工作了，同时找回代码也是一件费劲的事情易用性svn提供图形化客户端(非linux系统)，所以大家看一下就可以使用了svn分支、合并、冲突解决都是图形化操作，大家用起来问题不大大家都习惯了图形操作的方式，所以学习很快但是在团队不断变大、项目越来越多的时候，对svn的管理就需要有点技巧了总体成本svn软件本身是免费的，所以软件本身费用是0成本如果自己搭建服务器，那就需要服务器成本了，不过你可以选择网上云服务，如google代码库（国内的就别想了）、svn china、RiouxSVN等。因为我自己以前只使用过google，所以对这些云服务需要自己去体验了团队学习我们忽略吧svn的目标毕竟是代替老牌的cvs，周边产品的支持那是杠杠的，其他和软件开发相关的环境和平台，肯定都是支持svn的，如果你选择的基础环境工具中还有不支持svn的，那肯定是你出问题了。但是很多优秀svn的周边产品都是需要收费的技术支持社区绝对是一个神奇的存在，你遇到的问题，肯定有人解决了，至少我当时是这样的同时可以买专业的svn产品，这样可以得到专业团队的技术支持，当然这个成本肯定是有的周边产品刚刚就说了它的目标是代替老牌的cvs，所以周边产品自然不用说，只是成本的问题离线操作这个是我当时最郁闷的一点，如果你没有网络，你就不能提交了。很不好做历史记录管理git服务器这里只介绍git版本库管理中其他的思考。只介绍git是因为我现在使用的git，其实是之前在使用svn的时候没有考虑那么多，自己也没有好好去研究svn的一套体系。要使用git作为团队代码管理，就需要git服务器（当然对那些单兵作战的兄弟们，最好也有一个git服务器，这样至少可以做到你在哪里都可以作战）。这里git服务器的选择就有两种方式了：1、使用三方托管平台；2、自己搭建git服务器。这里主要讨论第2种方式，自家搭建服务器。git是基于ssh的，所以如果不要复杂功能只需要一个git-shell就可以是服务器了，不过我们可不想重复找轮子，别人已经弄好的工具，我们为什么不直接用呢！！！Gitosis、 Gitolite（这个东西的权限管理很不错）等。如果要高级功能的(如：web访问)，那gitlab和gerrit（下载需要翻墙）将是不二之选。这里我同时选用了2者，它们的不同在于gerrit是一个更偏向代码审查工具和权限控制。虽然gitlab也可以做代码审查，但是gerrit是做提交前审查，同时对代码权限的控制更细力度；而gitlab是代码提交后审查，同时必须有开发人员手动发起审查，不能自动发起审查操作。这导致他们两个的操作流程有很大区别。我个人更倾向于gerrit的方式，这样可以强迫大家把自己的代码质量提上去，所以我这里选择了两者结合，gerrit这里做权限和质量把控，gitlab做为集成测试和发布版本库。任务/缺陷管理环境缺陷跟踪系统redmine、Bugzilla、BugZero、Trac、jira、trello、bugfree、禅道、coding.net等，现在不论是收费的还是免费的都有很多，我相信任何一个都能解决bug跟踪问题。从我的使用过程中发现这些系统都有各自的有点，同时也有很多不足的地方，最终一个工具是不是符合你们团队，只有试用过才知道。以下是我在使用过程中发现的一些特点，感觉如果从这些点出发去试用和思考一个系统或工具，可以很快判断这个系统或工具是否适合团队，里面有些特性是我使用过的工具里面都没有的，但是这些特点我感觉确实很有用：跨平台客户端（现在大多是web，这个大部分都满足）可以和其他种类系统集成（如：代码库，测试平台、持续集成环境等）界面易操作性多项目管理自定义流程当然成本决定算一个系统更新速度支持多种开发模式分级统计功能移动端支持持续集成环境持续集成环境对团队和项目的自动化有一定要求，同时可以也是对团队自动化的一种推进；同时对团队的开发流程和编码风格都会有推动作用。当然至于用什么工具那是其次的，总点是要让团队养成持续集成的习惯和节奏。持续集成至应该做到一下几点：自动构建：要求无人值守，如果人工来操作，那就没有持续集成的必要了发现版本库的变更：通过轮询或者定时，或者程序员使用命令，处罚持续集成发现版本库的变更反馈机制：在出现问题时，能及时的把问题反馈给正确的人（提交者、测试者、管理者）回滚：在出现问题后，拥有回滚到可交付的能力纯净的构建环境：每一次都应该把之前的环境删除干净，让每一次构建都是一个新的构建完善的集成功能：代码的测试，审查都应该做到完善。如果单纯的利用它做持续的编译，那就是大材小用了为了避免每次过多出现问题的构建，开发者在提交代码的时候，最好在本地独立的构建一次。可以自行运行构建脚本，模拟构建由于数据库与编码的分离，最好把数据库相关的DDL\DML等脚本一起放入版本库中，这样CI进行构建的时候，可以连同数据库一起重新构建能和我们的代码管理库、任务/缺陷跟踪等其他平台交互推荐书籍《持续集成：软件质量改进和风险降低之道》集成工具：jenkins（前身是Hudson）、gitlab-ci、Apache Continuum、CruiseControl、Luntbuild、drone、shippable集成的配置是必不可少的，就是让你定义如何集成构建的构建脚本啦，如果没有一个可配置的构建过程，那持续集成从何说起呢。ant、maven、gradle、make、shell由于集成是基于测试之上的，所以一个好的测试工具比不可少，但是这个和团队使用的语言息息相关，每中语言都有自己的测试工具。简单举例已达到抛砖引玉的效果：各种Unit（Junit，HtmlUnit，cppUnit，SQLUnit等）、karma、mocha。。。（手软&gt;_&lt;）自动代码审查是提高代码质量，养成代码习惯比可少的，同时这些事情可以自动的做掉，可以让我们更加关注于我们的代码checkstyle、javaNcss、PMD、siminan、jsHint、jsLint、Emma。。。集成反馈和报告这个可以让我们可以实时得到集成结果，失败快速找原因，成功我们就可以安心睡觉了。邮件通知、Jabber、JSCoverage、GCOV、python coverage、JCoverage、Cobertura。。。代码质量监控环境代码质量监控平台其实就是让我们的代码质量可视化、可管理，让我们的代码质量形成历史记录。同时可以非常方便的工全部人员查看。质量可视化跟踪质量走向（需要历史记录）可以自动从持续集成环境、代码审查中搜集质量信息可以和代码管理环境打通，这个的目的是最好能看到每个人代码质量可以和其他工程管理工具打通SonarQube、前面介绍的自动代码审查工具文档编辑环境我们的程序员往往都不喜欢写文档，你让他写文档，还不如让他写2倍的代码。但是文档确是我们项目中不可缺少的部分，那怎么让我们的程序员可以高效的写文档呢！其实我们程序员在写文档的时候，往往是被文档的格式所折磨，不能专心的写内容，从而出发对写文档的抵触情绪。所以结合以上我任务文档编写环境应该有一下几点：不用关心格式，重点在内容，格式自动能从代码中自动生成文档文档能实时共享、自动共享，像现在用的邮件、QQ之类的其实很影响心情文档格式足够简单，在写的时候要做到双手不脱离键盘最好markdown、各种语言doc工具了（jsdoc、javadoc等）、wiki、shpinx沟通环境上面所说的说有东西的最终目的其实都是为了解决我们协作的问题，至少是或多或少都会涉及到协作沟通问题。像现在大家用的最多的沟通工具应该变成QQ、微信之类的了吧，加上邮件、电话、各种协作平台或者其他通讯工具，但是这些工具都有一个特点：在使用的时候都会有一个长时间打断我们思维，或者需要我们专门准备一个时间去做；这些其实都会造成浪费。其实最有效的沟通就是面对面交流，所以构建一个良好的沟通环境，对我们的项目进度起着至关重要的作用：沟通资源随手可得（易于获得），可以在30秒内获得兄弟们可以采取自己认为高效的方式沟通，同时沟通方式的资源易于获得沟通历史和结果易于记录，最好能在不察觉的情况下记录起来项目开发环境项目开发环境可以分为：工程管理工具和工程开发工具。项目开发环境每个团队都有差别，同时团队内部每个人肯定都有差异，因为它受到的影响因数最多，比如：使用语言，工作内容，个人习惯，操作系统，可能还和心情有关等。因此团队在选择项目开发环境的时候，既要根据团队的定位选定基础开发环境（工程管理工具），同时出一些选择辅助开发环境的选择指导规则；也要考虑每个成员的习惯，开放出来辅助开发环境，让每个成员可以根据自己的习惯，选择一套他自己最高效的项目开发环境集合。下面我列举我认为在选择工程管理工具和工程开发工具应该具备的几点特征：工程管理工具可以和工程开发工具高效集成可以测试可以做质量检查可以和质量管理系统集成ant，maven，gradle，gulp，grunt，make，cmake。。。项目开发工具项目开发工具也叫做集成开发环境，很多集成开发环境都带有自己的工程管理工具可以和代码管理工具集成测试必须可以做本地质量检查可以方便实现重构手法，关于重构推荐《重构：改变既有代码设计》最好能和缺陷跟踪系统集成可以和工程管理工具集成eclipse、webstorm、vs、idea等需求/产品管理环境对于需求/产品管理环境我自己现在还没有在具体项目中实践过，所以这里就不在阐述了，如果你有好的想法可以给我留言，或者给我连接地址，我连接过去测试管理环境测试管理环境其实应该在持续集成环境里面，但是由于上面写持续集成环境的时候过于偏向开发人员的使用角度介绍了，并且这两套系统确实也是独立存在的。这个测试管理环境更多面向于测试人员，而我认为测试工具本身也是分为测试管理工具和测试执行工具两类别，所以我会从测试管理和测试执行两个方面来说我观点（这里的划分是按照工具的分类划分，并不是按照软件方法的方式划分），同时对于测试我想后面会有专门的一篇文章来介绍，所以这里就这样了，大家见谅我的不专业测试管理工具测试管理我认为比较重要的是：测试计划，测试用例，测试跟踪，缺陷管理(这个和任务/缺陷管理环境一样)可以管理测试计划可以管理测试用例可以跟踪每个测试用例的状态可以和缺陷系统集成可以和持续集成系统集成QC(Quality Center)，TestLink，oKit，TD（TestDirector）上面提到的缺陷管理系统测试执行工具测试执行的方式都很多了，并且测试执行种类也很多，比如：自动化测试，性能测试，安全测试，白盒测试等。这里面不同的测试方式所使用的工具都是不一样的：selenium，jmeter，jprofile，Wireshark，AppCan，Metasploit，Nmap，Acunetix，Burp Suite，apache ab，Gatling还是那句话工具只能给我们提供一个更专心、更快速做事的环境，但是最终这个事情能不能做成、能不能做好完全是取决我们自己。所以不论使用任何工具都行，前提是我们有自己提高的意识和习惯，比如：编码风格、编程习惯、测试习惯、重构习惯、沟通能力、协作能力等，这些才是真真决定项目成败的关键。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3新增选择器]]></title>
      <url>%2F2017%2F02%2F07%2Fcss3%E6%96%B0%E5%A2%9E%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[现代前端开发中css3已经是不可其他的一部分，早已成为每个web开发人员必备技能之一。而选择器又是css中最基础、最重要的知识点，对于我们页面结构和代码接口都有着举足轻重的作用。今天我们就来看看css3所支持的和新增的选择器。1. CSS1定义的选择器选择器类型说明E类型选择器选择指定类型的元素E#idID选择器选择匹配E的元素，且匹配元素的id为“id”，E选择符可以省略。E.class类选择器选择匹配E的元素，且匹配元素的class属性值为“class”，E选择符可以省略。E F包含选择器选择匹配F的元素，且该元素被包含在匹配E的元素内。E:link链接伪类选择器选择匹配E的元素，且匹配元素被定义了超链接并未被访问。例：a:link、#a_id:linkE:visited链接伪类选择器选择匹配E的元素，且匹配元素被定义了超链接并已被访问。例：a:visitedE:active用户操作伪类选择器选择匹配E的元素，且匹配元素被激活E:hover用户操作伪类选择器选择匹配E的元素，且匹配元素正被鼠标经过E:focus用户操作伪类选择器选择匹配E的元素，且匹配元素获取了焦点E:first-line伪元素选择器选择匹配E元素内的第一行文本E:first-letter伪元素选择器选择匹配E元素内的第一个字符2. CSS2定义的选择器选择器类型说明*通配选择器选择文档中所有元素E[foo]属性选择器选择匹配E的元素，且该元素定义了foo属性。E选择符可以省略，表示选择定义了foo属性的任意类型的元素。E[foo=”bar”]属性选择器选择匹配E的元素，且该元素foo属性值为“bar”E[foo~=”bar”]属性选择器选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个以空格符分隔的列表，其中一个列表的值为“bar”，E选择符可以省略。E[foo!=”en”]属性选择器选择匹配E的元素，且该元素定义了foo属性，foo属性值是一个用连字符（-）分隔的列表，值以“en”开头。E:first-child结构伪类选择器选择匹配E的元素，且该元素为父元素的第一个子元素E:before伪元素选择器在匹配E的元素前面插入内容E:after伪元素选择器在匹配E的元素后面插入内容E &gt; F子包含选择器选择匹配F的元素，且该元素为所匹配E元素的子元素。E + F相邻兄弟选择器选择匹配F的元素，且该元素为所匹配E元素后面相邻的位置。E:lang(language)语言选择器例如：p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个元素。3. CSS3新增属性选择器选择器类型说明E[foo^=”bar”]属性选择器选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”开始。E选择符可以省略，表示可匹配任意类型的元素。E[foo$=”bar”]属性选择器选择匹配E的元素，且该元素定义了foo属性，foo属性值以“bar”结束。E选择符可以省略，表示可匹配任意类型的元素。E[foo*=”bar”]属性选择器选择匹配E的元素，且该元素定义了foo属性，foo属性值包含“bar”。E选择符可以省略，表示可匹配任意类型的元素。E:root结构伪类选择器选择匹配E所在文档的根元素。在（X）HTML文档中，根元素就是html元素，此时该选择器与html类型选择器匹配的内容相同。E:nth-child(n)结构伪类选择器选择所有在其父元素中第n个位置的匹配E的子元素。注意，参数n可以是数字（1、2、3）、关键字（odd、even）、公式（2n、2n+3）参数的索引从1开始。tr:nth-child(3)匹配所有表格中第3排的tr；tr:nth-child(2n+1)匹配所有表格的奇数行；tr:nth-child(2n)匹配所有表格的偶数行；tr:nth-child(odd)匹配所有表格的奇数行；tr:nth-child(even)匹配所有表格的偶数行；E:nth-last-child(n)结构伪类选择器选择所有在其父元素中倒数第n个位置的匹配E的子元素E:nth-of-type(n)结构伪类选择器选择父元素中第n个位置，且匹配E的子元素。注意，所有匹配E的子元素被分离出来单独排序。非E的子元素不参与排序。参数n可以是数字，关键字、公式。例：p:nth-of-type(1)E:nth-last-of-type(n)结构伪类选择器选择父元素中倒数第n个位置，且匹配E的子元素。E:last-child结构伪类选择器选择位于其父元素中最后一个位置，且匹配E的子元素。E:first-of-type结构伪类选择器选择位于其父元素中且匹配E的第一个同类型的子元素。该选择器的功能类似于 E:nth-of-type(1)E:last-of-type结构伪类选择器选择位于其父元素中且匹配E的最后第一个同类型的子元素。该选择器的功能类似于 E:nth-last-of-type(1)E:only-child结构伪类选择器选择其父元素只包含一个子元素，且该子元素匹配E。E:only-of-type结构伪类选择器选择其父元素只包含一个同类型的子元素，且该子元素匹配E。E:empty结构伪类选择器选择匹配E的元素，且该元素不包含子节点E:enabledUI状态伪类选择器选择匹配E的所有可用UI元素。E:disabledUI状态伪类选择器选择匹配E的所有不可用UI元素。E:checkedUI状态伪类选择器选择匹配E的所有可用UI元素。例：input:checked匹配input type为radio及checkbox元素::selectionUI状态伪类选择器选择被用户选取的元素部分。E ~ F相邻兄弟选择器选择匹配F的所有元素，且匹配元素位于匹配E的元素后面。在DOM结构树中，E和F所匹配的元素应该在同一级结构上。E:not(s)否定伪类选择器选择匹配E的所有元素，且过滤掉匹配s选择符的任意元素。s是一个简单结构的选择器，不能使用符合选择器，E:target目标伪类选择器选择匹配E的所有元素，且匹配元素被相关URL指向。注意：该选择器是动态选择器，只有存在URL指向该匹配元素时，样式才起效果。例：demo.html#id参考：http://www.w3school.com.cn/cssref/css_selectors.asp]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[让网络更好为你服务]]></title>
      <url>%2F2017%2F02%2F05%2Flet-the-network-better-serve-you%2F</url>
      <content type="text"><![CDATA[你每天早上一醒来有没有立即想拿起手机赶紧看一下（facebook、twitter、微信），无论里面有没有信息都要打开一下才安心？并且在上班之前还要想办法挤出时间看一下各大新闻网站，查收邮件在各种邮件信息中找出今天需要处理的事情。并且在工作的时候，一出现一个消息弹框马上点击进去看，害怕自己遗漏哪怕一次消息。这些在一个信息爆炸的时代是正常的，被称为信息饥渴。其实出现这个情况是由于我们没有很好获取信息方式和管理信息方法。这篇文章就介绍如何更好的利用网络工具来为我们管理信息。这里我先把这些网络工具分为：信息产生工具github、facebook、twitter、rss博客、linkedin、微信服务号 信息收集转换器zapier、ifttt、smooch、feedly、pocket、buffer 信息管理工具Evernote、todoist、kanbanflow、自己博客、bearychat、slack 作为一个有态度的程序员肯定是从我最爱的github开始了，我们在github上面肯定少不了有自己的开源代码，当有人给我们提交一个issue、发起一个pull request等信息时我们github --&gt; kanbanflow 我把看书作为一项任务来对待，在我看完一本书的时候自动在 Evernote 里面创建一个书评的待完成的笔记，并在 todolist 中建立一个任务放入到待计划中kanbanflow --&gt; Evernote --&gt; kanbanflow 对于facebook、twitter等社交工具中有新信息的时候，全部集中到 slackfacebook/twitter --&gt; slack 对于各种新闻信息进行快速过滤，对于感兴趣的放入到pocket,同时建立阅读任务；后面在整理pocket的时候需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。pocket --&gt; todoist pocket --&gt; Evernote --&gt; kanbanflow 对于自己关注的新闻、博客、论坛等信息，订阅rss信息到feedly，如果有信息时自在todolist建立阅读任务；在阅读过程中需要整理笔记的时候自动在Evernote中建立需要完善的整理笔记和相关todolit任务。rss/feedly --&gt; kanbanflow rss/feedly --&gt; Evernote --&gt; kanbanflow 对于自己博客更新，会自动同步到twitter、facebook等账户中，并且保存到 Evernote自己博客 --&gt; facebook --&gt; twitter --&gt; Evernote 在工作中我们会用到 gitlab、jenkins 等工具，我把这些信息全都收集到 bearychat 中gitlab/jenkins --&gt; bearychat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[uml学习-plantuml]]></title>
      <url>%2F2016%2F12%2F04%2Fuml%E5%AD%A6%E4%B9%A0-plantuml%2F</url>
      <content type="text"><![CDATA[软件设计工具箱中 UML 绝对是一个必备工具，这也意味着作为一个程序员学习UML的使用是必须的了。UML图中总共有9种图：用例图时序图类图对象度活动图状态图组件图部署图泳道图其中，时序图、活动图、泳道图 可以互相转换画UML图的工具有很多，今天介绍一款特别的UML工具：PlantUML。它是使用编码的方式生成UML图。不过开始学习UML时，为了能更好的理解UML的使用规则、使用场景和思考原则，建议不要使用任何工具软件，而是使用笔和本子手动绘制各种图标。时序图用例图类图对象图活动图1234@startuml:Hello wolrd;:This is on defined on several **lines**;@enduml1234567@startumlstart:Hello world;:This is on defined onseveral **lines**;stop@enduml1234567@startumlstart:Hello world;:This is on defined onseveral **lines**;end@enduml1234567891011121314@startumlstartif (Graphviz installed?) then (yes) :process all\ndiagrams;else (no) :process only __sequence__ and __activity__ diagrams;endifstop@enduml12345678910111213141516@startumlstartif (condition A) then (yes) :Text 1;elseif (condition B) then (yes) :Text 2; stopelseif (condition C) then (yes) :Text 3;elseif (condition D) then (yes) :Text 4;else (nothing) :Text else;endifstop@enduml123456789101112@startumlstartrepeat :read data; :generate diagrams;repeat while (more data?)stop@enduml123456789101112@startumlstartwhile (data available?) :read data; :generate diagrams;endwhilestop@enduml12345678@startumlwhile (check filesize ?) is (not empty) :read file;endwhile (empty):close file;@enduml12345678910111213141516@startumlstartif (multiprocessor?) then (yes) fork :Treatment 1; fork again :Treatment 2; end forkelse (monoproc) :Treatment 1; :Treatment 2;endif@enduml泳道图在plantuml里面泳道图，是使用和活动图相同的语法12345678910111213@startuml|Swimlane1|start:foo1;|#AntiqueWhite|Swimlane2|:foo2;:foo3;|Swimlane1|:foo4;|Swimlane2|:foo5;stop@enduml123456789101112131415161718@startuml:start; fork :foo1; :foo2; fork again :foo3; detach endfork if (foo4) then :foo5; detach endif :foo6; detach :foo7; stop@enduml123456789101112131415161718192021222324@startuml:Ready;:next(o)|:Receiving;split :nak(i)&lt; :ack(o)&gt;split again :ack(i)&lt; :next(o) on several line| :i := i + 1] :ack(o)&gt;split again :err(i)&lt; :nak(o)&gt;split again :foo/split again :i &gt; 5&#125;stopend split:finish;@enduml状态图]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git版本管理流程]]></title>
      <url>%2F2016%2F04%2F26%2Fgit-branch-flow%2F</url>
      <content type="text"><![CDATA[代码版本库使用git管理，以下是git版本使用规范分支使用说明分支名称名字说明实例master线上分支不用于开发，使用tag功能标记版本。只能由beta和hotfix合并，合并同时打上发布版本tagv1.0.2beta灰度分支组灰度分之只能由test合并master产生，在测试通过后进入灰度阶段产生；灰度通过后合并进入masterbeta/signtest(release)测试分支组只能用于测试和修改bug，只能由由master合并进feature产生。对于测试通过的test，使用merge合并方式合并master产生beta分之；合并后的release需要删除test/sign; release/activefeature功能分支组从最新master检出用于开发一个新功能，一旦完成开发，合并master进入下一个test，删除本次feature分支；负责开发中多开发者代码同步使用feature/news; feature/votetopic本地开发分支组开发人员基于feature/release/hotfix检出自己本地开发(或修改bug)分支，在开发(或修改bug)中使用rebase合并方式和feature/release/hotfix进行同步。原则上一个feature/release/hotfix分支对应一个topic分支，开发完成的feature/release/hotfix删除对应的topic分支topic/feature-news-wlp; topic/release-new-wlp; topic/hotfix-news-wlphotfix修补分支组对于线上紧急bug修改，产生一个hotfix分支，只能由master上的tag标签签出。修改完成的hotfix合并回master，并且必须删除hotfix/v1.0.2注意：个人开发分支除特殊情况，不允许提交到远程服务器中。流程图说明代码提交/合并说明这个是开发人在日常开发中使用最多的操作。获取代码库123$ git clone &lt;版本库地址&gt;$ cd &lt;代码目录&gt;$ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt;建立自己的本地开发分支12$ git checkout feature/&lt;功能分支&gt;$ git checkout -b topic/&lt;功能分支&gt;-&lt;你的标识&gt;提交修改123$ git status$ git add .$ git commit -am &apos;修改描述&apos;发布你的修改123$ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt;$ git rebase feature/&lt;功能分支&gt; # 这里可能会产生合并操作$ git push origin topic/&lt;功能分支&gt;-&lt;你的标识&gt;:feature/&lt;功能分支&gt;代码发布说明发布代码是针对功能发布而定的，发布又分为测试发布和上线发布。对于发布操作，必须是先到测试环境(test)，再从测试环境(test)到灰度环境(beta)，最后从灰度环境(beta)到生产环境(master)，对于线上每次发布都必须有标签记录，可以回退。原则上从beta到master只会产生 fast-forward 类型操作。以下所有操作都在自己的开发分支中完成。发布到测试环境123456789101112# 合并feature分支$ git fetch origin master:master$ git fetch origin feature/&lt;功能分支&gt;:feature/&lt;功能分支&gt;$ git checkout feature/&lt;功能分支&gt;$ git merge master~~解决冲突~~# 生产test分支$ git checkout -b test/&lt;功能分支&gt;$ git push origin test/&lt;功能分支&gt;: test/&lt;功能分支&gt;# 清理feature分支$ git push origin :feature/&lt;功能分支&gt;$ git branch -D feature/&lt;功能分支&gt;发布到灰度环境123456789101112# 合并master到测试$ git fetch origin test/&lt;功能分支&gt;:test/&lt;功能分支&gt;$ git fetch origin master:master$ git checkout test/&lt;功能分支&gt;$ git merge master~~解决冲突~~# 生成beta分支$ git checkout -b beta/&lt;功能分支&gt;$ git push origin beta/&lt;功能分支&gt;:beta/&lt;功能名称&gt;# 清理 test$ git push origin :test/&lt;版本&gt;$ git branch -D test/&lt;版本&gt;发布到生产环境1234567891011# 合并到master$ git fetch origin beta/&lt;版本&gt;:beta/&lt;版本&gt;$ git fetch origin master:master$ git checkout master$ git merge beta/&lt;版本&gt;$ git tag -a &lt;发布版本号&gt; -m &quot;发布功能描述&quot;$ git push origin --tags$ git push origin master:master# 清理 beta$ git push origin :beta/&lt;版本&gt;$ git branch -D beta/&lt;版本&gt;修改生产环境bug1234567891011121314# 创建补丁版本，进行修改$ git fetch origin --tag$ git checkout -b hotfix/&lt;版本号&gt; &lt;版本号&gt;# 修改完成发布# 1. 合并到master$ git fetch origin master:master$ git checkout master$ git merge hotfix/&lt;版本号&gt;$ git tag -a &lt;发布版本号&gt; -m &quot;发布功能描述&quot;$ git push origin --tag$ git push origin master:master# 清理 hotfix$ git push origin :hotfix/&lt;版本号&gt;$ git branch -D hotfix/&lt;版本号&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker使用 - windows篇]]></title>
      <url>%2F2016%2F02%2F21%2Fdocker%2Fdocker-win%2F</url>
      <content type="text"><![CDATA[最新的 docker 在windows平台下安装和配置都很简单，请移步到docker windows版本]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker使用 - mac篇]]></title>
      <url>%2F2016%2F02%2F21%2Fdocker%2Fdocker-mac%2F</url>
      <content type="text"><![CDATA[最新的 docker 在mac平台下安装和配置都要简单很多，请移步到docker mac版本以下提供的是老版本的安装步骤之前学习过一段时间的docker，现在把docker的安装、基本操作、使用记录起来。此次安装docker的步骤讲解使用环境是 mac OS X EI Capitan（版本 10.11.3）。mac中使用docker需要使用boot2docker虚拟机支持，boot2docker是运行在Virtual Box里面的虚拟机。所有的docker容器实际运行在boot2docker里面，用户通过mac中docker客户端连接到boot2docker里面进行容器管理操作。docker 下载/安装windows/mac下建议使用docker一键安装包下载地址：https://get.daocloud.io/toolbox/ 下载你需要的版本。boot2docker工具安装包从github上下载https://github.com/boot2docker/osx-installer/releases测试安装结果12345$ docker --versionDocker version 1.8.0, build 0d03096$ boot2docker versionBoot2Docker-cli version: v1.8.0Git commit: 9a26066正常显示出版本信息表示成功初始化docker123$ boot2docker init$ boot2docker start$ $(boot2docker shellinit)根据提示设置docker环境变量123export DOCKER_HOST=xxxxxexport DOCKER_CERT_PATH=boot2docker-vm pathexport DOCKER_TLS_VERIFY=1如果不配置环境变量，会提示docker服务找不到查看配置信息1$ boot2docker -v info测试docker1$ docker run hello-world如果一切正常，那么docker的简单安装就完成了，docker的具体使用可以参考docker基本使用配置为了访问docker容器里面的服务器或端口，需要将容器端口映射到boot2docker虚拟机上。如果还需要重mac主机上访问docker容器，还需要将boot2docker虚拟机的端口通过NAT的方式映射到mac主机对应端口。mac主机端口 —–&gt; boot2docker虚拟机端口 ——-&gt; docker容器端口映射mac主机端口 到 boot2docker虚拟机端口有2中方式可以选择。参考######1. 在 Mac OS X与 VM Linux之间临时建立 ssh tunnel1$ boot2docker ssh -vnNTL 8000:localhost:8000######2. 用 Virtual Box的 NAT端口映射能力建立永久性的映射虚拟机已关闭时123VBoxManage modifyvm "boot2docker-vm" natpf1 "tcp-port3306,tcp,,3306,,3306"VBoxManage modifyvm "boot2docker-vm" natpf1 "tcp-port10080,tcp,,10080,,80"VBoxManage modifyvm "boot2docker-vm" natpf1 "tcp-port3000,tcp,,3000,,3000"虚拟机在运行时123VBoxManage controlvm "boot2docker-vm" natpf1 "tcp-port3306,tcp,,3306,,3306"VBoxManage controlvm "boot2docker-vm" natpf1 "tcp-port10080,tcp,,10080,,80"VBoxManage controlvm "boot2docker-vm" natpf1 "tcp-port3000,tcp,,3000,,3000"注意: mac上小于1024（如80、22等）端口需要root权限，所以一般不映射到这些端口boot2docker虚拟机端口 到 docker容器端口从boot2docker虚拟机端口到docker容器端口映色，有docker容器控制，具体详情参考docker手册参考docker 共享目录配置设置docker虚拟机目录共享123boot2docker stopVBoxManage sharedfolder add boot2docker-vm --name Volumes --hostpath /Volumes/ --automountboot2docker start配置docker虚拟机自动挂载建立 /var/lib/boot2docker/bootlocal.sh挂载新目录，docker虚拟机在启动的时候会自动执行这个脚本文件1234cd /var/lib/boot2docker/sudo vi bootlocal.shsudo chmod u+x bootlocal.shsudo rebootbootlocal.sh文件内容如下123#!/bin/shmkdir -p /Volumesmount -t vboxsf /Volumes /Volumes -o rw,uid=1000,gid=50]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[docker使用 - docker加速]]></title>
      <url>%2F2016%2F02%2F21%2Fdocker%2Fdocker-quicken%2F</url>
      <content type="text"><![CDATA[今天给大家推荐一个docker加速方法，希望大家用docker越来越爽。docker官方镜像资源在国内访问一直是一个坑啊，好在国内各种大牛和公司给出了很多的解决方案（在此对他们表示衷心的感谢）。docker加速对于docker在使用时镜像下载很慢或失败，是由于docker官方镜像已经被那啥了，大家都懂得。这里我们使用daocloud的加速服务（先升级到docker1.3.2以上）。先在daocloud上注册一个账号按照daocloud加速配置教程配置这里我们使用原生docker，所以按照 1.0 操作手册12echo "DOCKER_OPTS=\"\$DOCKER_OPTS --registry-mirror=http://&lt;xxxxx&gt;.m.daocloud.io\"" | sudo tee -a /etc/default/dockersudo service docker restart测试docker加速docker pull ubuntu当然也可以直接使用他们提供的第二版本方式对于有更方便的加速方法希望他家能提出，持续更新]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[doker安装 - linux篇]]></title>
      <url>%2F2016%2F02%2F19%2Fdocker%2Finstall-linux%2F</url>
      <content type="text"><![CDATA[之前学习过一段时间的docker，现在把docker的安装、基本操作、使用记录起来。此次安装docker的步骤讲解使用环境是ubuntu 14.04。ubuntu安装基本都是命令行，我就一步一步写命令了：apt-get安装更新软件源，同时使其支持https工作方式12$ sudo apt-get update$ sudo apt-get install apt-transport-https ca-certificates加入 GPG 秘钥1$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D添加docker安装源，新建/etc/apt/sources.list.d/docker.list文件1$ sudo vim /etc/apt/sources.list.d/docker.list输入如下信息:1deb https://apt.dockerproject.org/repo ubuntu-trusty main保存退出安装docker依赖1$ sudo apt-get install linux-image-extra-$(uname -r)使用apt-get安装docker1234$ sudo apt-get update$ sudo apt-get purge lxc-docker$ sudo apt-cache policy docker-engine$ sudo apt-get install docker-engine验证docker安装是否成功12$ sudo service docker start$ sudo docker run hello-world安装参考文档daocloud安装如果感觉上面安装过程太慢，也可以使用daocloud的安装教程1$ curl -sSL https://get.daocloud.io/docker | sh适用于Ubuntu，Debian,Centos等大部分Linux，会3小时同步一次Docker官方资源安装体验版或测试版，体验最新Docker。1$ curl -sSL https://get.daocloud.io/docker-experimental | sh1$ curl -sSL https://get.daocloud.io/docker-test | sh如果安装不成功，可以选择使用二进制包安装方式。 下载二进制包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript内存结构学习01]]></title>
      <url>%2F2015%2F11%2F04%2Fjavascript%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A001%2F</url>
      <content type="text"><![CDATA[最近项目中遇到了js继承方面的问题，发现js里面的继承机制和java/c++的继承有很大的区别，同时项目团队中的兄弟们对于js继承的理解也不是很透彻。所以，我把我对js继承和基本运行机制的理解写出来和他家一起讨论，同时把js的的继承方式和java/c++中的继承做比较，主要是对它们的内存结构做讲解。对于继承的理论和实现方式有很多，我这里不做一一介绍，只会针对一种实现方式去做比较，主要是想提供一种学习编程语言的方式（从程序内存结构开始学习一门编程语言，个人认为这个也是学习多门语言的一个敲门，也是掌握和比较多门语言的基础），希望可以供大家参考，起到一个抛砖引玉的作用。我们直接从例子开始代码1123456789101112131415161718192021222324252627282930// step1:生成基础结构var p=&#123; m1:10, m2:&#123; m2_2:20 &#125;&#125;;var c1=&#123;&#125;,c2=&#123;&#125;;c1.__proto__=p;c2.__proto__=p;Object.prototype.m0=1;// end step1// step2：开始操作赋值c1.m1=11;c1.m2.m2_2=21;c2.m1=12;c2.m2=&#123; m2_2:22&#125;;// end step2// step3：打印输出console.log("c1.m0=",c1.m0);console.log("c1.m1=",c1.m1);console.log("c1.m2.m2_2=",c1.m2.m2_2);console.log("c2.m1=",c2.m1);console.log("c2.m2.m2_2=",c2.m2.m2_2);console.log("p.m1=",p.m1);console.log("p.m2.m2_2=",p.m2.m2_2);运行结果如下：对这个结果有异议的同鞋，欢迎指正！同时建议大家可以打开浏览器亲自测试一下上面的代码，对理解后面的内存结构分析很有帮助。结果分析首先我们看一下他们的内存结构。在执行完step1代码片段，我们得到的内存结构如下图：对于上面的结构图有疑问的可以留言，或者可以直接在浏览器里面验证，如果不知道验证方法的可以留言讨论。在执行玩step2代码片段，我们得到的内存结构如下图：对于上面的内存结构的原因是由于js在执行的时候对于对象属性的查找/赋值规则决定的：对于属性查找会遍历原型链，直到找到第一个返回；对于属性赋值，只能是影响当前对象，不能改变原形链。如果有兴趣研究为什么js要使用这样规则的，可以看看js语言实现和程序语言原理方面的书籍或文章。有了第二部的内存结构图，我相信大家对于第step3中的输出已经没有什么疑问了。如果还有疑问的详细理解上面两条规则。代码2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// step1: 生成基础结构function P()&#123; this.m1=10; this.m2=&#123; m2_2:20 &#125;;&#125;P.prototype.m0=1;function C()&#123; &#125;var p = new P();C.prototype.m3 = 30;C.prototype=p;var c1 = new C();var c2 = new C();// end step1// step2: 操作/赋值c1.m0=2;c1.m1=11;c1.m2.m2_2=21;c2.m1=12;c2.m2=&#123; m2_2:22&#125;;P.prototype.m3 = 31;Object.prototype.m0=3;// end step2// step3: 打印输出console.log("c1.m0=",c1.m0);console.log("c1.m1=",c1.m1);console.log("c1.m2.m2_2=",c1.m2.m2_2);console.log("c1.m2.m0=",c1.m2.m0);console.log("c1.m3=",c1.m3);console.log("c2.m0=",c2.m0);console.log("c2.m1=",c2.m1);console.log("c2.m2.m2_2=",c2.m2.m2_2);console.log("c2.m2.m0=",c2.m2.m0);console.log("c2.m3=",c2.m3);console.log("p.m0=",p.m0);console.log("p.m1=",p.m1);console.log("p.m2.m2_2=",p.m2.m2_2);console.log("p.m2.m0=",p.m2.m0);console.log("p.m3=",p.m3);运行结果如下：对这个结果有异议的同鞋，欢迎指正！同时建议大家可以打开浏览器亲自测试一下上面的代码，对理解后面的内存结构分析很有帮助。结果分析首先我们看一下他们的内存结构。在执行完step1代码片段，我们得到的内存结构如下图：大家会发现，这个内存结构比之前的那个内存接口复杂好多，其实这个只是表面现象，因为他们的所遵循的内存使用规则完全一样的，这里就只是多了一个内存片段而已。对于上面的结构图有疑问的可以留言，或者可以直接在浏览器里面验证，如果不知道验证方法的可以留言讨论。同时大家注意上面红线和黑线的区别。在执行玩step2代码片段，我们得到的内存结构如下图：有了第二部的内存结构图，我相信大家对于第step3中的输出已经没有什么疑问了。如果还有疑问的详细理解上面两条规则。未完待续。。。（java/c++内存分析和比较）]]></content>
    </entry>

    
  
  
</search>
